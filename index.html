<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Index of Computer System and Security</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="computer system, computer security" />
  
  
  
  
  <meta name="description" content="Diting0x@">
<meta property="og:type" content="website">
<meta property="og:title" content="Index of Computer System and Security">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Index of Computer System and Security">
<meta property="og:description" content="Diting0x@">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Index of Computer System and Security">
<meta name="twitter:description" content="Diting0x@">
  
    <link rel="alternate" href="/atom.xml" title="Index of Computer System and Security" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/hiero.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>

<body>
  <header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            <a href="/" title="Index of Computer System and Security" rel="home">
              Index of Computer System and Security</a>
          </h1>
          <div class="site-description">Diting0x@</div>

            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>
            <div class="clearfix sf-menu">

              <ul id="main-nav" class="nmenu sf-js-enabled">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/syssec">系统安全</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/architecture">系统结构</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/virtualization">虚拟化</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/malware">恶意代码</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/conferences">主流会议</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/courses">名人课堂</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/academy">学术专家</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/news">安全事件</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/knowledge">小科普</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/share">技术分享</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/contribution">本站达人</a> </li>
                    
              </ul>
            </div>
          </nav>


      </div>
  </div>
</header>




  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-bypassaslr-analysis"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170807/bypassaslr-analysis/">bypassaslr-analysis</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170807/bypassaslr-analysis/" class="article-date">
	  <time datetime="2017-08-07T04:42:08.000Z" itemprop="datePublished">八月 7, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ASLR保护机制被突破的攻击技术分析"><a href="#ASLR保护机制被突破的攻击技术分析" class="headerlink" title="ASLR保护机制被突破的攻击技术分析"></a>ASLR保护机制被突破的攻击技术分析</h1><html xmlns:wb="http://open.weibo.com/wb" xml:lang="en" lang="en"><br><head><br>    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"><br>    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"><br>        <meta name="keywords" content="aslr,bypass aslr"><br>        <meta name="description" content="在本文中，我们对现有的AnC进行了重大的升级改造。AnC是一种针对MMU的EVICT + TIME旁路攻击，它能够对Intel、ARM和AMD等公司的20多种微架构的处理器的页表缓存的大小、内部体系结构以及它们与其他缓存的交互方式进行逆向。本文为针对突破ASLR保护机制攻击技术的分析。"><br>        <meta property="wb:webmaster" content="224437c7be31d633"><br><br>    <script type="text/javascript" src="http://s7.qhimg.com/!56caa871/xpc_sync_height.js"></script><br>    <link rel="stylesheet" type="text/css" href="/css/reset.css"><br>    <link rel="stylesheet" type="text/css" href="/css/common_new.css?v=4.4.2.1"><br>    <link rel="stylesheet" type="text/css" href="/css/jquery.notyfy.css"><br>    <link rel="stylesheet" type="text/css" href="/css/notyfy.theme.default.css"><br>    <link rel="stylesheet" type="text/css" href="/css/s_common.css?v=2.2.7" media="only screen and (max-device-width:900px), only screen and (max-width:900px)"><br>    <script type="text/javascript" src="/js/jquery.min.js?v=3.1"></script><br>    <script type="text/javascript" src="/js/jquery.notyfy.js"></script><br>    <script type="text/javascript" src="/js/iscroll.js"></script><br>    <script src="http://js.passport.qihucdn.com/5.0.3.js"></script><br>    <script type="text/javascript"><br>        var myScroll, myNavScroll;<br><br>        function iscrollLoaded(){<br>            myScroll = new IScroll(‘#wrapper’,<br>              {<br>                scrollX: true,<br>                scrollY: false,<br>                bounceEasing: ‘circular’,<br>                eventPassthrough: true,<br>                preventDefault: false,<br>                bounceTime: 500<br>              }<br>            );<br>        }<br><br>        $(function(){<br><br>            //导航横向滚动<br><br><br>            function setNavWidth(){<br><br>                /<em> 计算导航宽度 </em>/<br>                var allWidth = $(window).width();<br>                var scroller = $(‘#scroller’);<br><br>                if(allWidth &gt; 900){<br>                    scroller.find(‘ul’).add(scroller.find(‘.scroll’)).removeAttr(‘style’);<br>                    scroller.css(‘overflow’, ‘visible’);<br>                    if(myNavScroll) myNavScroll.destroy();<br>                }else{<br><br>                    var width = 0;<br>                    scroller.find(‘.scroll’).children(‘ul’).children(‘li’).each(function(index, el) {<br>                        if(!$(this).hasClass(‘mobile-hide’)){<br>                            width += $(this).outerWidth();<br>                        }<br>                    });<br>                    scroller.find(‘ul’).add(scroller.find(‘.scroll’)).width(width);<br><br>                    if(myNavScroll) myNavScroll.destroy();<br><br>                    myNavScroll = new IScroll(‘#scroller’, {<br>                        scrollX: true,<br>                        scrollY: false,<br>                        momentum: false,<br>                        click: true<br>                    });<br><br>                }<br><br>            }<br>            setNavWidth();<br>            $(window).resize(function(event) {<br>                setNavWidth();<br>            });<br><br>        });<br><br>    </script><br></head><br><body onload="iscrollLoaded();"><br><div id="is-mobile"></div><br><br><br><br><br><br><div class="content clearfix"><br>  <div class="main"><br>      <div class="article"><br>          <div id="article_box"><br>            <h2>【技术分享】ASLR保护机制被突破的攻击技术分析</h2><p>本文转自安全客，并附上链接:<a href="http://bobao.360.cn/learning/detail/3520.html" target="_blank" rel="external">http://bobao.360.cn/learning/detail/3520.html</a> <br><a class="text-more" href="http://www.cs.vu.nl/~herbertb/download/papers/revanc_ir-cs-77.pdf" target="_blank">论文原文链接：http://www.cs.vu.nl/~herbertb/download/papers/revanc_ir-cs-77.pdf</a></p><br><br>            <p class="article-msg"><br><br>            </p><br>            <hr size="1"><br>            <div class="article-msg"><br><br>            </div><br>            <p></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></strong></span></p><hr><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">最近，基于硬件的攻击已经开始通过Rowhammer内存漏洞或旁路地址空间布局随机化保护机制来攻击系统了，这些攻击方式都是基于处理器的内存管理单元（MMU）与页表的交互交互方式的。这些攻击通常需要重复加载页表，以观察目标系统行为的变化情况。为了提高MMU的页表查找速度，现代处理器都使用了多级缓存，例如转译查找缓存（translation lookaside buffers，TLB）、专用页表缓存，甚至通用数据缓存。要想攻击得手，需要在访问页表之前可靠地刷新这些缓存。为了从非特权进程中刷新这些缓存，攻击者需要基于这些缓存的内部体系结构、大小以及缓存交互方式来创建专门的内存访问模式。虽然关于TLB和数据高速缓存的信息通常都会在供应商的处理器手册中发布，但是关于不同处理器上的页表高速缓存的特性方面的信息却鲜有提及。在本文中，我们改进了最近提出的针对MMU的EVICT + TIME攻击，对来自Intel、ARM和AMD的20种不同微架构中页表缓存与其他缓存的内部架构，大小以及其交互方式。同时，我们以代码库的形式将我们的发现公之于众，该代码库不仅提供了一个方便的接口来刷新这些缓存，同时还可以用来在新的体系结构上自动逆向页表缓存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">引言</span></strong></span></p><hr><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">由于添加到系统中的高级防御日益增加，致使针对软件的攻击的难度也是与日俱增，因此，针对硬件的攻击反而成为一种更有吸引力的替代方案。在这些攻击也是五花八门，既有利于Rowhammer漏洞攻击系统的，也有使用旁路攻击破坏地址空间布局随机化来泄漏加密密钥的，甚至还有用来跟踪鼠标移动的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在这些针对硬件的攻击中，有许多攻击都是通过滥用现代处理器与内存来实现的。目前，所有的处理器的核心都是存储器管理单元（MMU），它通过在多个进程之间提供虚拟化内存来简化可用物理存储器的管理工作。MMU使用称为页表的数据结构来执行虚拟存储器到物理存储器之间的转换。页表是基于硬件的攻击的目标所在。例如，由Rowhammer漏洞导致的页表页中的单个位翻转，将会授予攻击者某种访问权限来访问本来无法访问的物理内存，从而进一步获得超级用户权限。此外，诸如ASLR和其他使用ASLR引导的安全防御机制都依赖于代码或数据都是被随机存储到虚拟存内存中这一特性的。由于这个（秘密）信息被嵌入在页表中，攻击者可以利用MMU与页表的交互方式进行旁路攻击，以获取这些机密信息。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">从虚拟内存到物理内存的转换通常会很慢，因为它需要进行多次内存访问来解析原始虚拟地址。为了提高性能，现代处理器都使用多级缓存，例如转译查找缓存（TLB）、专用页表缓存，甚至通用数据缓存。为了成功攻击页表，攻击者经常需要重复刷新这些缓存，以观察系统在处理页表时的行为。通过参阅处理器手册，人们可以很容易找到TLB和数据高速缓存的各种详细信息。然而，关于页表缓存的信息，例如它们的大小和行为，通常是很难找到的。因为没有这些信息，攻击者需要借助于试错法，所以，如果他们要想打造可以适用于多种体系结构上的攻击的话，难度可想而知。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在本文中，我们对现有的AnC进行了重大的升级改造。AnC是一种针对MMU的EVICT + TIME旁路攻击，它能够对Intel、ARM和AMD等公司的20多种微架构的处理器的页表缓存的大小、内部体系结构以及它们与其他缓存的交互方式进行逆向。AnC依赖于以下事实：MMU查找的页表将被存储在最后一级高速缓存（LLC）中，以供下一次查找时使用，从而提高地址转换速度。通过刷新LLC的部分内容和对页表查找进行定时，AnC可以识别出LLC的哪些部分是用来存储页表的。除了刷新LLC，AnC还需要刷新TLB以及页表缓存。由于有关TLB和LLC的大小的信息是可知的，所以攻击者可以使用AnC来逆向自己感兴趣的页表缓存的特性，如其内部结构和大小等。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">简而言之，我们做出了以下贡献：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 176, 80);">我们描述了一种新技术，可以用来对现代处理器中非常常见却无文档说明的页表缓存进行逆向工程。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 176, 80);">我们利用Intel、ARM和AMD的20种不同微结构处理器对我们的技术进行了深入评估。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 176, 80);"><span style="color: rgb(0, 176, 80); font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">我们以开源软件的形式发布了用于刷新缓存的框架实现。我们实现的框架提供了一个方便的接口，可以方便地应用于我们已经测试的各种微架构上，来刷新页表缓存，并且它还可以用来自动检测新处理器上的页表缓存。更多信息，请访问：&nbsp;</span><span style="color: rgb(0, 176, 80); font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;"><a href="https://www.vusec.net/projects/anc" _src="https://www.vusec.net/projects/anc" target="_blank" rel="external">https://www.vusec.net/projects/anc</a>&nbsp;</span></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">背景和动机&nbsp;</span></strong></span></p><hr><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">在本节中，我们讨论分页内存管理机制和它在大多数现代处理器上的实现。此外，我们还将考察MMU是如何进行虚拟地址转换的，以及用于提高这种转换性能的各种缓存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">页式技术和MMU</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">页面技术已经成为现代处理器架构的一个组成部分，因为它能够通过虚拟化技术来简化物理内存的管理：由于地址空间有限，操作系统不再需要重新分配应用程序的整个内存，并且不再需要处理物理内存碎片。此外，操作系统可以限制进程访问的内存空间，防止恶意代码或故障代码干扰其他进程。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">它所带来的直接后果，就是许多现代处理器架构都采用了MMU，一个负责将虚拟地址转换为相应物理地址的硬件组件。转换信息被存储在页表中——一种多级单向树，每个级别都可以由虚拟地址的一部分进行索引，从而选择下一级页表，或者在叶级别，也就是物理页面。因此，每个虚拟地址都能够从树的根节点到叶节点唯一地选出一条路径以找到对应的物理地址。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">图1详细展示了MMU是如何在x86_64上执行虚拟地址转换的。首先，MMU读取CR3寄存器以找到顶级页表的物理地址。然后，用虚拟地址的前9位作为索引在该页表中选择页表项（PTE）。这个PTE包含对下一级页表的引用，然后用虚拟地址中接下来9位的作为索引继续选择页表项。通过对下两个级别重复该操作，MMU就可以在最低级页表中找到对应于0x644b321f4000的物理页了。</span></p><p style="text-align:center"><img src="http://p5.qhimg.com/t0160dec3ffed79a683.png" title="t01e6858fccdfa83b82.png" alt="http://p2.qhimg.com/t01e6858fccdfa83b82.png"></p><p style="text-align: center; text-indent: 0em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">图1：在x86_64架构上，将0x644b321f4000转换成其对应的内存页的MMU的页表查询过程。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">缓存MMU的操作</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">如果MMU可以避免从头开始解析其最近已解析过的虚拟地址的话，那么内存的访问性能就会得到极大的改善。为此，CPU会将解析过的地址映射存储到TLB高速缓存中。因此，如果在TLB中命中的话，就无需查询各个页表了，而这个过程是需要花费许多时间的。此外，为了提高TLB未命中时的性能，处理器会将页表数据存储到数据高速缓存中。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">现代处理器还可以进一步提高TLB未命中情况下的地址转换性能，方法是使用页表缓存或转译缓存来缓存不同级别页表的PTE。虽然页表缓存使用物理地址和PTE索引进行索引，但是转换缓存使用的是已经过部分解析的虚拟地址。通过转译缓存，MMU可以查找虚拟地址并选择具有最长匹配前缀的页表，即选择存在于给定虚拟地址的高速缓存内的最低级页表。虽然这允许MMU免去部分页表的查询工作，但是转译缓存的实现同时也带来了额外的复杂性。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">此外，这些高速缓存在实现方式也可以多种多样，不仅可以实现多个专用的高速缓存供不同的页表级使用，而且还可以实现单个高速缓存来供不同的页表级共享，或者甚至可以作为一个可以缓存PTE的TLB来加以实现。例如，AMD的Page Walking Caches（就像在AMD K8和AMD K10微架构中发现的那样）采用的是统一页表缓存的方式，而Intel的Page-Structure Caches的实现采用的是专用的转译缓存的方式。类似地，ARM在针对低功耗和硅利用率而优化的设计中实现了统一的页表缓存（页表查询缓存），同时它们在针对高性能而优化的设计中实现了统一的转换缓存（中间页表查找缓存）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">图2展示了当MMU翻译虚拟地址时不同高速缓存的交互方式。虽然TLB和缓存具有完整的文档说明，但是关于页表和翻译缓存的诸多细节仍然缺乏相关的文档说明。</span></p><p style="text-align:center"><img src="http://p3.qhimg.com/t019def034f041288b0.png" title="t01171424d03658fcfa.png" alt="http://p3.qhimg.com/t01171424d03658fcfa.png"></p><p style="text-align: center; text-indent: 0em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">图2：MMU的通用实现以及将虚拟地址转换为物理地址的所有组件。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">研究动机</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">最近的基于页表滥用的硬件攻击，都要求能够正确刷新页表缓存，才能完成相应的操作。例如，预取攻击依赖于一个正确的时机，届时虚拟地址转换恰好在一个页表缓存中部分成功，借以了解内核中随机化地址方面的信息。而Rowhammer攻击在处理页表时则需要重复刷新TLB和页表缓存，以扫描物理内存中的敏感信息&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">另一个需要刷新页表缓存的例子是AnC攻击。MMU的页表查询结果会被缓存到LLC中。AnC利用这个事实来完成FLUSH + RELOAD攻击，以确定出MMU在页表查询期间访问的页表内存页中的偏移量。知道这个偏移量后，就能找到经过随机化处理后的虚拟地址，从而攻陷ASLR防御机制。但是，为了完成一次可靠的攻击，AnC需要尝试多种不同的访问模式，并且每种模式都需要尝试许多次，并且每次都需要有效地刷新页表缓存以便触发完整的页表查询流程。因此，关于页表缓存的内部工作机制的知识，对于完成正确高效的AnC攻击来说是非常必要的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在某些情况下，TLB用作页表缓存。在这些情况下，cpuid指令可以用来了解不同TLB的大小，这样就知道了不同页表缓存的大小了。但是，在一些x86_64微体系结构上，cpuid指令并不会给出所有TLB的大小。例如，尽管在Intel Sandy Bridge和Ivy Bridge处理器上存在可以缓存1 GB页面的TLB，但这些信息根本无法通过cpuid指令获取。此外，在其他CPU体系结构上，可能没有办法获取TLB的大小，或者页表缓存可能已经实现为完全独立的单元。因此，我们需要一个更通用的方法来探索页表缓存的重要属性。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">页表缓存逆向技术</span></strong></span></p><hr><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">我们现在开始讨论如何改造AnC技术，以探测页表缓存的各种属性。实际上，我们需要克服许多挑战，才能使AnC适用于不同的架构，这些将在后面展开详细的讨论。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">使用MMU的缓存信号&nbsp;</span></strong></span></p><p style="text-align:center"><img src="http://p7.qhimg.com/t0157edf8ac3bdb1710.png" title="t0122307c8196661603.png" alt="http://p8.qhimg.com/t0122307c8196661603.png"></p><p style="text-align: center; text-indent: 0em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">代码清单1：设计原理示意代码</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在了解页表缓存时，我们依赖于这样一个事实，即MMU的页表查询结束于目标处理器的数据缓存处。下面以Intel x86 64为例进行说明，这里假设使用了四个页表级别，那么给定虚拟地址v的MMU的页表查询会将来自4个页表内存页的4个缓存行放入L1数据缓存以及L3，假设L3包括L1。这样一来，如果高速缓存行仍然位于数据缓中的话，那么再次对虚拟地址v进行页面查询的时候，就会变得相当快。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">CPU数据缓存被分为不同的缓存集。每个缓存组可以存储多达N个缓存行，这被称为N路组相关缓存。Oren等人发现，给定两个不同的（物理）内存页面，如果它们的第一个缓存行属于同一缓存组，那么页面中的其他缓存行也会共享（不同的）缓存组，即如果我们在一个与缓存行边界对齐的页面内选择了偏移t，那么另一内存页中的偏移t处的缓存行就会共享相同的缓存组。这是因为：为了让两个内存页的第一个缓存行位于同一个缓存组中，那么决定缓存组和切片（slice）的两个页面的物理地址的所有位必须是相同的，并且两个页面内的偏移将共享相同的低位。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">利用缓存的这个特性，我们可以轻松利用一些内存页来用作驱逐缓冲区。假设用于转换虚拟地址v的四个页表项中的一个正好位于页表内存页的偏移零处。当我们访问驱逐缓冲区中所有页面的第一个缓存行的时候，我们将从缓存中驱逐掉MMU的最近转换虚拟地址v时的页表查询结果。因此，虚拟地址v的下一次页表查询将会变得稍微慢一些，因为它需要从内存获取前面提到过的页表项。这就是一个EVICT + TIME攻击的例子，通过它，AnC就能够在存储页表项的内存页面中，从潜在的64个缓存行中找出4个缓存行。注意，通过尝试来自虚拟地址v之外的各种偏移，我们可以弄清楚每个级别中的页表项对应于哪些缓存行中。例如，如果我们在v + 32 KB上执行EVICT + TIME，与在v上执行EVICT + TIME时相比发生变化的缓存行对应于级别1页表的缓存行。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这是因为在x86 64架构上，每个缓存行可以存储8个页表项，映射32 KB的虚拟内存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">假设一个页表缓存对应于一个页表级别，若不刷新该级别的页表缓存的话，我们就无法观察MMU在该级别上的活动。举例来说，假设有一个页表缓存，它用来缓存具有32个表项的2级页表。假设2级页表中的每个表项可以映射2 MB的虚拟内存，当我们访问连续的64 MB虚拟缓冲区（以2MB为边界）的时候，我们将刷新该页表缓存。因此，我们可以轻松地通过蛮力方式穷举每个级别的潜在页表缓存的大小。例如，如果在x86 64架构的Intel处理器上我们无法通过AnC观察到上面三级页表的信号，那是因为该页面（转译）缓存位于2级页表中。然后，我们可以蛮力破解该缓存的大小，然后移动到上一级。代码清单1为我们展示了具体的实现过程。注意，与AnC不同，我们采用了一个已知的虚拟地址，所以我们可以准确知道MMU信号应该出现在缓存中的什么地方。当然，为了提高清单1中代码的鲁棒性，使其适用于多种处理器架构，我们还需要解决许多问题，具体将在后文中详细展开。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">确保存取顺序</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">许多现代CPU架构都实现了乱序执行技术，其中指令的执行顺序取决于输入数据的可用性，而不是它们在原始程序中的顺序。在应用乱序执行技术之后，指令在解码之后被插入等待队列中，直到它们的输入操作数可用为止。一旦输入操作数可用，该指令就会被发送到相应的执行单元，这样的话，这条指令就会先于前面的指令由该单元执行了。此外，这种CPU架构通常都是超标量的，因为它们具有多个执行单元，并且允许将多条指令调度到这些不同的执行单元中并行执行。在指令执行完成之后，它们的结果将被写入另一个现已“退休的”队列中，该队列以原始程序的顺序进行排序，以保证正确的逻辑顺序。此外，有些现代CPU架构不仅具有针对指令的乱序执行的能力，而且它们还具有对内存操作进行重新排序的能力。为了测量这种CPU体系结构上单个指令的执行时间，我们必须在定时指令之前和之后注入内存屏障，并目标代码之前和之后插入代码屏障，以清除正在运行的指令和内存操作。为了串行化内存存取顺序，我们可以在ARMv7-A和ARMv8-A上面使用dsb指令，而在x86_64上，可以通过rdtscp和mfence指令保证串行化的内存存取顺序。为了串行化指令顺序，我们可以在x86_64上使用cpuid指令，在ARMv7-A和ARMv8-A上使用isb sy指令。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">定时</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在缓存命中和缓存未命中的情况下，存在从几百纳秒或甚至几十纳秒的性能差异，因此我们需要高精度的定时源才能能够区分缓存是否命中。虽然在兼容POSIX的操作系统上可以通过clock_gettime（）来获取定时信息，但是在各种ARMv7-A和ARMv8-A平台上，它们提高的定时信息却不够精确。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">许多现代处理器架构都提供了专用寄存器来计数处理器的周期数，从而提供高精度的定时源。虽然这些寄存器可通过各种rdtscp指令中的非特权rdtsc进行访问，但默认情况下，ARMv7-A和ARMv8-A上的性能监视单元（PMU）提供的PMCCNTR寄存器是无法访问的。此外，当最初引入这些寄存器时，没有确保它们在内核之间是同步的，并且直接利用处理器时钟使其计数进行递增。在这些情况下，进程迁移和动态频率调整会对定时造成一定程度的影响，甚至让它变得不再可靠。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">考虑到当今大多数处理器都具有多个内核，在循环中简单递增全局变量的线程可以提供一个基于软件的周期计数器。我们发现这种方法在各种平台上都能够可靠地工作，并且可以提供很高的精度度。请注意，JavaScript版本的AnC也采用了类似的技术来构建高精度的计时器。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">讨论</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">利用x86_64平台上的cpuid以及ARMv7-A和ARMv8-A上的扁平设备树（FDT），我们可以检测包括处理器属性（如TLB、缓存、处理器和供应商的名称）和微架构的等处理器拓扑信息。有了这些信息，我们就可以构建一个适当的驱逐组，以便在缺少页表和转译缓存的架构上成功地自动执行AnC攻击。因此，在带有页表或转译缓存的体系结构上，我们可以通过构建驱逐组并尝试渐进式执行AnC攻击来逆向这些缓存的大小。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">评测</span></strong></span></p><hr><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">我们使用Intel、ARM和AMD等公司从2008年到2016年期间发布的20个不同的CPU对我们的技术进行了全面的评估，并发现了每个页表级的页表缓存的具体大小（我们称2级页表为PL2），以及利用我们的技术逆向这个信息所需要的时间。同时，我们还提供了每种CPU的缓存和TLB的大小。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">我们的研究结果总结见表1。下面，我们将逐一介绍各个供应商产品在这些方面的特点和差异。</span></p><p style="text-align:center"><img src="http://p1.qhimg.com/t0199001842b2ddad50.png" title="t01a2b8b8d5f2b39f23.png" alt="http://p8.qhimg.com/t01a2b8b8d5f2b39f23.png"></p><p style="text-align: center; text-indent: 0em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">表1：22种不同微架构的规格和逆向结果</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Intel</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在英特尔的处理器中，最后一级缓存是包含型的，这意味着最后一级缓存中可用的数据必须在较低级别的缓存中可用。由于这个特性，只要从最后一级缓存中逐出缓存行就足够了，因为这将导致它们将被从较低级别的缓存中逐出。我们发现，英特尔的页面结构缓存或切片转译缓存是在Intel Core和Xeon处理器上实现的，至少是Nehalem微架构。在Intel Core和Xeon处理器上，具有可供24-32个PL2表项和4-6个PL3表项的高速缓存，而在Silvermont处理器上，只有一个高速缓存，仅仅可以供12-16个PL2表项使用。在我们的多次测试期间，我们注意到，它们主要集中于几个彼此接近的数字。保守的攻击者可以总是选择更大的数字。在Intel Core和Xeon处理器以及Silvermont处理器上，我们发现cpuid报告的TLB的大小正好适用于完全刷新这些缓存，这很可能是因为用于缓存巨型页面的TLB也包含了缓存中间页面查询的逻辑。最后，我们发现，当Sandy Bridge和Ivy Bridge实现一个TLB来缓存1G页面时，cpuid指令不会报告这个TLB的存在，并且Nehalem和Westmere都实现了一个PL3页面结构缓存，但是没有提供这样的TLB实现。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">AMD</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在AMD的处理器上，LLC是独占型的，这意味着数据最多可以放入一个高速缓存中，以便可以一次存储更多的数据。为了能够正确驱逐缓存行，我们必须分配一个驱逐组，其大小等于高速缓存大小的总和。我们经测试发现，AMD K10微体系结构实现了AMD的页面查询缓存具有24个表项。此外，我们的测试表明，AMD的页面查询缓存没有被Bulldozer微体系结构的设计和该微体系结构的后代所采用。因此，AMD的Bulldozer架构似乎没有提供任何页表或转译缓存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">最后，AMD的Bobcat架构似乎实现了一个带有8到12个表项的页面目录缓存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">ARMv7-A</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">与Intel和AMD的处理器不同，根据片上系统的供应商的不同，有些ARM处理器上的L2缓存可以配置为包含型、独占型或非包含型。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">然而，对于大多数ARMv7-A处理器来说，这些缓存都是配置为非包含型的。在ARMv7-A上，有两个页面级别可用，其中的页表分别提供256和4096个表项，分别可以映射4K和1M空间。对于支持大容量物理内存地址扩展（LPAE）的处理器，则使用三个页面级别，其中每个页表分别提供了512、512和4个表项，可以映射4K、1M和1G空间。即使最后一级页表仅由适合单个缓存行的四个表项组成，但是AnC攻击仍然可以应用于其他两个页面级别，以确定页表和转译缓存的存在性。此外，其低功耗版本（例如ARM Cortex A7）则实现了统一的页表缓存，而面向高性能的版本（例如ARM Cortex A15和A17）则实现了统一的转译缓存。但是，较旧的设计，如ARM Cortex A8和A9，却根本没有任何MMU缓存。同时，我们发现带有64个表项的页表缓存和带有16个表项的转译缓存分别可用于ARM Cortex A7和ARM Cortex A15。此外，我们的程序可以可靠地确定出所有支持和不支持LPAE的ARMv7-A的这些高速缓存的大小，即使在启用所有核心的ARM big.LITTLE处理器上，也可以透明地在不同类型的核心之间来回切换。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192);"><strong>ARMv8-A</strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">ARMv8-A处理器也实现了类似于Intel和AMD的包含型LLC。此外，ARMv8-A使用与x86_64类似的模型，提供了四个页面级别，每级512个表项。然而，在Linux系统上，仅使用了三个页面级别来提高页表查找的性能。与ARMv7-A类似，ARMv8-A在其低功耗版本（例如ARM Cortex A53）上实现了4路关联64项统一页表缓存，并在注重性能的版本，例如ARM Cortex A57， A72和A73中实现了一个统一的转译缓存。此外，我们还发现ARM Cortex A53实现了一个具有64个表项的页表缓存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">讨论</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">如代码清单2所示，我们可以通过分配与缓存项一样多的页面，然后“触动”每个页面级别中的每个页面来刷新TLB和页面结构。通过触动这些页面，MMU就会被迫执行虚拟地址转换以替换缓存中的现有的表项。此外，通过使用页面大小作为每个页面级别的步幅，我们可以利用巨型页面来刷新页面结构缓存或TLB。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></p><pre class="brush:plain;toolbar:false">1&nbsp;/<em>&nbsp;Flush&nbsp;the&nbsp;TLBs&nbsp;and&nbsp;page&nbsp;structure&nbsp;caches.&nbsp;</em>/<br>2&nbsp;for&nbsp;(j&nbsp;=&nbsp;0,&nbsp;level&nbsp;=&nbsp;fmt-&gt;levels;&nbsp;j&nbsp;&lt;=&nbsp;page_level;&nbsp;++level,&nbsp;++j)<br>3&nbsp;{<br>4&nbsp;p&nbsp;=&nbsp;cache-&gt;data&nbsp;+&nbsp;cache_line&nbsp;<em>&nbsp;cache-&gt;line_size;<br>5&nbsp;6<br>for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;level-&gt;ncache_entries;&nbsp;++i)&nbsp;{<br>7&nbsp;</em>p&nbsp;=&nbsp;0x5A;<br>8&nbsp;p&nbsp;+=&nbsp;level-&gt;page_size;<br>9&nbsp;}<br>10&nbsp;}</pre><p style="text-align: center; text-indent: 0em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">代码清单2：刷新TLB和页面结构缓存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">相关工作</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;"></span></p><hr><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">针对页表的硬件攻击</span></strong></span><br></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">AnC攻击可以根据MMU将PTE缓存到LLC中的方式来发动EVICT + TIME攻击，从而利用JavaScript给用户空间ASLR去随机化。而使用预取指令的硬件攻击则依赖于缓存的TLB表项和部分转译来实现内核空间ASLR的去随机化。页表是Rowhammer攻击最有吸引力的目标。Drammer和Seaborn的硬件攻击会破坏PTE，使其指向页表页面。但是，如果不能正确刷新页表缓存的话，所有这些攻击都将失败。本文提供了一种用于在各种体系结构上刷新这些缓存的通用技术。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">逆向硬件</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">针对商品化硬件的逆向工程已经随着对硬件的攻击的增加而变得日益流行。Hund等人对英特尔处理器如何将物理内存地址映射到LLC进行了逆向工程。Maurice 等人则使用性能计数器来简化了该映射功能的逆向过程。DRAMA则使用DRAM总线的被动探测以及对DRAM行缓冲器的定时攻击，对内存控制器将数据放置在DRAM模块上的原理进行了逆向工程。在本文中，我们对现有处理器的MMU中常见的页表缓存的各种未公开的特性进行了相应的逆向工程。</span></p><p style="text-indent: 2em; text-align: left;"><br></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">结束语</span></strong></span></p><hr><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">当前，基于硬件的攻击（如缓存或Rowhammer攻击）开始变得越来越流行，因为针对软件的攻击已经变得越来越具有挑战性。对于跨处理器的鲁棒性攻击方法来说，掌握各种处理器内缓存的相关特性是至关重要的。由于这些缓存通常对软件来说是不可见的，因此通常很难找到相关的文档说明。在本文中，我们改进了针对MMU的现有EVICT + TIME攻击，使其能够逆向最新处理器上常见的页表缓存的各种特性。我们将该技术应用于20个不同的微架构，发现其中17个实现了这样的页表缓存。我们的开源实现提供了一个便利的接口，可以用于在这16个微体系结构上刷新这些缓存，并可以在未来的微架构上自动检测页表缓存。更多信息，请访问：&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;"><a href="https://www.vusec.net/projects/anc" _src="https://www.vusec.net/projects/anc" target="_blank" rel="external">https://www.vusec.net/projects/anc</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">参考文献</span></strong></span></p><hr><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">[1] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti.</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Control-flow Integrity. CCS’05.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[2] T. W. Barr, A. L. Cox, and S. Rixner. Translation&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">caching: skip, don’t walk (the page table). ISCA’10.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[3] A. Bhattacharjee. Large-reach memory management&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">unit caches. MICRO’13.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[4] E. Bosman, K. Razavi, H. Bos, and C. Giuffrida.</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Dedup Est Machina: Memory Deduplication as an&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Advanced Exploitation Vector. SP’16.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[5] X. Chen, A. Slowinska, D. Andriesse, H. Bos, and&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">C. Giuffrida. StackArmor: Comprehensive Protection&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">From Stack-based Memory Error Vulnerabilities for&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Binaries. NDSS.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[6] D. Cock, Q. Ge, T. Murray, and G. Heiser. The Last&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Mile: An Empirical Study of Timing Channels on&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">seL4. CCS’14.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[7] S. Crane, C. Liebchen, A. Homescu, L. Davi,&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">P. Larsen, A.-R. Sadeghi, S. Brunthaler, and&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">M. Franz. Readactor: Practical Code Randomization&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Resilient to Memory Disclosure. NDSS’15.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[8] T. H. Dang, P. Maniatis, and D. Wagner. The&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">performance cost of shadow stacks and stack canaries.&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">ASIA CCS’15.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[9] D. Evtyushkin, D. Ponomarev, and N. Abu-Ghazaleh.</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Jump Over ASLR: Attacking Branch Predictors to&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Bypass ASLR. MICRO’16.&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[10] C. Giuffrida, A. Kuijsten, and A. S. Tanenbaum.</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Enhanced Operating System Security Through&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Efficient and Fine-grained Address Space&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Randomization. SEC’12.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[11] B. Gras, K. Razavi, E. Bosman, H. Bos, and&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">C. Giuffrida. ASLR on the Line: Practical Cache&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Attacks on the MMU. NDSS’17.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[12] D. Gruss, C. Maurice, A. Fogh, M. Lipp, and&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">S. Mangard. Prefetch Side-Channel Attacks:&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Bypassing SMAP and Kernel ASLR. CCS’16.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[13] R. Hund, C. Willems, and T. Holz. Practical Timing&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Side Channel Attacks Against Kernel Space ASLR.&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">SP’13.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[14] AMD64 Architecture Programmer’s Manual, Volume&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">2: System Programming. Publication No.: 24593, May&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">2013.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[15] Intel 64 and IA-32 Architectures Optimization&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Reference Manual. Order Number: 248966-032,&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">January 2016.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[16] Y. Jang, S. Lee, and T. Kim. Breaking kernel address&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">space layout randomization with intel tsx. CCS’16.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[17] K. Koning, H. Bos, and C. Giuffrida. Secure and&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Efficient Multi-Variant Execution Using&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Hardware-Assisted Process Virtualization. DSN’16.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[18] V. Kuznetsov, L. Szekeres, M. Payer, G. Candea,&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">R. Sekar, and D. Song. Code-pointer integrity.&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">OSDI’14.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[19] M. Lipp, D. Gruss, R. Spreitzer, C. Maurice, and&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">S. Mangard. Armageddon: Cache attacks on mobile&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">devices. SEC’16.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[20] K. Lu, C. Song, B. Lee, S. P. Chung, T. Kim, and&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">W. Lee. ASLR-Guard: Stopping Address Space&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Leakage for Code Reuse Attacks. CCS’15.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[21] C. Maurice, N. L. Scouarnec, C. Neumann, O. Heen,&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">and A. Francillon. Reverse Engineering Intel&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Last-Level Cache Complex Addressing Using&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Performance Counters. RAID’15.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[22] Y. Oren, V. P. Kemerlis, S. Sethumadhavan, and A. D.&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Keromytis. The Spy in the Sandbox: Practical Cache&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Attacks in JavaScript and their Implications. CCS’15.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[23] P. Pessl, D. Gruss, C. Maurice, M. Schwarz, and&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">S. Mangard. DRAMA: Exploiting DRAM Addressing&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">for Cross-CPU Attacks. SEC’16.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[24] K. Razavi, B. Gras, E. Bosman, B. Preneel,</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">C. Giuffrida, and H. Bos. Flip Feng Shui: Hammering&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">a Needle in the Software Stack. SEC’16.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[25] M. Seaborn. Exploiting the DRAM Rowhammer Bug&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">to Gain Kernel Privileges. In Black Hat USA,&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">BH-US’15.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[26] V. van der Veen, Y. Fratantonio, M. Lindorfer,&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">D. Gruss, C. Maurice, G. Vigna, H. Bos, K. Razavi,&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">and C. Giuffrida. Drammer: Deterministic&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Rowhammer Attacks on Mobile Platforms. CCS’16.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[27] Y. Yarom and K. Falkner. FLUSH+RELOAD: A High&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Resolution, Low Noise, L3 Cache Side-channel Attack.&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">SEC’14.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[28] X. Zhang, Y. Xiao, and Y. Zhang. Return-Oriented&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Flush-Reload Side Channels on ARM and Their&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Implications for Android Devices. CCS’16.&nbsp;</span></p><p></p><br><hr><br><br>                        <p>本文由 安全客 翻译，转载请注明“转自安全客”，并附上链接。<br><a class="text-more" href="http://www.cs.vu.nl/~herbertb/download/papers/revanc_ir-cs-77.pdf" target="_blank">原文链接：http://www.cs.vu.nl/~herbertb/download/papers/revanc_ir-cs-77.pdf</a></p><br>                      </div><br>          <div style="margin-top: 20px;background-color:#FFFFFF"><br>    <input type="hidden" id="detail_title" name="detail_title" value="【技术分享】ASLR保护机制被突破的攻击技术分析 - 安全客 - 有思想的安全新媒体"><br>    <input type="hidden" id="use_nickname" name="use_nickname" value="0"><br>    <a name="mao"></a><br>    <div class="reg-log mobile-hiden"><br>        <div class="" id="userTo"><br>            <div id="to-list" class="input-text" style=""><br>                <textarea disabled="disabled" class="hide" id="comment-content" to="to"></textarea><br>                <ul id="preadded" style="display:none"><br>                </ul><br>                <div id="to-auto" style="width: 200px"><br>                    <ul id="feed"><br>                    </ul><br>                </div><br>            </div><br>        </div><br>        <input type="hidden" id="source-id" value="3520"><br>        <input type="hidden" id="source-type" value="learning"><br>        <input type="hidden" id="post-comment-url" value="/comment/add"><br>        <input type="hidden" id="post-nickname-url-ajax" value="/comment/randnicknameajax"><br>        <input type="hidden" id="post-check-login-url-ajax" value="/comment/checklogin"><br>        <input type="hidden" id="stoken_comment_set" value="110666b353c7e2fd0e936dbb12d4baf6"><br>            </div><br>    <div class="mobile-hide" style="width: 870px; margin: 0 auto;"><br><br>    </div><br><br><br>    <div class="clearfix"></div><br>    <div class="comments"><br><br></div><br><br>  </div><br>  <div class="side-bar"><br>      <div class="mod hot-news"><br><br></div><br><br>  </div><br><br><br><br></div></div></div></body><br></html>







      
    </div>
    <footer class="entry-meta entry-footer">
      

      
      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-offensivesec"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170807/offensivesec/">offensivesec</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170807/offensivesec/" class="article-date">
	  <time datetime="2017-08-07T04:19:47.000Z" itemprop="datePublished">八月 7, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <html><br>  <head><br>    <meta charset="utf-8"><br>    <meta http-equiv="X-UA-Compatible" content="IE=edge"><br>    <title>CSE590: Schedule</title><br></head><br>  <body><br><header class="site-menu"><br>  <div class="wrap"><br>    <a> Overview:<br>The course will cover a wide range of topics in the area of offensive computer security, trying to strike a balance between core concepts and recent advancements. The main goal of the course is to provide an understanding of various computer security concepts through a more adversarial way of thinking. By focusing on vulnerabilities and exploitation techniques, the course will cover a broad range of topics, including the ethics of offensive security, reverse engineering, software vulnerability discovery and exploitation, malicious code analysis, network traffic interception and manipulation, reconnaissance and information gathering, physical security, and social engineering.<br><br>All topics will be covered from a highly practical perspective, following a mixed format of lectures, hands-on sessions, and paper presentations. Each student will give a short conference-style presentation of one research paper, which the rest of the class should read and discuss. Other requirements include 3–4 programming/hands-on assignments and a long-term course project (a few candidate projects will be provided).<br></a><br>  </div><br></header><br>    <div class="wrap"><br>      <div class="page"><br>  <h2>Schedule</h2><br><table class="schedule"><br>  <thead><br>    <tr><br>      <th class="row-ID"></th><br>      <th class="row-name"></th><br>    </tr><br>  </thead><br>  <tbody><br>    <tr><br>      <td><h3>8/29</h3></td><br>      <td><br>        <h3>Introduction and Basic Concepts</h3><br>        <h4>Recommended Reading</h4><br>        <p><a href="https://www.usenix.org/system/files/login/articles/02_bratus.pdf" target="_blank" rel="external">Why Offensive Security Needs Engineering Textbooks</a></p><br>        <p><a href="http://www.hackercurriculum.org/" target="_blank" rel="external">Hacker Curriculum</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>8/31</h3></td><br>      <td><br>        <h3>Ethics</h3><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>9/5</h3></td><br>      <td><br>        <h3>Labor Day - No Class</h3><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>9/7</h3></td><br>      <td><br>        <h3>Reconnaissance and Information Gathering</h3><br>        <h4>Recommended Reading</h4><br>        <p><a href="http://nmap.org/" target="_blank" rel="external">nmap</a></p><br>        <p><a href="http://phrack.org/issues/51/11.html" target="_blank" rel="external">The Art of Port Scanning</a></p><br>        <p><a href="http://conferences.sigcomm.org/imc/2007/papers/imc76.pdf" target="_blank" rel="external">A Brief History of Scanning</a></p><br>        <p><a href="https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-durumeric.pdf" target="_blank" rel="external">An Internet-Wide View of Internet-Wide Scanning</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>9/12</h3></td><br>      <td><br>        <h3>Network Traffic Interception</h3><br>        <h4>Recommended Reading</h4><br>        <p><a href="http://phrack.org/issues/48/14.html" target="_blank" rel="external">IP-spoofing Demystified</a></p><br>        <p><a href="https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf" target="_blank" rel="external">New Tricks For Defeating SSL In<br>Practice</a></p><br>        <p><a href="https://www.linshunghuang.com/papers/mitm.pdf" target="_blank" rel="external">Analyzing Forged SSL Certificates in the Wild</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>9/14</h3></td><br>      <td><br>        <h3>x86 101</h3><br>        <h4>Recommended Reading</h4><br>        <p><a href="https://www-ssl.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html" target="_blank" rel="external">Intel® 64 and IA-32 Architectures Software Developer Manuals</a></p><br>        <p><a href="https://en.wikibooks.org/wiki/X86_Assembly" target="_blank" rel="external">x86 Assembly</a></p><br>        <p><a href="https://software.intel.com/en-us/articles/introduction-to-x64-assembly" target="_blank" rel="external">Introduction to x64 Assembly</a></p><br>        <p><a href="http://duartes.org/gustavo/blog/category/software-illustrated/" target="_blank" rel="external">Gustavo Duarte’s Software Illustrated blog posts</a></p><br>        <p><a href="http://asmtutor.com/" target="_blank" rel="external">NASM Assembly Language Tutorials</a></p><br>        <p><a href="http://www.bottomupcs.com/" target="_blank" rel="external">Computer Science from the Bottom Up</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>9/19</h3></td><br>      <td><br>        <h3>Reverse Engineering</h3><br>        <h4>Recommended Reading</h4><br>        <p><a href="http://uninformed.org/index.cgi?v=1&a=7&t=sumry" target="_blank" rel="external">Introduction to Reverse Engineering Win32 Applications</a></p><br>        <p><a href="https://beginners.re/" target="_blank" rel="external">Reverse Engineering for Beginners</a></p><br>        <p><a href="https://challenges.re/" target="_blank" rel="external">Reverse Engineering Challenges</a></p><br>        <p><a href="http://crackmes.de/" target="_blank" rel="external">crackmes.de</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>9/21</h3></td><br>      <td><br>        <h3>Memory Corruption 1</h3><br>        <h4>Recommended Reading</h4><br>        <p><a href="http://phrack.org/issues/49/14.html" target="_blank" rel="external">Smashing The Stack For Fun And Profit</a></p><br>        <p><a href="http://www.cultdeadcow.com/cDc_files/cDc-351/index.html" target="_blank" rel="external">Tao of Windows Buffer Overflow</a></p><br>        <p><a href="http://spaf.cerias.purdue.edu/tech-reps/823.pdf" target="_blank" rel="external">The Internet Worm Program: An Analysis</a></p><br>        <p><a href="http://10kstudents.eu/material/" target="_blank" rel="external">Crash course on buffer overflows by the 10K Students initiative</a></p><br>        <p><a href="https://www.exploit-db.com/papers/13205/" target="_blank" rel="external">Using GDB to Develop Exploits - A Basic Run Through</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>9/26</h3></td><br>      <td><br>        <h3>Paper Presentations</h3><br>        <p><a href="https://zmap.io/paper.pdf" target="_blank" rel="external">ZMap: Fast Internet-Wide Scanning and its Security Applications</a></p><br>        <p><a href="http://mdbailey.ece.illinois.edu/publications/ndss16_ipv6.pdf" target="_blank" rel="external">Don’t Forget to Lock the Back Door! A Characterization of IPv6 Network Security Policy</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>9/28</h3></td><br>      <td><br>        <h3>No Class</h3><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>10/3</h3></td><br>      <td><br>        <h3>Memory Corruption 2</h3><br>        <h4>Recommended Reading</h4><br>        <p><a href="http://seclists.org/bugtraq/2000/Sep/214" target="_blank" rel="external">Format String Attacks</a></p><br>        <p><a href="http://phrack.org/issues/57/8.html" target="_blank" rel="external">Vudo malloc tricks</a></p><br>        <p><a href="http://phrack.org/issues/57/9.html" target="_blank" rel="external">Once upon a free()… </a></p><br>        <p><a href="http://phrack.org/issues/60/10.html" target="_blank" rel="external">Basic Integer Overflows</a></p><br>        <p><a href="http://2014.zeronights.org/assets/files/slides/the-past-the-present-and-the-future-of-software-exploitation-techniques.pptx" target="_blank" rel="external">The past, the present and the future of software exploitation techniques [.pptx]</a></p><br>        <p><a href="https://trailofbits.github.io/ctf/exploits/references/tr-2007-153.pdf" target="_blank" rel="external">Low-level Software Security: Attacks and Defenses</a></p><br>        <p><a href="http://www.few.vu.nl//~herbertb/papers/memerrors_raid12.pdf" target="_blank" rel="external">Memory Errors: The Past, the Present, and the Future</a></p><br>        <p><a href="https://people.eecs.berkeley.edu/~dawnsong/papers/Oakland13-SoK-CR.pdf" target="_blank" rel="external">SoK: Eternal War in Memory</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>10/5</h3></td><br>      <td><br>        <h3>Paper Presentations</h3><br>        <p><a href="http://christian-rossow.de/publications/crossarch-ieee2015.pdf" target="_blank" rel="external">Cross-Architecture Bug Search in Binary Executables</a></p><br>        <p><a href="https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final225.pdf" target="_blank" rel="external">Enemy of the State: A State-Aware Black-Box Web Vulnerability Scanner</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>10/10</h3></td><br>      <td><br>        <h3>Code Reuse</h3><br>        <h4>Recommended Reading</h4><br>        <p><a href="http://seclists.org/bugtraq/1997/Aug/63" target="_blank" rel="external">Getting around non-executable stack (and fix)</a></p><br>        <p><a href="http://seclists.org/bugtraq/2000/May/90" target="_blank" rel="external">non-exec stack</a></p><br>        <p><a href="http://phrack.org/issues/58/4.html" target="_blank" rel="external">The advanced return-into-lib(c) exploits: PaX case study</a></p><br>        <p><a href="http://users.suse.com/~krahmer/no-nx.pdf" target="_blank" rel="external">x86-64 buffer overflow exploits and the borrowed code<br>chunks exploitation technique</a></p><br>        <p><a href="https://cseweb.ucsd.edu/~hovav/dist/geometry.pdf" target="_blank" rel="external">The Geometry of Innocent Flesh on the Bone:<br>Return-into-libc without Function Calls (on the x86)</a></p><br>        <p><a href=""></a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>10/12</h3></td><br>      <td><br>        <h3>Paper Presentations</h3><br>        <p><a href="https://users.ece.cmu.edu/~dbrumley/pdf/Schwartz,%20Avgerinos,%20Brumley_2011_Q%20Exploit%20Hardening%20Made%20Easy.pdf" target="_blank" rel="external">Q: Exploit Hardening Made Easy</a></p><br>        <p><a href="http://people.engr.ncsu.edu/tkbletsc/pubs/TCRILC.pdf" target="_blank" rel="external">On the Expressiveness of Return-into-libc Attacks</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>10/17</h3></td><br>      <td><br>        <h3>Paper Presentations</h3><br>        <p><a href="https://users.ece.cmu.edu/~dbrumley/pdf/Cha%20et%20al._2012_Unleashing%20Mayhem%20on%20Binary%20Code.pdf" target="_blank" rel="external">Unleashing MAYHEM on Binary Code</a></p><br>        <p><a href="https://www.cs.ucsb.edu/~vigna/publications/2016_SP_angrSoK.pdf" target="_blank" rel="external">(State of) The Art of War: Offensive Techniques in Binary Analysis</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>10/19</h3></td><br>      <td><br>        <h3>Post-exploitation</h3><br>        <h4>Recommended Reading</h4><br>        <p><a href="http://phrack.org/issues/62/8.html" target="_blank" rel="external">Remote Exec</a></p><br>        <p><a href="http://uninformed.org/index.cgi?v=3&a=2&t=sumry" target="_blank" rel="external">Attacking NTLM with Precomputed Hashtables</a></p><br>        <p><a href="https://github.com/mubix/post-exploitation-wiki" target="_blank" rel="external">Post Exploitation Wiki</a></p><br>        <p><a href="https://www.exploit-db.com/docs/18229.pdf" target="_blank" rel="external">Post Exploitation Using Meterpreter</a></p><br>        <p><a href="http://pastebin.com/raw/0SNSvyjJ" target="_blank" rel="external">Hack Back! A DIY Guide</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>10/24</h3></td><br>      <td><br>        <h3>Paper Presentations</h3><br>        <p><a href="http://web.mit.edu/ha22286/www/papers/CCS14.pdf" target="_blank" rel="external">Information Leaks Without Memory Disclosures: Remote Side Channel Attacks on Diversified Code</a></p><br>        <p><a href="https://cs.unc.edu/~fabian/papers/oakland2013.pdf" target="_blank" rel="external">Just-In-Time Code Reuse: On the Effectiveness of Fine-Grained Address Space Layout Randomization</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>10/26</h3></td><br>      <td><br>        <h3>No Class</h3><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>10/31</h3></td><br>      <td><br>        <h3>Paper Presentations</h3><br>        <p><a href="http://nsl.cs.columbia.edu/projects/minestrone/papers/outofcontrol_oakland14.pdf" target="_blank" rel="external">Out Of Control: Overcoming Control-Flow Integrity</a></p><br>        <p><a href="https://www.informatik.tu-darmstadt.de/fileadmin/user_upload/Group_TRUST/PubsPDF/ccs15.stackdefiler.pdf" target="_blank" rel="external">Losing Control: On the Effectiveness of Control-Flow Integrity under Stack Attacks</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>11/2</h3></td><br>      <td><br>        <h3>Paper Presentations</h3><br>        <p><a href="https://www.internetsociety.org/sites/default/files/09_3_2.pdf" target="_blank" rel="external">Too LeJIT to Quit: Extending JIT Spraying to ARM</a></p><br>        <p><a href="https://www3.cs.stonybrook.edu/~mikepo/papers/devil.ndss15.pdf" target="_blank" rel="external">The Devil is in the Constants: Bypassing Defenses in Browser JIT Engines</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>11/7</h3></td><br>      <td><br>        <h3>Malware and Rootkits</h3><br>        <h4>Recommended Reading</h4><br>        <p><a href="http://vxheaven.org/" target="_blank" rel="external">VX Heaven</a></p><br>        <p><a href="http://phrack.org/issues/62/12.html" target="_blank" rel="external">NTIllusion: A portable Win32 userland rootkit</a></p><br>        <p><a href="http://uninformed.org/index.cgi?v=8&a=2" target="_blank" rel="external">A Catalog of Windows Local Kernel-mode Backdoor Techniques</a></p><br>        <p><a href="https://www.rsaconference.com/writable/presentations/file_upload/crwd-t08-evasive-malware-exposed-and-deconstructed.pdf" target="_blank" rel="external">Evasive Malware Exposed and Deconstructed<br></a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>11/9</h3></td><br>      <td><br>        <h3>Paper Presentations</h3><br>        <p><a href="https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-hu.pdf" target="_blank" rel="external">Automatic Generation of Data-Oriented Exploits</a></p><br>        <p><a href="https://www.comp.nus.edu.sg/~shweta24/publications/dop_oakland16.pdf" target="_blank" rel="external">Data-Oriented Programming: On the Expressiveness of Non-Control Data Attacks</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>11/14</h3></td><br>      <td><br>        <h3>Web Application Exploitation</h3><br>        <h4>Recommended Reading</h4><br>        <p><a href="http://net-square.com/_assets/One-way_Web_Hacking.pdf" target="_blank" rel="external">One-Way Web Hacking</a></p><br>        <p><a href="http://blog.rootcon.org/2012/03/introducing-35-pentesting-tools-used.html " target="_blank" rel="external">35 Pentesting Tools Used for Web Vulnerability Assessment</a></p><br>        <p><a href="http://phrack.org/issues/49/8.html" target="_blank" rel="external">CGI Security Holes</a></p><br>        <p><a href="http://phrack.org/issues/54/8.html" target="_blank" rel="external">NT Web Technology Vulnerabilities</a></p><br>        <p><a href="http://phrack.org/issues/55/7.html" target="_blank" rel="external">Perl CGI problems</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>11/16</h3></td><br>      <td><br>        <h3>Paper Presentations</h3><br>        <p><a href="https://www3.cs.stonybrook.edu/~mikepo/papers/ret2dir.sec14.pdf" target="_blank" rel="external">ret2dir: Rethinking Kernel Isolation</a></p><br>        <p><a href="http://www.ieee-security.org/TC/SP2016/papers/0824a987.pdf" target="_blank" rel="external">Dedup Est Machina: Memory Deduplication as an Advanced Exploitation Vector</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>11/21</h3></td><br>      <td><br>        <h3>Paper Presentations</h3><br>        <p><a href="http://www.csl.sri.com/users/porras/EKHunter.pdf" target="_blank" rel="external">EKHUNTER: A Counter-Offensive Toolkit for Exploit Kit Infiltration</a></p><br>        <p><a href="http://syssec.rub.de/media/emma/veroeffentlichungen/2014/09/10/POPChainGeneration-CCS14.pdf" target="_blank" rel="external">Code Reuse Attacks in PHP: Automated POP Chain Generation</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>11/23</h3></td><br>      <td><br>        <h3>Thanksgiving Break - No Class</h3><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>11/28</h3></td><br>      <td><br>        <h3>Paper Presentations</h3><br>        <p><a href="https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-vogl.pdf" target="_blank" rel="external">Dynamic Hooks: Hiding Control Flow Changes within Non-Control Data</a></p><br>        <p><a href="https://www.internetsociety.org/sites/default/files/11_2_1.pdf" target="_blank" rel="external">Persistent Data-only Malware: Function Hooks without Code</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>11/30</h3></td><br>      <td><br>        <h3>Paper Presentations</h3><br>        <p><a href="https://people.csail.mit.edu/stelios/papers/jujutsu_ccs15.pdf" target="_blank" rel="external">Control Jujutsu: On the Weaknesses of Fine-Grained Control Flow Integrity</a></p><br>        <p><a href="http://hgi.ruhr-uni-bochum.de/media/emma/veroeffentlichungen/2014/07/29/antiROP-RAID14.pdf" target="_blank" rel="external">Evaluating the Effectiveness of Current Anti-ROP Defenses</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>12/5</h3></td><br>      <td><br>        <h3>Paper Presentations</h3><br>        <p><a href="http://senglehardt.com/papers/www15_cookie_surveil.pdf" target="_blank" rel="external">Cookies That Give You Away: The Surveillance Implications of Web Tracking</a></p><br>        <p><a href="https://zmap.io/paper.pdf" target="_blank" rel="external">ZMap: Fast Internet-Wide Scanning and its Security Applications</a></p><br>      </td><br>    </tr><br>    <tr><br>      <td><h3>12/7</h3></td><br>      <td><br>        <h3>Wrap Up</h3><br>      </td><br>    </tr><br>  </tbody><br></table><br></div><br>  </div></body><br></html>

      
    </div>
    <footer class="entry-meta entry-footer">
      

      
      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-memorysafety-defense"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170605/memorysafety-defense/">内存持久战之防御措施</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170605/memorysafety-defense/" class="article-date">
	  <time datetime="2017-06-05T02:11:39.000Z" itemprop="datePublished">六月 5, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本系列主要介绍内存的安全性问题，以及相应的攻击模型及防御措施，对整个系统安全问题的概览有很大的帮助。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170513/memorysafety-defense/" target="_blank" rel="external">内存持久战之防御措施</a>》与作者信息：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>
<hr>
<blockquote>
<ul>
<li>0X01 广泛部署的防御机制</li>
<li>0X02 防御机制Step-by-step </li>
</ul>
</blockquote>
<p>继前两篇文章 <a href="http://www.csyssec.org/20170513/memorysafety/" target="_blank" rel="external">内存持久战-内存安全性</a>, <a href="http://www.csyssec.org/20170513/memorysafety-attack/" target="_blank" rel="external">内存持久战-攻击模型</a>, 再加上防御措施，才能算是完整的内存战争。本文首先介绍目前广泛部署的防御机制，然后根据 <a href="http://www.csyssec.org/20170513/memorysafety-attack/" target="_blank" rel="external">内存持久战-攻击模型</a> 每一步实施的攻击破坏介绍相对应的防御细节。</p>
<h3 id="0X01-广泛部署的防御机制"><a href="#0X01-广泛部署的防御机制" class="headerlink" title="0X01 广泛部署的防御机制"></a>0X01 广泛部署的防御机制</h3><p>目前广泛部署的防御机制有栈粉碎性保护（Stack smashing protection)，DEP/W⊕X以及ASLR(Address Space Layout Randomization)。针对Windows平台，也提出了一些特殊的机制，比如 SafeSEH 与 SEHOP 用来保护堆的元数据和异常处理器。</p>
<p>栈粉碎性保护,SafeSEH以及SEHOP的基本思想是在返回地址与缓冲区(比如函数入口）之间放置随机数作为哨兵（称为cookie或canary),在函数返回前先检测哨兵的值是否被篡改，以达到检测缓冲区溢出攻击的目的。这些机制都属于代码指针保护方式（code pointer integrity),主要检测一些特殊代码指针，如栈上的返回地址、异常处理器指针的完整性，然而对于直接修改（比如索引错误）却无能为力。有关stack smashing 可参考这篇文章 <a href="http://www.drdobbs.com/security/anatomy-of-a-stack-smashing-attack-and-h/240001832?pgno=1" target="_blank" rel="external">Anatomy of a Stack Smashing Attack and How GCC Prevents It
</a></p>
<p>W⊕X（write XOR executable)属于DEP（data execution prevention)的子集，是不可执行数据（Non-executable data）与代码完整性(code integrity)的结合。所有现代CPU都支持设置不可执行页面权限，结合不可写代码权限，就可以实施W⊕X机制，很简单也很实际。然而无法防御ROP（return oriented programming),ROP指的是在将现有代码中的可复用代码（可以是现有的函数）以及一些指令序列（gadgets)连接起来实施恶意操作。有关ROP可参考这篇文章，<a href="https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf" target="_blank" rel="external">Return-oriented Programming:<br>Exploitation without Code Injection</a>.</p>
<p>ASLR在下文会详细描述。</p>
<h3 id="0X02-防御机制Step-by-step"><a href="#0X02-防御机制Step-by-step" class="headerlink" title="0X02 防御机制Step-by-step"></a>0X02 防御机制Step-by-step</h3><p>从目前提出的所有防御机制来看，可将其划分为两大类：概率性以及确定性防御。概率性机制用来随机化一些对象，如ISR(Instruction Set Randomization), ASLR(Address Space Randomizatioin)以及DSR(Data Space Randomization),可选手段相对较少。 确定性防御机制实施reference monitor, 有关reference monitor的定义可参考，<a href="https://en.wikipedia.org/wiki/Reference_monitor" target="_blank" rel="external">wikipedia page on reference monior</a>, 主要就是在参考验证机制上定义了一些设计要求。 其主要利用静态与动态注入技术，静态注入可在编译阶段实施，动态注入需要在运行时加入代码，损耗相对较大。有关注入技术，可参考前面的文章 <a href="http://www.chongh.wiki/blog/2015/12/18/pin-for-dynamic-binary-instrumentation/" target="_blank" rel="external">PIN for Dynamic Binary Instrumentation</a>。</p>
<p>下面将针对攻击模型中实施的每个步骤介绍相对应的防御机制，每种防御机制对应每一步的攻击过程。<br>可以先去回顾一下 <a href="http://www.csyssec.org/20170513/memorysafety-attack/" target="_blank" rel="external">内存持久战之攻击模型</a> 的完整实施过程。注意，以下介绍的防御机制并没有时序关系,以横向关系依次描述。</p>
<p><strong><em>Step 1&amp;2: Memory safety.</em></strong> 考虑完整的内存安全性，空间错误和时域错误都需要阻止。类型安全（Type-safe)的语言通过检查数组边界并使用自动垃圾回收来实施空间与时域安全性。对于非类型安全语言，可嵌入reference monitor针对非安全代码实施类似的策略，对象可以是源码、中间语言、二进制。</p>
<p>针对空间安全，可跟踪指针边界，将指针结构体的表示方法扩展，加入额外信息。但是这种需要源码标注(annotation)，对于庞大的代码基是不实用的，甚至会改变内存结构带来二进制兼容性问题。可参考 <a href="https://www.cs.virginia.edu/~weimer/p/p477-necula.pdf" target="_blank" rel="external">CCured</a> 项目。为解决兼容性问题，越来越多研究者开始追踪对象边界，不但要知道对象分配的内存区域边界，并利用指针运算而不是引用指针来保护指针边界。</p>
<p>然而，检测边界并不能解决use-after-free, double-free(use-after-free的特列)问题. 此时，实施时域安全可作为补充。1）特殊的分配器：释放的内存只能被同类型对象重用并对齐。此策略可阻止user-after-free攻击，但对dangling pointers无效；2）基于对象的方法：利用影子内存标记每一块释放的内存位置，如果访问最近被释放的空间就能被检测到。著名的Valgrind内存检测就是利用此方法来检测user-after-free错误的。有关Valgrind的内存检测技术将会在后续的文章<a href="http://www.chongh.wiki/blog/2016/02/20/valgrind-memory/" target="_blank" rel="external">Valgrind内存检测</a> 详细介绍。如果标记的内存区域重新被新的指针指向，对其的非法访问就检测不到了；3）基于指针的方法：同时维护指针的边界信息与内存分配信息实施全面的内存安全。</p>
<p><strong><em>Step 3: 代码完整性(code integrity, 对应修改代码),代码指针完整性(code pointer integrity，对应修改代码指针)以及数据完整性（data integrity，对应修改数据变量).</em></strong></p>
<p>代码完整性保证程序中的代码不可写性，可以将含有代码的所有内存页面设置为read-only,所有现代CPU都支持此操作。但是，代码完整性并不支持自我修改(self-modifying)的代码以及即时(Just-In-Time, JIT)编译。代码指针完整性保护指针不被修改，对于不变指针，如全局偏移表、虚拟函数表（vtable),可将其内存页设置read-only。但大部分指针，如定义的函数指针或保存的返回地址必须是可写的。另外，就算内存中所有的函数指针都能实施代码指针完整性，并不能防御use-after-free攻击，例如，通过悬挂指针读取错误的vtable<br>来改变程序的控制流并不会涉及内存中的覆盖代码指针操作。</p>
<p>数据完整性的实施近似空间安全保护，但并没有实施时域安全保护。数据完整性包括基于对象的完整性保护以及基于points-to集合的完整性保护。基于对象的完整性保护利用静态指针分析来鉴别出不安全的指针集(比如可能会越界的指针)以及指针的points-to集合，然后在代码中插入用影子内存跟踪对象的创建与释放的代码，当对不安全的指针进行写操作或引用操作时会检测指针的位置是否标记在影子内存中。基于points-to集合的完整性保护在基于对象的完整性保护上加了一个限制，每个解引用只能写它自己指向的集合对象，是对其保护的加强。</p>
<p><strong><em>Step 4: ISR(对应指针转向攻击者特定代码),ASLR（对应指向shellcode或者gadget的地址),DSR(对应解析输出的数据变量).</em></strong></p>
<p>ISR随机化系统指令来保护代码破坏攻击，随着硬件的更新与发展,ISR技术已经废弃；ASLR随机化代码和数据的存储位置来防御控制流劫持攻击，如果payload(指恶意代码中执行恶意操作的部分）在虚拟内存空间的地址不是固定的，攻击者就无法转移控制流。ASLR也是目前用来保护劫持攻击运用最广泛的技术，然后ASLR的随机化是可预测的，尤其是32位机器，heap-spraying以及JIT-spraying技术可以多次填充payload使随机化失效；</p>
<p>DSR将存储在内存中的数据形式，而不是存储位置，进行随机化。它为每个变量,包括指针，生成不同的key并进行加密操作，数据的每次读取/存储操作都多了个加解密过程。该方法在代码注入之前都要对指针进行静态分析，overhead较大，但保护比较健壮，能有效防止信息泄露，还能防御控制流劫持以及数据攻击。</p>
<p><strong><em>Step 5: 控制流完整性（control-flow integrity,对应利用间接跳转指令 call/jump 引用指针，利用返回指令引用指针)以及数据流完整性(data-flow integrity，对应引用破坏后的数据变量).</em></strong></p>
<p>控制流完整性包括动态返回完整性以及静态控制流图完整性。前文提到的栈粉碎性保护机制不能保护间接调转（call and jump)，不能防御直接修改破坏以及信息泄露，但开销小，兼容性好，所以运用比较广泛。影子栈技术能够解决栈粉碎性保护的信息泄露以及直接修改破坏问题，它把返回地址存入隔离的影子栈中，当函数返回时，对原有栈和影子栈两处保存的值做比较，已保证不被篡改。为了防御控制流劫持，不但要保护返回值，还要保护间接跳转，静态控制流图完整性的方式标记所有的call,jump，并将其标记信息存储在特殊的影子内存中或直接放进代码里; 数据流完整性在数据被使用前，通过检查read指令检测数据是否被破坏。它使用静态points-to分析构建一个全局的可达定义集合（reaching definition sets)，保证数据变量最近一次被写是通过程序中的写指令写入的，而不是攻击者可控制的写入。有关reaching definition sets的定义可参考 <a href="https://en.wikipedia.org/wiki/Reaching_definition" target="_blank" rel="external">wikipedia page on Reaching definition</a>.</p>
<p><strong><em>Step 6: 不可写数据策略(Non-executable data,对应执行注入的shellcode).</em></strong><br>Non-executable data 保护栈、堆之类的内存页面不可执行，只需要设置内存页面的执行位即可。实际上Non-executable data策略与代码完整性结合就是W⊕X机制。</p>
<p>每个攻击过程对应的防御机制都已讲完。横向来看，所有攻击模型的每个步骤都有多个防御方法；纵向来看，每种攻击在不同的实施阶段也有不同的防御方法，如控制流劫持攻击，从Step1-6分别有，内存安全性机制（step 1-2),代码指针完整性(step 3),ASLR(step 4), 控制流完整性（step 5）以及不可写数据策略（step 6)不同的防御机制。要阻止某种攻击或多种攻击，需要结合多种防御机制，每种机制也都有其优势与弱点。评判防御机制的性质，可从以下方面去衡量，保护强度、误报率、漏报率、性能开销、内存开销、兼容性，是否模块化等。</p>
<p>至此，内存持久战系列文章就到这里了，水平有限，很多不到位的地方欢迎补充修正。 回顾一下，最后用下面这张图总结，就清晰明了了。[图来源于S&amp;P’13]</p>
<figure><br>    <a href="http://7xppf1.com1.z0.glb.clouddn.com/memorywar.png" target="_blank" rel="external"><img src="http://7xppf1.com1.z0.glb.clouddn.com/memorywar.png" width="350"></a><br>    <figcaption></figcaption><br></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.drdobbs.com/security/anatomy-of-a-stack-smashing-attack-and-h/240001832?pgno=1" target="_blank" rel="external">Anatomy of a Stack Smashing Attack and How GCC Prevents It
</a></p>
<p><a href="https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf" target="_blank" rel="external">Return-oriented Programming: Exploitation without Code Injection</a>.</p>
<p><a href="https://en.wikipedia.org/wiki/Reference_monitor" target="_blank" rel="external">wikipedia page on reference monior</a></p>
<p><a href="https://www.cs.virginia.edu/~weimer/p/p477-necula.pdf" target="_blank" rel="external">CCured</a></p>
<p><a href="https://nebelwelt.net/publications/files/13Oakland.pdf" target="_blank" rel="external">S&amp;P’13 Eternal War in Memory </a></p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170513/memorysafety-defense/" target="_blank" rel="external">内存持久战之防御措施</a>》与作者信息：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/内存安全/">内存安全<span class="article-category-count">3</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Memory/">Memory</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/">System</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-ravel"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170531/ravel/">会找漏洞的时光机-Pinpointing Vulnerabilities</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170531/ravel/" class="article-date">
	  <time datetime="2017-05-31T13:33:58.000Z" itemprop="datePublished">五月 31, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>来源： <a href="https://www.inforsec.org/wp/?p=1993" target="_blank" rel="external">InforSec</a><br>作者：Yue CHEN, Florida State University, 博士在读<br>转载请注明来源与原作者信息。</p>
<hr>
<p>当我们的系统遭受攻击时，即便我们已经检测到攻击，如何知道被利用的漏洞在哪里呢？</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/ravel1.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/ravel1.png" width="450"></a><br>    <figcaption></figcaption><br></figure>

<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/ravel2.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/ravel2.png" width="450"></a><br>    <figcaption></figcaption><br></figure>



<p>先让我们来看一个简单的例子(见上图)：假如用户输入的argv[1]是个巨长无比的字符串，由于strcpy不限制拷贝的字符数，buf会被溢出，那么在第6行函数return时候，很可能会控制流异常。假如使用攻击检测，很可能检测到第6行的return 0，但是真正的漏洞在第4行。症状(Symptom)和根本原因(Root Cause)在不同的地方。对于复杂的大程序，想要定位到Root Cause还是非常困难的。</p>
<p>目前基于memory instrumentation的漏洞检测，由于要instrument所有的内存访问，其开销特别大，因此不适合用于程序运行时使用。所以这篇论文提出个系统叫Ravel (Root-cause Analysis of Vulnerabilities from Exploitation Log), 它包含一个online模块和一个offline模块. <strong>Online的模块把运行的不确定事件都记录(Record)下来，并且提供攻击检测功能；Offline的模块可以重放(Replay)程序的运行，并且可以instrument memory并且定位漏洞。</strong></p>
<p>这样做有若干优势:</p>
<ul>
<li>可以把真实世界里的攻击，在实验室环境进行重放(Replay)并分析。</li>
<li>运行时候性能开销很小，开销大的漏洞定位阶段被放在了Offline的实验室里。</li>
<li>可扩展。可以自由添加新的攻击检测和漏洞定位方法。</li>
<li>对于攻击检测，Ravel用了现有的方法，比如程序崩溃，异常系统调用，CFI等。 对于Record &amp; Replay,  Ravel主要记录了不确定事件，比如系统调用(syscall)结果，内核到用户空间的数据拷贝，同步原语等等 (具体参看幻灯片或者论文)。</li>
</ul>
<p>对于Replay阶段的Memory Instrumentation，Ravel集成了二进制翻译引擎(Binary Translation Engine，简称BT)。其中很重要的功能 (也是一项挑战) ， 是可以把BT发出的syscall和目标程序本身的syscall区分开来，以确保replay和record的一致性。</p>
<p>对于漏洞定位，Ravel设计了一系列功能。首先是<strong>数据流分析(Data-flow Analysis)</strong>。我们把写入一块内存叫做define, 简称def；把从这块内存里读出数据叫use。假如指令A写入这块内存，指令B接着读了出来，他们就构成了一组def-use关系。一堆这种关系可以构成一张图，叫DFG (Data-flow Graph).</p>
<p>我们可以预先把这些关系找出来，做一张DFG。假如运行时候有之前没见过的def-use关系出现，可以视为发现 违规(violation)，意味着很可能有漏洞。那么如何知道出问题的地方是在def，还是在use呢？</p>
<p>Ravel用了一些启发式搜索(heuristics)。这里用buffer overflow举个例子。</p>
<p>比如我们本来有三个use (也就是read from memory):</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/ravel3.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/ravel3.png" width="450"></a><br>    <figcaption></figcaption><br></figure>

<p>然后有一个大的def (write to memory) 把这仨use都覆盖了:</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/ravel4.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/ravel4.png" width="450"></a><br>    <figcaption></figcaption><br></figure>

<p>假如发现这些def-use关系是violation，那么很有可能，漏洞在def的指令及其周围。</p>
<p>并且很有可能是buffer overflow, memory overwriting之类的。Violation关系如下图:</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/ravel5.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/ravel5.png" width="450"></a><br>    <figcaption></figcaption><br></figure>


<p>别的漏洞，比如information leakage，也可以用类似的方法来定位。</p>
<p>对于<strong>整数错误(Integer Errors)</strong>, Ravel关注的是一些用整数计数(比如放在RCX/ECX寄存器里)的指令，比如MOVS, STOS 等； 和有整数参数的函数，比如memcpy, recvfrom 等。从这些参数开始，Ravel进行backwards search来定位漏洞。</p>
<p>可以定位的整数错误漏洞包括:</p>
<p>Assignment Truncation (比如0x12345678 → 0x5678)</p>
<ul>
<li>检测方法：从longer type赋值到shorter type</li>
</ul>
<p>Integer Overflow/underflow (比如0xFFFFFFFF + 1)</p>
<ul>
<li><p>检测方法：检测RFLAGS/EFLAGS寄存器<br>Signedness Error (比如 unsigned_int_var = signed_int_var)</p>
</li>
<li><p>检测方法：收集Hint。比如一些指令或者函数会指定特定的signed或者unsigned参数。详情参见slides或者<br>那么有些整数错误是程序员/编译器故意设置的，如何区分呢？</p>
</li>
<li><p>由于这些错误已经和reported的漏洞相关，所以非常大可能是漏洞，而不是正常的整数操作。<br>假如Race Condition存在，replay的execution trace会和record下来的不一样，所以可以用该方法来检测。</p>
</li>
</ul>
<p>一旦检测到，Ravel继续用happens-before relation来进一步尝试定位漏洞。</p>
<p>Ravel还能检测以下一系列漏洞，具体参见paper，此处不再赘述:</p>
<p>Use-after-free and Double-free</p>
<p>Buffer Overflow</p>
<p>Integer Errors</p>
<p>Information Leakage</p>
<p>Format String Vulnerabilities</p>
<p>Ravel的Record &amp; Replay功能基于FreeBSD 10.2实现，漏洞定位基于Valgrind实现。</p>
<p>下图用Nginx的CVE-2013-2028 漏洞举了一个Ravel如何从攻击定位到漏洞的例子, 具体描述参见论文。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/ravel6.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/ravel6.png" width="450"></a><br>    <figcaption></figcaption><br></figure>


<p>更多的Evaluation实验, 比如Heartbleed，以及别的漏洞类型比如</p>
<p>Null Pointer Dereference,</p>
<p>Heap Overflow,</p>
<p>Out-of-bounds Read,</p>
<p>Untrusted Pointer Dereference,</p>
<p>也可以在论文里找到。</p>
<p>最后是Online Performance Overhead的Evaluation, 实验是在流行的web服务器和SPEC CPU 2006上做的， 可以看出性能开销非常小。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/ravel7.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/ravel7.png" width="450"></a><br>    <figcaption></figcaption><br></figure>


<p>论文链接: <a href="http://ww2.cs.fsu.edu/~ychen/paper/ravel.pdf" target="_blank" rel="external">http://ww2.cs.fsu.edu/~ychen/paper/ravel.pdf</a></p>
<p>Slides链接(pptx): <a href="http://ww2.cs.fsu.edu/~ychen/paper/ravel.pptx" target="_blank" rel="external">http://ww2.cs.fsu.edu/~ychen/paper/ravel.pptx</a></p>
<p>Slides链接(pdf): <a href="http://ww2.cs.fsu.edu/~ychen/paper/ravel_slides.pdf" target="_blank" rel="external">http://ww2.cs.fsu.edu/~ychen/paper/ravel_slides.pdf</a></p>
<p>作者简介:</p>
<p>Yue CHEN, Florida State University, 博士在读。期间曽有幸在 百度美研X-Lab, 华为美研大数据组 等地实习。</p>
<p>研究兴趣为系统安全，移动安全。个人主页: <a href="http://YueChen.me" target="_blank" rel="external">http://YueChen.me</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/系统安全/">系统安全<span class="article-category-count">1</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Exploit/">Exploit</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-memorysafety-attack"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170513/memorysafety-attack/">内存支持战之攻击模型</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170513/memorysafety-attack/" class="article-date">
	  <time datetime="2017-05-13T02:09:22.000Z" itemprop="datePublished">五月 13, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本系列文章主要介绍内存的安全性问题，以及相应的攻击模型及防御措施，对整个系统安全问题的概览有很大的帮助。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170513/memorysafety-attack/" target="_blank" rel="external">内存持久战之攻击模型</a>》与作者信息：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>
<hr>
<blockquote>
<ul>
<li>0X01 基本攻击模型</li>
<li>0X02 构建攻击模型</li>
</ul>
</blockquote>
<p>内存破坏是计算机安全中亘古不变的话题。内存破坏也被看作是top three危险的软件错误。像C/C++这种底层语言很容易引来这些bugs. 这些程序语言无法对内存安全性的保证，以至于让一些攻击者利用内存bugs改变程序行为或甚至控制整个控制流（control-flow).  要了解什么是内存安全性，可参考上一篇文章：<a href="http://www.csyssec.org/20170513/memorysafety/" target="_blank" rel="external">内存持久战-内存安全性</a>.  然而，一种最显而易见的解决方案就是避免这些容易引起内存破坏的程序语言，用一种内存安全的程序语言去重写这些程序。显然这是不切实际的，比如重写整个OS？<br>尽管papers的许多防御措施层出不穷，但大部分都无法应用到工业上，归结于以下问题：性能开销太大、与现有的程序特性并不兼容、不够健壮、不够完整、依赖于编译器或源码等等。<br>对内存的破坏与保护是一场持久战。本文重在总结利用内存破坏的相关攻击及其实施过程。</p>
<hr>
<h3 id="0X01-基本攻击类型"><a href="#0X01-基本攻击类型" class="headerlink" title="0X01 基本攻击类型"></a>0X01 基本攻击类型</h3><ul>
<li>代码破坏攻击(Code corruption):  攻击者在内存中覆盖程序代码，执行自己写入的代码.</li>
<li>控制流劫持（Control-flow hijack）: 攻击者重写程序的返回地址或跳转地址，转而执行自己的代码（shell code).</li>
<li>数据攻击（Data-only attack）: 攻击者并不会修改程序控制流，而是操作程序中的关键数据获取额外权限或泄露重要信息。</li>
<li>信息泄露（Information leak attack）:任何类型的内存错误都有可能导致内存内容的泄露 </li>
</ul>
<p>注意，也许你会问，怎么没有缓冲区溢出攻击，format string攻击等？ 这些都只是实施细节，属于过程，最终目的都可划分为以上的四种攻击模型。可具体看下文的构建攻击模型。</p>
<h3 id="0X02-构建攻击模型"><a href="#0X02-构建攻击模型" class="headerlink" title="0X02 构建攻击模型"></a>0X02 构建攻击模型</h3><p>攻击者要实施一次完整的攻击，首先要触发内存错误，具体可按照以下六个步骤进行：<br>注：<em>Step 1&amp;2</em> 是上述攻击模型通用的过程，必不可少，目的是为了触发内存错误。至于 <em>Step 3-6</em>，有些攻击需要完整的步骤才能执行，有些则在前几个阶段就可以完成。</p>
<p><strong><em>Step 1: 让指针无效</em></strong>。</p>
<p>要让指针无效，可以强制让指针越界（out of bounds)，引用越界指针引发空间错误（spatial error)。包括：触发未经过检测的空间分配失败错误（allocation failure),这时指针将变成空指针；在循环中不作边界检测，不断递增或递减数组指针，让指针指向数组边界之外的内存空间导致缓冲区溢出；索引越界，一般由整数溢出、截断、对齐、错误的指针映射导致。</p>
<p>或可让指针指向已经被删除的对象,这时指针称为悬挂指针(dangling pointer).比如，利用不正确的异常处理器（exception handler)回收对象，但并不重新初始化指向这个对象的指针。<br>引用悬挂指针引发时域错误（temporal error). 时域错误也称为use-after-free漏洞，因为引用（used)悬挂指针是在指针指向的内存区域已经被回收（freed)到内存管理系统之后. 大部分此类的错误指针在heap上分配的对象，但局部变量的指针分配给全局变量后会造成指针逃逸(escape)出局部作用域，在函数返回或栈上的局部变量被删除后逃逸的指针将会变成悬挂指针。</p>
<p><strong><em>Step 2: 强制让程序引用（读或写）无效指针</em></strong>。</p>
<p><strong><em>Step 3: 利用无效指针修改对象</em></strong>。修改的对象包括数据指针、代码指针、代码、数据变量，以及输出数据变量</p>
<p><strong><em>Step 4: 偏离源程序执行</em></strong>。可将修改的对象转向攻击者特定的代码（code curruption attack)、也可指向shellcode或者gadget(指一些指令序列）的地址、修改变量特定值、解析输出的数据变量（information leak attack). 注：此时，code currupttion attack与information lead attack过程都已全部完成。</p>
<p><strong><em>Step 5: 使用修改后的对象</em></strong>。包括利用间接跳转指令 <em>call/jump</em> 引用指针，利用返回指令引用指针，以及引用破坏后的数据变量（data-only attack).至此，数据攻击过程已全部完成。</p>
<p><strong><em>Step 6: 执行恶意代码</em></strong>。包括重用现有的函数/gadgets以及执行注入的shellcode(control-flow hijack).至此，control-flow hijack过程已全部完成。</p>
<p>最后看两张图，分别是control-flow hijack利用越界指针与悬挂指针劫持控制流的完整过程：</p>
<figure><br>    <a href="http://7xppf1.com1.z0.glb.clouddn.com/hijack-bound.png" target="_blank" rel="external"><img src="http://7xppf1.com1.z0.glb.clouddn.com/hijack-bound.png" width="300"></a><br>    <figcaption></figcaption><br></figure>

<figure><br>    <a href="http://7xppf1.com1.z0.glb.clouddn.com/hijack-dangling.png" target="_blank" rel="external"><img src="http://7xppf1.com1.z0.glb.clouddn.com/hijack-dangling.png" width="300"></a><br>    <figcaption></figcaption><br></figure>


<p>既然谈论的是持久战，针对内存破坏相关攻击的防御措施将在下一篇文章<a href="http://www.csyssec.org/20170513/memorysafety-attack/" target="_blank" rel="external">内存持久战-防御措施</a>详细介绍。</p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><a href="https://nebelwelt.net/publications/files/13Oakland.pdf" target="_blank" rel="external">S&amp;P’13 Eternal War in Memory </a></p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170513/memorysafety-attack/" target="_blank" rel="external">内存持久战之攻击模型</a>》与作者信息：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/内存安全/">内存安全<span class="article-category-count">3</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Memory/">Memory</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/">System</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div class="widget-wrap" style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 75%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 42px;" placeholder=" 搜索…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="搜索">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">集思广益</h3>
      <p>我们推崇的是黑客与分享精神，如果您觉得本站对您有帮助，不妨自己也参与进来共同建设，期待您能推荐好文章或投稿至本站，
让更多人受益。本站热烈欢迎志同道合者与志愿者参与本站的共同维护和建设，您可通过微博[@Diting0x](http://weibo.com/diting0x)联系我</p>
       <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="null" title="Words"><i class="fa fa-words" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a> </li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>


        	</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>最新推荐</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170807/bypassaslr-analysis/">bypassaslr-analysis</a></h6>
          <!--  <span>八月 7, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170807/offensivesec/">offensivesec</a></h6>
          <!--  <span>八月 7, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170605/memorysafety-defense/">内存持久战之防御措施</a></h6>
          <!--  <span>六月 5, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170531/ravel/">会找漏洞的时光机-Pinpointing Vulnerabilities</a></h6>
          <!--  <span>五月 31, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170513/memorysafety-attack/">内存支持战之攻击模型</a></h6>
          <!--  <span>五月 13, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170513/memorysafety/">内存持久战之内存安全性</a></h6>
          <!--  <span>五月 13, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170508/intro-aslr/">系统安全浅薄知识系列(一)-ASLR</a></h6>
          <!--  <span>五月 8, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170505/cfi-mathias/">控制流完整性-Mathias Payer</a></h6>
          <!--  <span>五月 5, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170505/vmi-xenproject/">虚拟机自省技术-一个有新商业应用的安全性创造</a></h6>
          <!--  <span>五月 5, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/cf-exception/">控制流分支指令上的控制流处理器异常(单步执行)</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/cfi-development/">控制流完整性的发展历程</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/cfi-ccs05/">控制流完整性-CCS05年论文</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/rop-intel/">因特尔发布新的技术规范去防御 ROP 攻击</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/ropjop-research/">ROP/JOP攻击与防御最新研究进展</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/nmi-virtual/">虚拟化技术的NMI窗口退出</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/lbr-ret2dir/">利用LBR特性检测ret2dir攻击</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类导航</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hypervisor安全/">Hypervisor安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/主流会议/">主流会议</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/二进制分析/">二进制分析</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存安全/">内存安全</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内核安全/">内核安全</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内核完整性/">内核完整性</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/博士之路/">博士之路</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/名人课堂/">名人课堂</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学术专家/">学术专家</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全圈子/">安全圈子</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/恶意代码/">恶意代码</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/漏洞利用/">漏洞利用</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/硬件特性/">硬件特性</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/硬件虚拟化/">硬件虚拟化</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统内核/">系统内核</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统安全/">系统安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统安全科普/">系统安全科普</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟化原理/">虚拟化原理</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟化基础/">虚拟化基础</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟化综合/">虚拟化综合</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机快照/">虚拟机快照</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机监控/">虚拟机监控</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机记录与重放/">虚拟机记录与重放</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机迁移/">虚拟机迁移</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签导航</h3>
    <div class="widget tagcloud">
      <a href="/tags/ASLR/" style="font-size: 12.31px;">ASLR</a> <a href="/tags/ASPLOS/" style="font-size: 10px;">ASPLOS</a> <a href="/tags/Attack/" style="font-size: 12.31px;">Attack</a> <a href="/tags/Binary/" style="font-size: 10.77px;">Binary</a> <a href="/tags/CFI/" style="font-size: 12.31px;">CFI</a> <a href="/tags/Cloud/" style="font-size: 10px;">Cloud</a> <a href="/tags/Compiler/" style="font-size: 10px;">Compiler</a> <a href="/tags/Conference/" style="font-size: 12.31px;">Conference</a> <a href="/tags/Conferences/" style="font-size: 10px;">Conferences</a> <a href="/tags/Course/" style="font-size: 13.08px;">Course</a> <a href="/tags/Exception/" style="font-size: 10px;">Exception</a> <a href="/tags/Exploit/" style="font-size: 16.92px;">Exploit</a> <a href="/tags/Forensics/" style="font-size: 10px;">Forensics</a> <a href="/tags/HAV/" style="font-size: 12.31px;">HAV</a> <a href="/tags/Hardware/" style="font-size: 13.85px;">Hardware</a> <a href="/tags/Heap/" style="font-size: 10.77px;">Heap</a> <a href="/tags/Hooking/" style="font-size: 10px;">Hooking</a> <a href="/tags/Instrumentation/" style="font-size: 10.77px;">Instrumentation</a> <a href="/tags/Introspection/" style="font-size: 13.85px;">Introspection</a> <a href="/tags/JOP/" style="font-size: 10px;">JOP</a> <a href="/tags/KVM/" style="font-size: 16.15px;">KVM</a> <a href="/tags/Kernel/" style="font-size: 17.69px;">Kernel</a> <a href="/tags/Libvmi/" style="font-size: 13.08px;">Libvmi</a> <a href="/tags/Linux/" style="font-size: 13.08px;">Linux</a> <a href="/tags/Malware/" style="font-size: 15.38px;">Malware</a> <a href="/tags/Memory/" style="font-size: 13.08px;">Memory</a> <a href="/tags/Migration/" style="font-size: 11.54px;">Migration</a> <a href="/tags/Monitoring/" style="font-size: 13.08px;">Monitoring</a> <a href="/tags/NX/" style="font-size: 10px;">NX</a> <a href="/tags/Overflow/" style="font-size: 10.77px;">Overflow</a> <a href="/tags/PIN/" style="font-size: 10px;">PIN</a> <a href="/tags/Paper/" style="font-size: 11.54px;">Paper</a> <a href="/tags/Ph-D/" style="font-size: 10.77px;">Ph.D</a> <a href="/tags/Ppaerwriting/" style="font-size: 10px;">Ppaerwriting</a> <a href="/tags/Professor/" style="font-size: 12.31px;">Professor</a> <a href="/tags/QEMU/" style="font-size: 14.62px;">QEMU</a> <a href="/tags/RE/" style="font-size: 10px;">RE</a> <a href="/tags/ROP/" style="font-size: 10.77px;">ROP</a> <a href="/tags/Rootkit/" style="font-size: 11.54px;">Rootkit</a> <a href="/tags/SYSCALL/" style="font-size: 10px;">SYSCALL</a> <a href="/tags/Sandbox/" style="font-size: 10.77px;">Sandbox</a> <a href="/tags/Security/" style="font-size: 20px;">Security</a> <a href="/tags/Shellcode/" style="font-size: 10px;">Shellcode</a> <a href="/tags/Snapshot/" style="font-size: 10px;">Snapshot</a> <a href="/tags/Stack/" style="font-size: 10.77px;">Stack</a> <a href="/tags/Syscall/" style="font-size: 10px;">Syscall</a> <a href="/tags/System/" style="font-size: 18.46px;">System</a> <a href="/tags/Systemcall/" style="font-size: 11.54px;">Systemcall</a> <a href="/tags/TSX/" style="font-size: 10px;">TSX</a> <a href="/tags/TrustZone/" style="font-size: 10px;">TrustZone</a> <a href="/tags/VT-x/" style="font-size: 10px;">VT-x</a> <a href="/tags/Valgrind/" style="font-size: 10px;">Valgrind</a> <a href="/tags/Virtualization/" style="font-size: 19.23px;">Virtualization</a> <a href="/tags/Volatility/" style="font-size: 10px;">Volatility</a> <a href="/tags/XEN/" style="font-size: 13.08px;">XEN</a>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      版权所有&copy; 2017 Index of Computer System and Security 保留所有权利.
      </div>
      <div class="site-credit">
       <!--  自豪地使用 <a href="https://github.com/iTimeTraveler/hexo-theme-hiero" target="_blank">hiero</a> --> 
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
</script>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/syssec" class="mobile-nav-link">Syssec</a>
  
    <a href="/architecture" class="mobile-nav-link">Architecture</a>
  
    <a href="/virtualization" class="mobile-nav-link">Virtualization</a>
  
    <a href="/malware" class="mobile-nav-link">Malware</a>
  
    <a href="/conferences" class="mobile-nav-link">Conferences</a>
  
    <a href="/courses" class="mobile-nav-link">Courses</a>
  
    <a href="/academy" class="mobile-nav-link">Academy</a>
  
    <a href="/news" class="mobile-nav-link">News</a>
  
    <a href="/knowledge" class="mobile-nav-link">Knowledge</a>
  
    <a href="/share" class="mobile-nav-link">Share</a>
  
    <a href="/contribution" class="mobile-nav-link">Contribution</a>
  
</nav> -->
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>





  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
  

  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1261078922&web_id=1261078922" language="JavaScript"></script>
  </div>


</body>
</html>
