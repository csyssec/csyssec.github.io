<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Index of Computer System and Security</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="computer system, computer security" />
  
  
  
  
  <meta name="description" content="Diting0x@">
<meta property="og:type" content="website">
<meta property="og:title" content="Index of Computer System and Security">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Index of Computer System and Security">
<meta property="og:description" content="Diting0x@">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Index of Computer System and Security">
<meta name="twitter:description" content="Diting0x@">
  
    <link rel="alternate" href="/atom.xml" title="Index of Computer System and Security" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/hiero.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>

<body>
  <header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            <a href="/" title="Index of Computer System and Security" rel="home">
              Index of Computer System and Security</a>
          </h1>
          <div class="site-description">Diting0x@</div>

            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>
            <div class="clearfix sf-menu">

              <ul id="main-nav" class="nmenu sf-js-enabled">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/syssec">系统安全</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/architecture">系统结构</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/virtualization">虚拟化</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/malware">恶意代码</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/conferences">主流会议</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/courses">名人课堂</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/academy">学术专家</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/news">安全事件</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/knowledge">小科普</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/share">技术分享</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/contribution">本站达人</a> </li>
                    
              </ul>
            </div>
          </nav>


      </div>
  </div>
</header>




  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-rowhammer"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170808/rowhammer/">神乎其神的Rowhammer：用比特位翻转实现云虚拟机夺权</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170808/rowhammer/" class="article-date">
	  <time datetime="2017-08-08T02:16:05.000Z" itemprop="datePublished">八月 8, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <html><br><body><br><span>来源于Freebuf,附上链接：<a href="http://www.freebuf.com/column/133871.html" target="_blank" rel="external">http://www.freebuf.com/column/133871.html</a>. 作者：欧阳洋葱</span><br><br><span>想一个简单的问题，Memory类的存储介质中，每一个栅格存储一个比特位（0或1）。如果因为外力，这个比特位发生翻转，情况会怎样？这并非传说，而且有专家觉得还能应用到针对云服务器的东西向攻击中！</span><br>                          <blockquote><p>我先前在FreeBuf的文章中介绍过一种名为<a href="http://www.freebuf.com/news/107150.html" target="_blank" rel="external">Bitsquatting</a>的攻击手法，这是一种超高端的钓鱼攻击：我们假定内存、CPU缓存由于环境，或者制造缺陷，产生内存的比特位翻转，就可能导致原本我们要访问某家网站，最终由于这种硬件错误，却访问了与这家网站域名相近的钓鱼站点。</p><br></blockquote><br><p><b>其实我个人真正钟爱的领域是成像和半导体，在我去年也算是半只脚踏进神圣的安全行业之后，第一次听说比特位翻转这种听起来极为高端的攻击方式就有些惊呆的感觉。而且这还不是个传说，先前Sun所推的UltraSparc II处理器就存在这样的问题——简单来说，采用UltraSparc II CPU的服务器有些时候会毫无征兆地出现随机性错误，最后发现问题出在SRAM介质之上，据说在生产过程中SRAM存储部分被辐射物污染，可以导致Cache的比特位翻转。</b></p><br><p>Cache比特位如果出现这种随机的翻转，数据处理肯定会出问题，最终就是服务器崩溃。这个问题本身也是因为处理器SRAM缺乏错误检查和纠正机制。我个人在听说这种所谓的“BUG”之后的确是有点三观被毁。对半导体有研究的同学可以去看看这篇Paper：<a href="https://media.blackhat.com/bh-us-11/Dinaburg/BH_US_11_Dinaburg_Bitsquatting_WP.pdf" target="_blank">https://media.blackhat.com/bh-us-11/Dinaburg/BH_US_11_Dinaburg_Bitsquatting_WP.pdf</a></p><br><p>然而实际上，这种听起来很玄幻的攻击其实不算新鲜，虽然看起来具有很强的不可控性，但实际还是可以人为触发其中的“硬件”漏洞（只是据说！！！我很怀疑）。这个漏洞名为Rowhammer，前两年就有人提出了，可能是有史以来最理想化的漏洞。由于其不可控性，很多人认为Rowhammer停留在理论阶段。</p><br><p>去年9月份，有安全研究人员提出一种名为“风水翻转”的攻击技术，主要针对同处一个云环境下的其他虚拟机。其本质也是Rowhammer攻击，据说具备了“高准确性”和“可控”的特点，可从其他虚拟机盗取加密密钥。谁曾想，这种硬件级别的漏洞可以应用到听起来如此靠上的层级（云算是非常上层吧）。</p><br><p style="text-align: center;"><br><img src="http://image.3001.net/images/20160905/14730591835335.jpg!small" width="690"></p><br><noscript><p></p></noscript><br><h2>颠覆攻击逻辑的Rowhammer技术</h2><br><p>去网上查资料，会发现Rowhammer的描绘极为晦涩。但Rowhammer漏洞其实很容易理解，这里我用自己的话来科普以下，这是个特别针对Memory的攻击技术，但不是缓冲区破坏或溢出攻击。一般的计算机Memory介质中，每个存储单元（晶体管+电容器）存放1bit数据，这个比特位要么是0，要么是1——存储单元中充满电子表示1，清空表示0。内存就是由上亿这样的存储单元构成的，数据也因此得以存储。</p><br><p>不过电容器会泄露，一个电容器充满电子后，只需要几毫秒就会泄露殆尽。这就要求CPU（内存控制器）对电容进行充电，让“1”这个值能够保持住。整个过程是由内存控制器先读取电容器中的值，然后再把数据写回去。这种刷新操作，每秒会执行几千次。</p><br><p>这几年的内存容量正在大幅度上涨，所以存储比特位的电容器也就越来越小，排列越来越近。要防止相邻的电容之间相互干扰，难度也就变得更大。如果能够快速、反复访问一排电容，相邻行的电容更容易产生干扰错误和所谓的“比特位翻转”，也就是0变成1。</p><br><p>其实正常的数据读写一般是不会发生比特位翻转的，可是如果对某些行进行反复读写，问题就有可能产生。2014年卡内基梅陇大学的研究人员层发表过一篇论文，题为《无访问情况下的内存比特位翻转——DRAM干扰行错误的试验研究》，其本质是通过机器码指令CLFUSH或Cache Line Flush，强制进行这种比特位的读取和更新。据说利用这种方式，可引起大量比特位翻转。</p><br><p>利用比特位翻转，很多事情都可以做，比如说执行未经授权的代码。这就是所谓的Rowhammer。这是一种颠覆人类对安全认知的攻击技术，软件层面几乎解决无望。先前已经有研究人员演示，如何用Rowhammer来进行提权，以及打破安全沙盒。</p><br><p>不过看原理就知道，这种攻击实在有够理想化，存在诸多不确定性，因为攻击者根本无法精准控制比特位如何翻转。比如说，这种攻击对数据所在的内存位置首先就有要求，这样才能实施内存翻转：但敏感数据存储在这些位置的几率可能并不算高。</p><br><p style="text-align: center;"><img src="http://image.3001.net/images/20160905/14730583438870.jpg!small" width="690"></p><br><noscript><p></p></noscript><br><h2>实现内存“风水逆转”</h2><br><p>所以在去年9月，针对Rowhammer的内存位置限制，有人开发出一种名为Flip Feng Shui（风水翻转）的攻击技术，这本质上也是Rowhammer。这种攻击就是篡改deduplication操作——deduplication在云端主机中应用得很常见，这种技术可让两个或者更多虚拟主机共享特定的数据块，起到节约内存资源的作用。</p><br><p>Flip Feng Shui在物理内存上做手脚，可致加密密钥和其他敏感数据存储到内存特定的位置——这些位置就很容易受Rowhammer的影响了。所以才叫风水翻转，就是让数据在内存中的“风水”位置变更好，Rowhammer攻击变得更可靠。</p><br><p>这种技术是由阿姆斯特丹自由大学的一名研究人员Ben Gras提出的。他说：“先前就已经有攻击方法表明，共同主机的虚拟机彼此间是可以相互攻击的，比如说获取对方的加密密钥。不过这次的攻击更具破坏性，也是此类攻击的第一例。”</p><br><p>“我们可以相当高的精度和可控性，针对目标虚拟机的内存进行篡改。针对这种软件堆栈中看似随机化的数据破坏方式，我们首次以极高的准确性和可控的方式，对其进行了展示。”这里Gras所谓的“看似随机化的数据破坏方式”也就是Rowhammer攻击。</p><br><p style="text-align: center;"><img src="http://image.3001.net/images/20160905/14730586559779.png!small" width="690"></p><br><noscript><p></p></noscript><br><p>研究团队演示了攻击者如何利用Flip Feng Shui攻击，获取另一台VM虚拟机上的RSA加密密钥——当然这要求被攻击的虚拟主机与攻击者处在相同的云环境中。在他们进行的某一例实验中，进行攻击的虚拟机获取到可用于授权安全shell访问的密钥，这样一来，这台虚拟机就可以获取目标虚拟机的未授权访问了。</p><br><p>研究人员在报告中提到，进行攻击的虚拟机获取到GPG密钥——该密钥是Ubuntu系统开发者用来确认更新可靠性的。有了这个GPG密钥，攻击者就能迫使目标虚拟机下载和安装恶意更新。</p><br><p>其实整个攻击过程描述起来还是比较复杂的，首先需要获取目标公钥。发起攻击的虚拟机通过Flip Feng Shui，针对公钥的某个特定部分进行比特位翻转，也就是我们上面提到的Rowhammer攻击方式——这里实际上还利用了云环境的deduplication技术。就像前文提到的，这种技术在云端主机中很常见，这是一种相较数据压缩粒度更大、节约存储资源的技术。基于此，物理页才会在多个虚拟机用户间共享，针对共享数据块的比特位翻转才显得有意义。</p><br><p>在公钥的比特位发生翻转之后，就构造出了一个全新的公钥，这个公钥会非常简单（足以进行因式分解）。也就是说，Rowhammer攻击欺骗目标虚拟机，接受新的公钥；攻击者随后也就能够得到相对应的私钥，并进行未经授权的SSH访问，签署恶意Ubuntu更新了。</p><br><p style="text-align: center;"><img alt="30907982735.jpg" data-original="http://image.3001.net/images/20160905/14730590053968.jpg!small" src="http://www.freebuf.com/buf/themes/freebuf/images/grey.gif" width="690"></p><br><noscript><img alt="30907982735.jpg" src="http://image.3001.net/images/20160905/14730590053968.jpg!small" width="690"><p></p></noscript><br><p>鉴于篇幅关系，这里没法细致详述每一环技术细节，有兴趣的同学可以前往翻阅研究人员发表的论文，题为《<a href="https://www.usenix.org/system/files/conference/usenixsecurity16/sec16_paper_razavi.pdf" target="_blank" rel="external">Flip Feng Shui: Hammering a Needle in the Software Stack</a>》。Gras表示，这次的实验虽然只针对RSA密钥，但他预期未来这种攻击方式还能针对数字签名算法、Diffie-Hellman加密算法、ECC等等。这样一来，攻击者就不仅能够进行未授权访问量了，还能窃听合法会话。</p><br><p>另外，这种攻击也需要一些条件才能发起，比如说像前文提到的，要求虚拟机开启Deduplication；而且本次实验依赖于基于内核的虚拟机，以及Linux中的Kernel SamePage Merging特性。还有，内存芯片本身也需要具备比特位翻转的基础，先前有人做过相应的<a href="https://users.ece.cmu.edu/~yoonguk/papers/kim-isca14.pdf" target="_blank" rel="external">测试</a>，129款DDR3内存中，110款存在攻击可行性，还有12款DDR4内存有8款也存在Rowhammer漏洞（对此，我也真的很震惊，为什么我总是震惊？）。</p><br><p>最后，研究人员还列出了一些可抵御Flip Feng Shui攻击的手段，硬件层面要求DRAM芯片制造商进行相应的Rowhammer测试，还有比如针对某些DDR4芯片实施的直接行刷新机制等；至于软件层面，包括禁用内存的deduplication，开发者和工程师也应该考虑加入额外的措施，比如检查安全敏感信息完整性。</p><br><blockquote><p>“这种攻击不需要攻击者进行什么复杂的操作，就能完全控制共用主机的云虚拟机。同时，我们认为Flip Feng Shui还能通过更多的形式发起攻击，这就需要系统安全社区能够对这样的威胁引起足够的重视。”</p><br></blockquote><br><p>不过说实话，我对这种所谓Rowhammer的攻击精度还是持怀疑态度，是一种“怎么可能”的惊叹。有兴趣的真的很建议去看原paper。如果说针对Memory（包括内存、Cache、Register）的这种比特位翻转攻击真的是可行的，那么任何提权、代码执行之类的操作何苦再从应用或者系统层面去搞定呢？而且它还不是缓冲区溢出攻击那样的层面，应用层的恶意程序更多的是种逆向的边信道攻击。</p><br><p>不过的不过，我对安全本身了解得相当浅层，所以或许其精度有什么特别实现方式。毕竟先前在看ARM的安全文档谈Lab Attack的时候也有点惊呆——即边信道（或者叫侧信道）攻击远比你们想象得复杂和高端，就是实验室里不计成本用到的所谓“电子探针”。突然觉得还有点小激动&#8230;</p><br><p><span style="color: rgb(159, 163, 168);">* 参考来源：<span style="color: rgb(51, 51, 51); font-size: 16px;">《</span><a href="https://www.usenix.org/system/files/conference/usenixsecurity16/sec16_paper_razavi.pdf" target="_blank" rel="external">Flip Feng Shui: Hammering a Needle in the Software Stack</a><span style="color: rgb(51, 51, 51); font-size: 16px;">》</span>，转载请注明来自FreeBuf.COM及作者欧阳洋葱</span></p><br><br></body><br></html>


      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/系统安全/">系统安全<span class="article-category-count">4</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rowhammer/">Rowhammer</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-googleprojectzero"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170808/googleprojectzero/">谷歌Project Zero：通过“Row hammer”漏洞获取系统权限</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170808/googleprojectzero/" class="article-date">
	  <time datetime="2017-08-08T02:05:11.000Z" itemprop="datePublished">八月 8, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <html xmlns:wb="http://open.weibo.com/wb" xml:lang="en" lang="en"><br><br><body onload="iscrollLoaded();"><br><br><p></p><p style="text-align:center"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;"></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">本文转自安全客，附上链接：<a href="http://bobao.360.cn/learning/detail/302.html" target="_blank" rel="external">http://bobao.360.cn/learning/detail/302.html</a><br>本文原作者：Mark Seaborn,沙盒制作和逃逸。以及逆向工程师Thomas Dullien</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212);"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;">概述</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">“Row hammer”是指，最近一些DRAM设备上反复访问一行内存可能造成相邻内存行的bit翻转问题。我们测试了一系列笔记本，并发现其中一部分存在这个问题。我们利用这个问题，开发了两套可用的提权溢出。一个溢出在64位Linux的Ring3受限用户进程中，使用“Row hammer——引导”bit翻转，来获得Ring0权限。当程序跑在存在“Rowhammer”问题的主机中时，进程可以在PTE中印发bit翻转。这可以用来获得内存页的写入权限，进而获得全部物理内存的读写权限。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们还不确定到底有多少台计算机存在这个问题，也不知道有多少存在问题的主机可以修复。我们的溢出程序使用x86指令clflush来获得访问底层DRAM的权限，但是其他的技术是可以用在非x86系统上。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们期望我们基于PTE修改的溢出可以在其他操作系统上使用；这个问题不是Linux独有的。引起PTE表中的bit翻转仅仅是溢出的一种方法；其他的通过bit翻转的溢出也同样有效。我们前文提到的另一个溢出将通过Native Client沙盒逃逸来证明不仅仅可以修改PTE</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212); font-size: 16px;"><strong><span style="color: rgb(84, 141, 212); font-family: 微软雅黑,Microsoft YaHei;">“Rowhammer”问题介绍</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们从Yoongu Kim等人的论文《Flipping Bits in Memory Without Accessing Them:</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">An Experimental Study of DRAM Disturbance Errors》（全部作者：Yoongu Kim，Ross Daly，Jeremie Kim，Chris Fallin，Ji Hye Lee，Donghyuk Lee，Chris Wilkerson，Konrad Lai，Onur Mutlu，Carnegie Mellon University，Intel Labs）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">在论文中，他们演示，通过反复访问同一进程中的两个“敲击”内存地址，可以在被叫做“受波及”的地址引起bit翻转。这个地址很可能位于当前进程虚拟地址以外的内存空间——在与当前的“敲击”内存不同的行中，也就是存在于一个不同的4k内存页中（也是由于当前流行的内存Bank中每一行的容量都大于4k的缘故）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">这个问题是由于存储单元（内存存储的最小计算单元）现在做的越来越小，也越来越紧凑。由于内存制造业不断改进芯片工艺以容纳更多的存储单元，这使得保护存储单元远离相互之间的电器性影响越来越难。因此，访问一个内存地址是会影响到周围的内存，引发电荷逃逸或进入相邻的存储单元。当进行了足够次数的访问，就可以将一个存储单元从0变为1或者从1变为0。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">这篇论文解释道，下面这个简短的代码片就可以导致bit翻转。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">code1a:</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">&nbsp; mov (X), %eax&nbsp; // Read from address X</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">&nbsp; mov (Y), %ebx&nbsp; // Read from address Y</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">&nbsp; clflush (X)&nbsp; // Flush cache for address X</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">&nbsp; clflush (Y)&nbsp; // Flush cache for address Y</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">&nbsp; jmp code1a</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">两个引发bit翻转的的必要因素：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">地址的选取：要使用代码片code1a来引发bit翻转，需要地址X和地址Y位&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 于同一个内存Bank的不同行中。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">一些背景知识：每一个DRAM芯片都包含多个Bank，而每个Bank中很多&nbsp;&nbsp; 行的存储单元。每访问内存&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 中的1字节需要将对应行的数据读取至芯片的&nbsp;&nbsp;&nbsp; “Row Buffer”中（这个过程会放掉对应行中每一个存储单元的电）读取/写入&nbsp;&nbsp;&nbsp;&nbsp; “Row Buffer”的上下文，然后将“Row Buffer”的上下文写回原来的行中（只是&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 读取的具体操作的一种，其&nbsp;&nbsp;&nbsp;&nbsp; 他的可以参考豆丁文档&nbsp; <a href="http://www.docin.com/p-639315446.html" target="_blank" rel="external">http://www.docin.com/p-639315446.html</a> 1.2中的内容）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;在这个“激活”一行（放电、充电）的过程中可以干扰到相邻的行。如果，在&nbsp; 相邻的行进行自动刷新的时候（通常每64ms进行一次），进行了足够多的“激 活”操作，就可以引发相邻行的bit翻转</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">“Row Buffer”扮演了一个缓存的角色，如果地址X和地址Y指向了同一行，那么在执行代码片code1a的时候，只会对“Row Buffer”进行操作，而不会进&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 行“激活”操作（具体可以参考豆丁文档中1.2节中提到的第三种读取方式）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;此外，内存中的每一个Bank拥有一套独立的“Row Buffer”（同样参考文档）。所以，如果地址X和地址Y位于不同的Bank中，在执行代码片code1a的&nbsp; 时候，也只会读取X、Y所在的个子的Bank中的“Row Buffer”而不会进行激&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 活操作。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">而然，如果地址X、Y指向了同一个Bank中的不同行，在执行代码片code1a&nbsp;&nbsp;&nbsp;&nbsp; 的时候，就会引发X、Y所在行之间不断的“激活”操作。这就叫做“Row &nbsp;&nbsp;&nbsp; Hammering”</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">绕过缓存：如果没有代码片code1a中的CLFLUSH指令，那么内存操作（MOVs）将只会记录在CPU的缓存（Cache）中。使用CLFLUSH刷写缓&nbsp;&nbsp;&nbsp; 存可以强制将内存访问命令发送到底层的DRAM中。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;注意到Yoongu Kim等人论文中的代码片code1a版本，还包含了MFENCE&nbsp;&nbsp;&nbsp; 指令，但是我们发没有必要调用MFENCE指令而且事实上调用后反而减少&nbsp; 了被翻转的bit。Yoongu Kim修正过的memtest函数也同样从他的“Row &nbsp;&nbsp;&nbsp;&nbsp; Hammering”代码中忽略掉了MFENCE指令。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">为“锤子”提炼需要选择的地址</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">使用物理地址映射</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">那么，我们如何来挑选成对的地址，来满足这个“不同行同Bank”的要求呢？</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">一种可能性是利用CPU集成的内存控制器对于物理地址到存储单元、内存行、Bank的映射的知识，以及其他相关的知识：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;内存的绝对物理地址，我们有权访问。Linux通过/proc/PID/pagemap</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">内存的相对物理地址，我们有权访问。Linux通过支持2M的连续物理地址&nbsp;&nbsp; 空间的内存页。通常一个普通的内存页仅有4K小于1个内存行，但是一个 2M的内存页，通常将包含多个内存行，其中比部分将存在于同一个Bank&nbsp;&nbsp; 中。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">Yoongu Kim等人通过这个方法。他们选择Y=X+8M基于Intel与AMD的CPU中内存控制器对于物理内存映射的知识。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 16px; color: rgb(84, 141, 212);"><strong><span style="font-size: 16px; font-family: 微软雅黑,Microsoft YaHei;">随机地址选取</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">CPU的物理地址映射很难被确定，尽管一些特性例如：/proc/PID/pagemap、大型内存页并不是通用的。此外，如果我们关于地址映射的猜测是错误的，我们可能会挑选一个降低“Row Hammering”成功率的偏移（比如：Y=X+8k可能使得地址总是在不同的Bank中）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">一个更简单的方法是随机的挑选一对地址。我们申请一大块内存（比如:1G）然后在这块内存中随机挑选虚拟地址。在一台拥有16个Bank的电脑上（例如我们的测试机拥有2个DIMM，每个DIMM拥有8个Bank），这样我们挑选的地址对就有1/16的概率位于同一个Bank中，这个概率已经很高了（当然，地址对位于同一行中的概率就微不足道了，一般一个Bank中有8k+个行）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">此外，我们可以通过修改代码片code1a，使其在每次循环中“Hammer”更多的地址对来提高我们“Row Hammering”的成功率。我们发现每次一次“Hammer”2或者4个地址对并不会增加多少时间。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212);"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">通过计时选择地址</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">另一种判断地址对时候满足“不同行同Bank”特性的方法是使用高精度计时（例如使用RDTSC 指令）记录非缓存访问这些地址所用的时间。拥有此特性的地址对的访问时间要长于其他情况地址对的访问时间。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212);"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">双侧“Hammering”</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们发现通过“Hammering”行N-1、N+1相比“Hammering”一个相邻行和另一个相对比较远的行，可以增加行N的bit翻转的成功率。我们称之为双侧“Hammering”</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">对于很多机器，双侧“Hammering”是在合理的时间内引发bit翻转的唯一方法。而对于那些通过随机选择地址对就已经可以引发bit翻转的，双侧“Hammering”可以在被翻转的bit数上产生一个非常显著的提高。我们在一台非常脆弱的主机层观察到1内存行超过25个bit的翻转。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">由于内存的几何结构使得执行双侧“Hammering”变得更加复杂。它需要攻击者了解或者能猜测到物理地址中同Bank相邻两行之间的偏移值究竟是多少。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">通过我们的测试，我们能够直接推断第4台样本笔记本（详见下表面的表格）的内存行偏移值是256k。我们得出这个结论是通过观察被翻转的bit发生的可能性相对于被选中的内存页到受影响的内存页之间的距离。这个可能性在我们给定目标内存行的情况下在256k上下达到最大值。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">“256k敲击内存区域，256k受波及内存区域，256k敲击内存区域”的设置被证明在同一厂商的其他笔记本上也同样有效。当然，对于其他厂商，这个设置很可能需要修改。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">这256k的内存行偏移，可以被解释成一种产品的内存行的大小、Bank的数量、等等DRAM在这才电脑上的参数，不过这需要更深入的了解引荐是如何将物理地址映射成行、列编号的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">使用双侧“Hammering”需要我们获得物理上连续的内存页（比如：via /proc/PID/pagemap或者大型内存页）</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212);"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">溢出“Row Hammer” bit翻转</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">Yoongu Kim等人说“通过工程化的尝试，我们相信我们可以将code1a发展成干扰攻击，从而获得系统的控制权”，但是他们把这个当做未来的研究任务，而我们现在就做到了！</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们发现了存在bit翻转的各种主机（参考下面的实验结果），并写出了一下两个exp：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">第一个是运行在Native Client（以下简称NaCl）沙盒中的程序，成功逃逸， 并实现直接调用我们本地系统调用。我们已经通过禁用NaCl沙盒中&nbsp;&nbsp; 的程序调用CLFLUSH指令来缓解攻击（我之所以首先选择NaCl沙盒做溢&nbsp;&nbsp; 出，是因为我在这个项目工作，并在之前写过概念性的沙盒逃逸代码）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">第二个是运行在64位Linux系统中的正常进程，成功提权并获得了全部物&nbsp;&nbsp;&nbsp; 理内存的权限。这个在实体机器上很难做到有效的攻击缓解。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212); font-size: 16px;"><strong><span style="color: rgb(84, 141, 212); font-family: 微软雅黑,Microsoft YaHei;">NaCl沙盒逃逸</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">NaCl是一个只允许运行部分x86-64指令的沙盒系统（包括其他构架）。在运行一个x86-64可执行程序前，NaCl会使用一个校验器来检验这个程序的代码是否都在NaCl所认为安全的指令集。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">然而，NaCl假设硬件行为是正确的。它假设内存地址除非调用指令改写，否则是不会改变的！NaCl对于机器码的检验方法在bit翻转面前是非常脆弱的，因为：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;1bit的翻转在验证过的代码中就可以使得一个安全的指令变得不安全。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">在NaCl沙盒中，程序的代码段是可读的。这意味着程序可以检是否发生了&nbsp;&nbsp; bit翻转，并检查是否或者如何利用这个翻转。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们的溢出目的是NaCl沙盒下的直接跳转指令序列，例如如下形式：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">andl $~31, %eax // Truncate address to 32 bits and mask to be 32-byte-aligned.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">addq %r15, %rax // Add %r15, the sandbox base address.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">jmp <em>%rax // Indirect jump.</em></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">溢出原理是通过触发这段指令序列的bit翻转。我们前文已经提到溢出会有13%的可能性造成bit翻转。在这里我们仅使用bit翻转来篡改所用的寄存器（通过进一步研究，还有其他的可利用的方法，比如：篡改操作码）举个栗子，如果在jmp %rax代表寄存器字节的最低bit发生翻转，这就变成了jmp *%rcx，此时由于rcx没有被审查，这就允许我们可以跳转到任意地址上。通常情况下NaCl只允许直接跳转到32字节对齐的地址（并且还要确保指令没有穿越32位约束的边界）当一个程序可以跳转到一个非对齐的地址时，它就可以从沙盒中逃逸。因为该程序可以将不安全的x86指令隐含在安全的x86指令中。例如：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">20ea0: 48 b8 0f 05 eb 0c f4 f4 f4 f4 movabs $0xf4f4f4f40ceb050f,%rax</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">这里在地址0x20ea2上隐藏了一条SYSCALL指令（0f 05）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们的NaCl溢出程序作了如下的工作：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">它使用NaCl信任的直接调转指令填充了由NaCl自带函数dyncode_create声 明的250M的动态代码空间</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">在每次循环中，程序首先挑选随机地址对，对动态代码空间通过CLFLUSH&nbsp; 进行“Row Hammer”。再对动态代码空间进行搜索。如果发现可利用的bit翻&nbsp;&nbsp;&nbsp;&nbsp; 转，就使用它并跳转到隐藏在NACl认证过的指令中的ShellCode。如果，没&nbsp;&nbsp;&nbsp;&nbsp; 有引发可利用的bit翻转，那么继续循环。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们已经通过修改在NaCl中禁用CLFLUSH的策略指令来缓解攻击。（用兴趣的可以跟踪CVE-2015-0565）然而，除了调用CLFLUSH也许还存在其他的方法来引发“Row Hammer”</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">在NaCl中禁用CLFLUSH，可能不仅束缚了NaCl的溢出，还能防止类似后面提到的系统提权，以至于让一个Chrome软件店中的软件仅仅通过一个底层的硬件Bug，就可以获得内核权限。据我们所知，目前Chrome软件店还没有这样的应用。PNaCl，一个在开源Web上面可用的框架，由于拥有一个特殊的保护层，溢出在调用CLFLUSH前，还需要先干掉PNaCl的指令解析器。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 16px; color: rgb(84, 141, 212);"><strong><span style="font-size: 16px; font-family: 微软雅黑,Microsoft YaHei;">内核提权</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们的内核提权的原理是，使用“Row Hammer”引发PTE基址处的1bit翻转。这可以使得PTE指向一个包含攻击者进程页表的物理内存。这赋予了攻击者进程对于自身页表的读写全，进而控制全部物理内存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">以下两点可以帮助我们的bit翻转具有一个很高的可利用性：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;1、“Row Hammer”引发的bit翻转具有很大的反复测试的可能性。这意味着，&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们可以进一步讨论，当一个存储单元可能会翻转，其中的某个bit的位置 对于溢出是否有意义。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">举个栗子：第51bit超过64位PTE中的最高位。如果这里从0变为1，这将 会产生一个比当前系统内存还要大的页号。而这对于我们的溢出是没有任何&nbsp;&nbsp; 意义的，所以我们可以跳过对于这个bit翻转的利用。然而，第12bit作为 PTE的物理页号的中间位。如果，我们将其翻转，那么PTE将依然指向一个&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 有效的物理内存页。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">2、我们喷射大量带有页表的物理内存。这意味着，当PTE物理页号被篡改&nbsp; 的时候，将会有很大的可能性指向我们喷射的页表。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们通过反复mmap相同的文件来达到喷射的效果。这个过程执行起来会迅 速，使用页表喷满3G内存在我们的测试机器上只需要3秒！</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">还有两点注意：</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们的溢出程序是一个正常的Linux进程。从沙盒中的溢出还需要进一步的&nbsp; 研究（例如：Chromium的渲染进程）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们的测试是在一台没有占用过多内存的机器上进行测试的。如果想在一个 内存使用频繁的机器上溢出成功，还需要做更多的工作。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212);"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">接下来：溢出步骤</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">第一步是</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;调用mmap映射一大片内存</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;通过“Row Hammering”随机地址对，找到可以对应的“攻击”地址/“受波及”地&nbsp; 址。我们通过搜索/proc/self/pagemap来找出刚刚跑出结果的物理地址。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;如果我们发现被翻转的bit不能用于我们的溢出，那么跳过这个地址</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">否则，释放掉出目标地址以外的全部内存页然后开始溢出攻击</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">为准备喷射内存页表，我们在/dev/shm （一个共享的内存区段）中创建一个文件。随后我们将频繁的映射它。（随后，我们将介绍如何确定这个文件的大小）我们在这个文件的每4k的开始写入一个标记数，当随后我们检查PTE的变动的时候，我们就可以非常容易的识别我们自己映射的内存页。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">同时，我们也意识到我们的这些内存页不能被分配到连续的物理内存地址中。因为随后的当我们进行bit翻转的时候，很可能导致PTE的指针从一个我们的内存页指向另一个我们映射的内存页。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">为避免这样的问题发生，我们首先要故意碎片化物理内存，这样系统从物理内存上分配出来的地址就随机的了：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">调用mmap（使用参数MAP_POPULATE）从机器的物理内存上申请一大块 空间。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">随后，我们通过调用madvise（使用参数MADV_DONTNEED）从这篇空间 中释放掉一个内存页，都会引起系统申请一个4k的内存页（例如：页表）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们现在已经做好内存喷射前的所有准备工作。要进行内存喷射，我们需要反复的调用mmap来映射之前生成的文件：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们希望每一次映射都会在以2M对齐的虚拟地址上，因此，每一个4k的&nbsp;&nbsp;&nbsp; 页表对应一个2M的虚拟地址空间。我们使用参数MAP_FIXED来达到这个&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 效果</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们通过访问相似的内存页来引导系统构建一些PTE。我们只需要对每个页 表构建一个PTE，因为我们知道我们的bit翻转会命中页表中的第N个PTE，&nbsp;&nbsp;&nbsp; 因为，为了效率，我们只对每一个2M内存区域的第N个4k内存页进行检 查。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">&nbsp;Linux对于每一个进程可以进性的mmap的数量作了限制（2^16）。这意味&nbsp;&nbsp;&nbsp;&nbsp; 着，我们之前在/dev/shm生成的文件必须足够大，以至于，当我们映射了2^16&nbsp; 此后，所申请的空间足够填充大部分的物理内存。但与此同时，我们希望保&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 持文件尽可能的小，这样就浪费掉本来可以用页表填充的内存。因此，在选 择这个文件的大小的时候，我们非常谨慎。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">在喷射内存的过程中，我们调用munmap来释放掉可以进行bit翻转的内存&nbsp;&nbsp; 页。而系统就会有很高的可能性紧接着使用这片物理内存保存页表。我们虽&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 然不能直接操作这片内存页，但是我们可以通过“Row Hammering”来篡改它。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">当完成喷射完成，接下来就是“Hammer”时间。我们通过“Hammer”攻击地址。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 来期望它引发“受波及”地址的bit翻转。不同于前一个溢出例子，这次我们 不能直接观察bit翻转。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">现在，我们来检查PTEs的改变是否可以利用。我们对我们映射的这一大片内存区域进行扫描，看看是否有PTE现在指向了我们申请的空间之外的内存。同样，为了效率，我们只需要检测每2M区域中的第N个内存页。我们可以检测我们之前写入的标记数。如果，我们发现如果所有的标记数都没有改动，那么我们的攻击失败了（胜败乃比家常事，大侠请从新来过）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">如果，我们发现一个标记数被修改了，那么我们已经获得了非法访问一个物理内存页的权限。而且有希望是我当前地址空间的内存页。如果希望更谨慎一点，我们可以来验证一下这个内存页是否看上去像是我们的一个页表项。在这第N个内存页的64位应该看起来像一个PTE（对应的一些标志位是0还是1）。如果，不像那么我们的攻击失败了（胜败乃比家常事，大侠请从新来过）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">能到达在这里，说明我们已经具备对一个很可能是我们自己进程的页表的写入权限。然而，我们还不知道这个页表对应的虚拟地址。我们可以动过下面的步骤来判断：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">在这个内存页中写入一个PTE（比如PTE指向物理内存页0）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">对地址空间做第二次扫描，去找第二个虚拟地址页同样没有指向我们的数据 文件。如果我们不能找到，说明我们的攻击失败（胜败乃比家常事，大侠请&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从新来过）</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212);"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">用页表的写入权限溢出</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们现在已经拥有对于我们当前进程的一个页表的写入权。通过篡改这个页表，我们可以访问物理内存中的任意内存页。对于接下来的溢出，我们现在拥有许多的方法。这些方法在可移植性、简洁性和运行速度上有所不同。高可移植性的方法可以不依赖于对于系统内核数据结构的了解。更快的方法可以在O(1)时间内完成，尽管慢一点的方法啊可能需要扫描全部的物理内存来定位一个数据结构</span></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">一些方法，如下：</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们所使用的方法：篡改一个可执行程序，例如/bin/ping（以root权限运行&nbsp;&nbsp; 但不需要su的程序），使用我们的ShellCode来覆盖程序入口，然后执行程 序。这时我们的ShellCode就将运行在root权限下。这个方法非常迅速而且&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 方便移植，但是这需要访问“/proc/PID/pagemap”。我们载入/bin/ping（通过调 用open和以MAP_POPULATE为参数的mmap）并通过/proc/self/pagema查&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 询文件被载入了哪个物理页面</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">一个相似的方法是修改一个可执行程序的动态库例如&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /lib64/ld-linux-x86-64.so.2（在一些系统上，像/bin/ping这些程序由于他们的&nbsp;&nbsp;&nbsp;&nbsp; 访问许可被锁死，会导致open调用失败）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">其他，低可移植性的方法可以篡改系统内核代码和内核数据结构</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们可以篡改当前进程的UID。这需要定位当前进程的cred结构体，并 了解它的结构</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们可以篡改系统调用的处理代码。我们可以通过SIDT指令快速定位&nbsp;&nbsp; 到对应的物理地址。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">引发“Row Hammering”的途径</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们的概念性的exp使用的x86指令CLFLUSH，因为这是最简单的发送强制内存访问到底层DRAM，并引发“Row Hammering”的方法</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">由于CLFLUSH指令在系统内核以及设备驱动以外，使用的概率是非常小的，因此CLFLUSH指令在用户层代码中可用是令人吃惊的。相比而言，ARM在用户层指令集中不存在这么一条缓存刷新指令。（Linux的ARM版本中JIT所使用的，确实有一个叫做cacheflush的系统调用。它被用来同步指令和数据缓存。而在x86版本中i-cache和d-cache是自动同步的，因此CLFLUSH对于刷新缓存是没有意义的）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们已经修改了NaCl的x86校验器来屏蔽CLFLUSH指令。不幸的是，系统不能屏蔽来自用户层对于CLFLUSH指令的调用。当前，CLFLUSH不能被拦截或者屏蔽，即使使用了VMX（x86虚化技术）（例如RDTSC不用VMX支持就可以拦截。VMX允许拦截很多指令包括WBINVD和CPUID，但还不能拦截CLFLUSH）要拦截CLFLUSH也许需要修改x86构架。从一个安全工程师的角度来看，去掉不必要的受攻击面是好的习惯。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">然而，不通过CLFLUSH也许还有其他的方法来引发“Row Hammering”，这也许可以使用在非x86构架上：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">正常的内存访问：正常访问内存经过足够多的次数或者正确的方式，可以造 成大量的缓存未命中，从而引起“Row Hammer”的bit翻转吗？这需要使得每&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一层缓存都未命中（L1、L2、L3等等）这是否可行取决于这些缓存之间的&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 关联性。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">如果这个方法可行，这将会是一个严重的问题。因为，可能当打开网页执行 JavaScript时，通过JavaScript的数组就可以造成bit翻转。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">绕过Cache的内存访问：在x86指令集中，有一类叫做非暂时移动指令（例 如：MOVNTI, MOVNTQ,MOVNTDQ(A), MOVNTPD, MOVNTSD and &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOVNTSS）和预读取指令（例如：PREFETCHNTA） （编者注：这些指令&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 是不同过Cache直接读写内存的）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">原子内存访问：一些报告称无恶意的使用spinlock可以引发“Row &nbsp;&nbsp;&nbsp; Hammering”，然而这些报告细节不够具体，我们也无从验证（论文《</span><a style="text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;" href="http://www.futureplus.com/images/FS2800/The%20Known%20Failure%20Mechanism%20in%20DDR3%20memory%20called%20Row%20Hammer.pdf" target="_blank" rel="external"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">The &nbsp; Known Failure Mechanism in DDR3 memory called “Row Hammer”</span></a><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">》作者：&nbsp; Barbara Aichinger）但这看上去在共享最高级缓存的多核心系统中不太可能实&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现。然而，它可能在核心之&nbsp;&nbsp;&nbsp;&nbsp; 间没有共享Cache的多路系统中 实现。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">未对齐原子内存访问：x86处理器可以保证使用LOCK前缀的指令对内存的 访问是原子级别的，即使要访问的地址是未对齐的，甚至超过了缓存界限。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; （详见《Intel® 64 and IA-32 Architectures Developer&#39;s Manual》8.1.2.2节&nbsp;&nbsp; “Software Controlled Bus Locking”。其中提到总线锁的完整性是不受地址是&nbsp;&nbsp; 否对齐的影响的）这个性质为了向后兼容而存在至今。在这种情况下，CPU&nbsp;&nbsp; 为了内存访问的原子操作而放弃使用缓存一致性机制。相反，CPU回到原始&nbsp;&nbsp;&nbsp;&nbsp; 的总线锁机制，我们相信CPU将使用非缓存的内容访问方式。（在一些多&nbsp; 路CPU非一致性内存访问的主机上，总线锁是通过QPI协议而不是物理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOCK针脚）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">如果非对齐原子操作产生了非缓存DRAM访问，那么这可能会引发“Row &nbsp;&nbsp; Hammering”</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">初步调查表明这些原子操作确实绕过了缓存，但是这些访问太缓慢，以至于 不能在有效的时间（64ms的刷新间隔）内进行足够的内存访问操作，来产&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 生bit翻转</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">非缓存内存页：例如，Windows中CreateFileMapping函数使用参数&nbsp; SEC_NOCACHE可以申请到一片非缓存内存页映射。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">其他操作系统的接口：这可能发生在系统内核或者设备驱动中（例如GPU&nbsp;&nbsp;&nbsp; 驱动）可以在用户层代码中进行绕过缓存的内存访问。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212); font-size: 16px;"><strong><span style="color: rgb(84, 141, 212); font-family: 微软雅黑,Microsoft YaHei;">实验结果</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们通过使用CLFLUSH随机地址对测试了一系列x86笔记本（都没有使用ECC内存）。我们发现其中大部分的机器存在“Row Hammer”引发bit翻转的现象。这个结果已经展示在下面的表格中</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">这个测试所使用的“rowhammer-test”测试程序可以从这里获得：</span></p><p style="text-indent: 2em; text-align: left;"><a style="text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;" href="https://github.com/google/rowhammer-test" target="_blank" rel="external"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">https://github.com/google/rowhammer-test</span></a></p><p style="text-indent: 2em; text-align: left;"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">注意：</span></strong></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们的样本空间还不足够作为一个严格的代表</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">一台给定电脑上的一个否定结果（没有bit翻转）并不意味着“Row Hammer” 在这台机器上不可能引发bit翻转了。我们没有进行足够的测试来证明一台&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 给定的机器是安全的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">作为结果，我们决定隐藏一部我们的数据</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">所有被测试的机器都使用DDR3内存。我们没有办法鉴别出所有的内存使用年限。</span></p><p style="text-align:center"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;"><img alt="http://p2.qhimg.com/t013c34db03148aa6db.png" src="http://p2.qhimg.com/t013c34db03148aa6db.png" title="t013c34db03148aa6db.png"></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">同时，我们也测试了一些桌面电脑，但是在它们上面没有发现任何bit翻转。这可能是由于，都是使用了ECC内存的高档电脑吧。ECC技术可以隐藏掉bit翻转。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212);"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">测试你自己的电脑</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">用户可能希望通过上面提到的“rowhammer-test”测试程序来测试它们自己的电脑。如果一台电脑在测试的过程中产生了bit翻转，那么用户一定希望变得安全并信任关于机器的结果</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">与此同时在测试过程中没有bit翻转的机器也并不意味着安全。这个测试仅仅证明引发bit翻转在这台电脑上比较困难</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212); font-size: 16px;"><strong><span style="color: rgb(84, 141, 212); font-family: 微软雅黑,Microsoft YaHei;">攻击缓解</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">针对附近内存行的刷新</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">为防止“Row Hammer”引发bit翻转，一些方案提出改进DRAM，改进内存控制器，或两者兼而有之。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">Yoongu Kim等人在他们的论文中讨论了。一个系统可以确保在一个给定的时间周期内，即使没有确定相邻的内存航是否正在刷新，也不会对给定的内存行进行过多次数的“激活”。他们的论文中提出“维护一组计数器”（无论保存在内存控制器中还是DRAM中），用来记录“激活”的次数。这篇论文建议另一个叫做“PARA”的概率性的方案。这个方案并不是很正规也因此不需要维护计数器。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">有迹象显示一些较新的硬件已经具有缓解能力：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">JEDEC近期发布的LPDDR4（“LP”代表低电压）将了两个“Row Hammer”攻击缓解技术列入说明书。这两个技术很可能将用于内存控制器中。（具体看以查看JEDEC &nbsp;document JESD209-4，虽然从JEDEC官网注册后才能下载，但是注册是免费的）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">“目标行刷新”模式（TTR），这允许内存控制器要求DRAM设备刷新指定行的周围行</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">“最大‘激活’计数”（MAC），这指定了一内存在其相邻内存行需要刷新前，所能承受的安全的“激活”次数</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">（LPDDR4的说明书并没有直接提到“Row Hammer”这一次，但是他们使用了术语“受波及的内存行”）</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们还发现至少一家DRAM生产商在他们的公开数据中表示他们不需要借助特殊的内存控制器的支持，已经在DRAM设备中加入了“Row Hammer”&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 攻击缓解方案。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们测试的一些较新型号的笔记本确实没有出现bit翻转。一个很可能的解释是这些笔记本都具有了“Row Hammer”攻击缓解能力</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">BIOS升级与加快刷新频率</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">硬件生产商是不是已经悄悄的推出BIOS升级？通过修改BIOS对于CPU内存控制器的配置，缓解了“Row Hammer”问题。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">举个栗（实）子（验），我们对第4台样本笔记本进行双侧“Hammering”来观察发生bit翻转所需要的时间。这个观察到时间都没有超过5分钟。随后我们将笔记本的BIOS更新到最新的版本，然后重新进行“Row Hammering”测试。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们最初以为现在的BIOS已经修复了这个问题。然而，经过接近40分钟的连续“Row Hammering”测试，还是出现了bit翻转。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们推测更新的BIOS提高了DRAM的刷新频率。这使得在DRAM的刷新间隔中造成足够多的干扰标的更加困难，但也还存在成功的可能性。这个与Yoongu Kim等人的论文中所提到的相符（参考论文第四个表格）在他们的论文中提到，对于一些DRAM型号，32ms的刷新周期是不足以将bit翻转概率降至0的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们没有大范围的对笔记本上的BIOS升级进行测试。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">使用性能计数器监视“Row Hammering”</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">CPU性能计数器也许可以被用来检测“Row Hammering”攻击。为了有效地“Hammer”一片内存区域，攻击者必须在短时间内产生大量对底层DRAM的访问。不论攻击者使用CLFLUSH还是通过正常的内存访问，这都会产生大量的缓存未命中。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">现代的CPU为性能分析提供允许监视缓存未命事件的方法。这些方法可以被防御方，有目的的用来监视系统突发的缓存未命中，因为正常的缓存未命中的访问方式在台式机和笔记本上都是极少发生的。通过记录每N个缓存未命中发生所需要的时间并监视不正常的变化，即使在系统繁忙的时候，我们也可以发现“Hammer”攻击。不行的是，即使我们检测到可能的“Hammer”攻击时，我们即无法做出明确的响应，也不知道正常的缓存未命中如何确定。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">与此同时，攻击者也可以使他们的攻击规避这些这种检测，这将增工程量，让这个监控程序变成了一个指令检测程序。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 16px; color: rgb(84, 141, 212);"><strong><span style="font-size: 16px; font-family: 微软雅黑,Microsoft YaHei;">揭露真相</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">计算机行业（谷歌也是其中一员）对于软件中的安全问题已经习以为常了。这也使得，对于公开讨论和披露的安全问题的重要性已经形成了共识。通过这些公开的讨论，也使得对于存在安全风险的Bug得到了更深入的认识。虽然这个行业对于硬件Bug还不太了解，但是通过公开讨论和披露这些相同的方式，也可以让硬件安全获益。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">考虑到这一点，我们可以得出两点经验：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">Bug的可以用性：回过头来，如果有更多的关于“Row Hammer”的披露，这个问题就会被更早的当做一个安全问题。看来生产商对于“Row Hammer”的了解已经有一段时间了，就像刚刚提到的LPDDR4中的“Row Hammer”攻击缓解的方案。也许是因为生产商并不认为这是一个具有威胁的安全问题。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">评估计算机风险：期待公布更多的关于“Row Hammer”的技术细节，这将有助于评估一台计算机究竟存不存在这个问题。截止到这篇文章结束，还是很难断言一台计算机不受“Row Hammer”影响。测试可以说明一台计算机存在漏洞，但不能证明完全不存在漏洞。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">我们接下来具体阐明这两点</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">Bug的可以用性</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">生产商并不会认为这是一个具有威胁的安全问题，假设这个溢出很难实现。我们所看到的关于“Row Hammer”的材料，没有一篇（除了Yoongu Kim等人的论文）探讨其安全威胁。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">然而，许多问题看上去很难实现溢出，但实际被证明可以被利用。这些问题最初可能被认为仅仅是一个无关紧要的问题，结果最终变成了一个安全问题。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">举个极端的栗子，最近Project Zero的Blog上描述的一个很难溢出的问题（地址：<a href="http://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html）这里展示了通过一字节偏移的覆盖实现了溢出以一个正常用户获得了root权限" target="_blank" rel="external">http://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html）这里展示了通过一字节偏移的覆盖实现了溢出以一个正常用户获得了root权限</a></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">对于大多数安全研究人员，尤其是那些练习写验证性溢出程序的人员，大家都知道bit翻转是可以被拿来利用的。例如一篇2003年的论文就像我们展示了如何利用随机bit翻转来实现JAVA虚拟机的逃逸。（详见“利用内存错误攻击虚拟机”，作者Sudhakar GovindavajhalaAndrew W. Appel.，地址：</span></p><p style="text-indent: 2em; text-align: left;"><a style="text-decoration: underline; font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;" href="https://www.cs.princeton.edu/~appel/papers/memerr.pdf）" target="_blank" rel="external"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">https://www.cs.princeton.edu/~appel/papers/memerr.pdf）</span></a></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">而且，就像我们文章中所说的，“Row Hammer”引发的bit翻转是比随机bit翻转更加好利用，因为“Row Hammer”引发的bit翻转是可重复尝试的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">评估计算机风险</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们鼓励生产商公布设备的信息，这样安全研究人员和公众可以用以评估他们的计算机是否存在“Row Hammer”问题</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">接下来信息对于我们的评估将会是有帮助的：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">对于每一种DRAM设备：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">这个DRAM设备在物理层面上容易被“Row Hammer”引发bit翻转吗？</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">这个DRAM设备包含了那些“Row Hammer”的缓解方法？它包含TRR或者MAC吗？这些缓解方法是否需要CPU内存控制器的支持？</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">对于每一款CPU：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">这款CPU的内存控制器中包含那些缓解方法？这些方法需要DRAM设备支持吗？</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">是否有关于在计算机初始化时如何配置CPU内存控制器的公开文档？</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">当初始化完成后，还是否有可能读写内存控制器的配置内容，用来验证是否开启了缓解方法？</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">内存控制器是如何将物理地址与DRAM中的存储单元、行、Bank对应起来的？这对于发觉究竟是哪几种内存访问方式可以引起“Row Hammering”是有很大帮助的</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">对于每一种BIOS：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px; color: rgb(84, 141, 212);">究竟哪一种缓解机制被BIOS在CPU内存控制器中开启了？例如，BIOS开启了双倍的刷新频率或者使用了TRR？这些配置都可见吗？</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">截止到发布这篇文章，我们都不能找到一点关于以上内容的公开信息。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">如果以上的信息大部分都可以获得，那么评估一台计算机将会非常简单。这也使得我们可以更容易的在测试没有产生bit翻转时，判断这台计算机是否存在这个问题。当一台机器经过测试没有发现bit翻转时，我们可以解释说是因为DRAM包含了缓解措施，或者因为DRAM物理层面上不易受到影响（究其原因，是生产商使用了旧的生产工艺）或者因为BIOS初始化了两倍的内存刷新频率。如此解释，会让我们在测试没有结果的时候有更多的自信判断这台计算机并不受这个问题影响，而不是因为我们反复的测试中存在一些不足的地方。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们希望研究人员在接下来的时间里，会对评估“Row Hammer”缓解方案感兴趣。例如，让DRAM设备记录内存行“激活”的次数（就像MAC方案中建议的一样）或者像PARA使用概率的方法。这些缓解方案的效果在双侧“Hammering”和单侧 “Hammering”下一致吗？DRAM设备和内存控制器独立的缓解方案是否会互相影响。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212); font-size: 16px;"><strong><span style="color: rgb(84, 141, 212); font-family: 微软雅黑,Microsoft YaHei;">结论</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">我们展示了两种通过“Row Hammering”的溢出案例。历史不断向我们证明，一个看似不可利用的错误，最终变成了严重的安全问题，而本文中的“Row Hammer”就印证了这一点。许多的安全软件还停留在除非对地址进行操作，否则内存不会被篡改的思想里。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">在过去的十年里，公开讨论软件的瑕疵和对应的利用使得计算机行业对于安全的理解有了巨大的发展。也使得可靠的软件生产商在他们的产品出现问题时及时通知用户进行升级。虽然相比于软件问题，计算机行业还不太习惯于硬件问题，我们应该鼓励硬件生产商采取相同的态度，来彻底的分析这些看似不可利用的错误所带来的影响，提供详尽的说明、缓解方案以及固件或者BIOS的升级。通过讨论可以使得硬件更加安全，而让广大的用户从中受益。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(84, 141, 212);"><strong><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">友情出演</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">Matthew Dempsky提出通过对PTE进行bit翻转来实现“Row Hammer”攻击</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 14px;">Thomas Dullien帮助测试了大量受影响的计算机，提出了双侧“Hammering”的思路，作了BIOS升级实验，并帮助具体的完善了PTE<span style="font-size: 16px; font-family: 仿宋_GB2312;">的</span><span style="font-family: 微软雅黑,Microsoft YaHei; font-size: 16px;">bit</span><span style="font-size: 16px; font-family: 仿宋_GB2312;">翻转溢出。</span></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 16px; font-family: 仿宋_GB2312;"><br></span></p><p></p><br><br><p>本文由 安全客 翻译，转载请注明“转自安全客”，并附上链接。<br><a class="text-more" href="http://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html" target="_blank">原文链接：http://googleprojectzero.blogspot.com/2015/03/exploiting-dram-rowhammer-bug-to-gain.html</a></p><br><br><br><br><br></body><br></html>







      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/系统安全/">系统安全<span class="article-category-count">4</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rowhammer/">Rowhammer</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-bypassaslr-analysis"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170807/bypassaslr-analysis/">ASLR保护机制被突破的攻击技术分析</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170807/bypassaslr-analysis/" class="article-date">
	  <time datetime="2017-08-07T04:42:08.000Z" itemprop="datePublished">八月 7, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <html xmlns:wb="http://open.weibo.com/wb" xml:lang="en" lang="en"><br><head><br><div class="content clearfix"><br>  <div class="main"><br>      <div class="article"><br>          <div id="article_box"><br>            <p>本文转自安全客，并附上链接:<a href="http://bobao.360.cn/learning/detail/3520.html" target="_blank" rel="external">http://bobao.360.cn/learning/detail/3520.html</a> <br><a class="text-more" href="http://www.cs.vu.nl/~herbertb/download/papers/revanc_ir-cs-77.pdf" target="_blank">论文原文链接：http://www.cs.vu.nl/~herbertb/download/papers/revanc_ir-cs-77.pdf</a></p><br>            <hr size="1"><br>            <p></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></strong></span></p><hr><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">最近，基于硬件的攻击已经开始通过Rowhammer内存漏洞或旁路地址空间布局随机化保护机制来攻击系统了，这些攻击方式都是基于处理器的内存管理单元（MMU）与页表的交互交互方式的。这些攻击通常需要重复加载页表，以观察目标系统行为的变化情况。为了提高MMU的页表查找速度，现代处理器都使用了多级缓存，例如转译查找缓存（translation lookaside buffers，TLB）、专用页表缓存，甚至通用数据缓存。要想攻击得手，需要在访问页表之前可靠地刷新这些缓存。为了从非特权进程中刷新这些缓存，攻击者需要基于这些缓存的内部体系结构、大小以及缓存交互方式来创建专门的内存访问模式。虽然关于TLB和数据高速缓存的信息通常都会在供应商的处理器手册中发布，但是关于不同处理器上的页表高速缓存的特性方面的信息却鲜有提及。在本文中，我们改进了最近提出的针对MMU的EVICT + TIME攻击，对来自Intel、ARM和AMD的20种不同微架构中页表缓存与其他缓存的内部架构，大小以及其交互方式。同时，我们以代码库的形式将我们的发现公之于众，该代码库不仅提供了一个方便的接口来刷新这些缓存，同时还可以用来在新的体系结构上自动逆向页表缓存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">引言</span></strong></span></p><hr><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">由于添加到系统中的高级防御日益增加，致使针对软件的攻击的难度也是与日俱增，因此，针对硬件的攻击反而成为一种更有吸引力的替代方案。在这些攻击也是五花八门，既有利于Rowhammer漏洞攻击系统的，也有使用旁路攻击破坏地址空间布局随机化来泄漏加密密钥的，甚至还有用来跟踪鼠标移动的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在这些针对硬件的攻击中，有许多攻击都是通过滥用现代处理器与内存来实现的。目前，所有的处理器的核心都是存储器管理单元（MMU），它通过在多个进程之间提供虚拟化内存来简化可用物理存储器的管理工作。MMU使用称为页表的数据结构来执行虚拟存储器到物理存储器之间的转换。页表是基于硬件的攻击的目标所在。例如，由Rowhammer漏洞导致的页表页中的单个位翻转，将会授予攻击者某种访问权限来访问本来无法访问的物理内存，从而进一步获得超级用户权限。此外，诸如ASLR和其他使用ASLR引导的安全防御机制都依赖于代码或数据都是被随机存储到虚拟存内存中这一特性的。由于这个（秘密）信息被嵌入在页表中，攻击者可以利用MMU与页表的交互方式进行旁路攻击，以获取这些机密信息。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">从虚拟内存到物理内存的转换通常会很慢，因为它需要进行多次内存访问来解析原始虚拟地址。为了提高性能，现代处理器都使用多级缓存，例如转译查找缓存（TLB）、专用页表缓存，甚至通用数据缓存。为了成功攻击页表，攻击者经常需要重复刷新这些缓存，以观察系统在处理页表时的行为。通过参阅处理器手册，人们可以很容易找到TLB和数据高速缓存的各种详细信息。然而，关于页表缓存的信息，例如它们的大小和行为，通常是很难找到的。因为没有这些信息，攻击者需要借助于试错法，所以，如果他们要想打造可以适用于多种体系结构上的攻击的话，难度可想而知。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在本文中，我们对现有的AnC进行了重大的升级改造。AnC是一种针对MMU的EVICT + TIME旁路攻击，它能够对Intel、ARM和AMD等公司的20多种微架构的处理器的页表缓存的大小、内部体系结构以及它们与其他缓存的交互方式进行逆向。AnC依赖于以下事实：MMU查找的页表将被存储在最后一级高速缓存（LLC）中，以供下一次查找时使用，从而提高地址转换速度。通过刷新LLC的部分内容和对页表查找进行定时，AnC可以识别出LLC的哪些部分是用来存储页表的。除了刷新LLC，AnC还需要刷新TLB以及页表缓存。由于有关TLB和LLC的大小的信息是可知的，所以攻击者可以使用AnC来逆向自己感兴趣的页表缓存的特性，如其内部结构和大小等。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">简而言之，我们做出了以下贡献：</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 176, 80);">我们描述了一种新技术，可以用来对现代处理器中非常常见却无文档说明的页表缓存进行逆向工程。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 176, 80);">我们利用Intel、ARM和AMD的20种不同微结构处理器对我们的技术进行了深入评估。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 176, 80);"><span style="color: rgb(0, 176, 80); font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">我们以开源软件的形式发布了用于刷新缓存的框架实现。我们实现的框架提供了一个方便的接口，可以方便地应用于我们已经测试的各种微架构上，来刷新页表缓存，并且它还可以用来自动检测新处理器上的页表缓存。更多信息，请访问：&nbsp;</span><span style="color: rgb(0, 176, 80); font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;"><a href="https://www.vusec.net/projects/anc" _src="https://www.vusec.net/projects/anc" target="_blank" rel="external">https://www.vusec.net/projects/anc</a>&nbsp;</span></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">背景和动机&nbsp;</span></strong></span></p><hr><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">在本节中，我们讨论分页内存管理机制和它在大多数现代处理器上的实现。此外，我们还将考察MMU是如何进行虚拟地址转换的，以及用于提高这种转换性能的各种缓存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">页式技术和MMU</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">页面技术已经成为现代处理器架构的一个组成部分，因为它能够通过虚拟化技术来简化物理内存的管理：由于地址空间有限，操作系统不再需要重新分配应用程序的整个内存，并且不再需要处理物理内存碎片。此外，操作系统可以限制进程访问的内存空间，防止恶意代码或故障代码干扰其他进程。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">它所带来的直接后果，就是许多现代处理器架构都采用了MMU，一个负责将虚拟地址转换为相应物理地址的硬件组件。转换信息被存储在页表中——一种多级单向树，每个级别都可以由虚拟地址的一部分进行索引，从而选择下一级页表，或者在叶级别，也就是物理页面。因此，每个虚拟地址都能够从树的根节点到叶节点唯一地选出一条路径以找到对应的物理地址。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">图1详细展示了MMU是如何在x86_64上执行虚拟地址转换的。首先，MMU读取CR3寄存器以找到顶级页表的物理地址。然后，用虚拟地址的前9位作为索引在该页表中选择页表项（PTE）。这个PTE包含对下一级页表的引用，然后用虚拟地址中接下来9位的作为索引继续选择页表项。通过对下两个级别重复该操作，MMU就可以在最低级页表中找到对应于0x644b321f4000的物理页了。</span></p><p style="text-align:center"><img src="http://p5.qhimg.com/t0160dec3ffed79a683.png" title="t01e6858fccdfa83b82.png" alt="http://p2.qhimg.com/t01e6858fccdfa83b82.png"></p><p style="text-align: center; text-indent: 0em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">图1：在x86_64架构上，将0x644b321f4000转换成其对应的内存页的MMU的页表查询过程。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">缓存MMU的操作</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">如果MMU可以避免从头开始解析其最近已解析过的虚拟地址的话，那么内存的访问性能就会得到极大的改善。为此，CPU会将解析过的地址映射存储到TLB高速缓存中。因此，如果在TLB中命中的话，就无需查询各个页表了，而这个过程是需要花费许多时间的。此外，为了提高TLB未命中时的性能，处理器会将页表数据存储到数据高速缓存中。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">现代处理器还可以进一步提高TLB未命中情况下的地址转换性能，方法是使用页表缓存或转译缓存来缓存不同级别页表的PTE。虽然页表缓存使用物理地址和PTE索引进行索引，但是转换缓存使用的是已经过部分解析的虚拟地址。通过转译缓存，MMU可以查找虚拟地址并选择具有最长匹配前缀的页表，即选择存在于给定虚拟地址的高速缓存内的最低级页表。虽然这允许MMU免去部分页表的查询工作，但是转译缓存的实现同时也带来了额外的复杂性。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">此外，这些高速缓存在实现方式也可以多种多样，不仅可以实现多个专用的高速缓存供不同的页表级使用，而且还可以实现单个高速缓存来供不同的页表级共享，或者甚至可以作为一个可以缓存PTE的TLB来加以实现。例如，AMD的Page Walking Caches（就像在AMD K8和AMD K10微架构中发现的那样）采用的是统一页表缓存的方式，而Intel的Page-Structure Caches的实现采用的是专用的转译缓存的方式。类似地，ARM在针对低功耗和硅利用率而优化的设计中实现了统一的页表缓存（页表查询缓存），同时它们在针对高性能而优化的设计中实现了统一的转换缓存（中间页表查找缓存）。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">图2展示了当MMU翻译虚拟地址时不同高速缓存的交互方式。虽然TLB和缓存具有完整的文档说明，但是关于页表和翻译缓存的诸多细节仍然缺乏相关的文档说明。</span></p><p style="text-align:center"><img src="http://p3.qhimg.com/t019def034f041288b0.png" title="t01171424d03658fcfa.png" alt="http://p3.qhimg.com/t01171424d03658fcfa.png"></p><p style="text-align: center; text-indent: 0em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">图2：MMU的通用实现以及将虚拟地址转换为物理地址的所有组件。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">研究动机</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">最近的基于页表滥用的硬件攻击，都要求能够正确刷新页表缓存，才能完成相应的操作。例如，预取攻击依赖于一个正确的时机，届时虚拟地址转换恰好在一个页表缓存中部分成功，借以了解内核中随机化地址方面的信息。而Rowhammer攻击在处理页表时则需要重复刷新TLB和页表缓存，以扫描物理内存中的敏感信息&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">另一个需要刷新页表缓存的例子是AnC攻击。MMU的页表查询结果会被缓存到LLC中。AnC利用这个事实来完成FLUSH + RELOAD攻击，以确定出MMU在页表查询期间访问的页表内存页中的偏移量。知道这个偏移量后，就能找到经过随机化处理后的虚拟地址，从而攻陷ASLR防御机制。但是，为了完成一次可靠的攻击，AnC需要尝试多种不同的访问模式，并且每种模式都需要尝试许多次，并且每次都需要有效地刷新页表缓存以便触发完整的页表查询流程。因此，关于页表缓存的内部工作机制的知识，对于完成正确高效的AnC攻击来说是非常必要的。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在某些情况下，TLB用作页表缓存。在这些情况下，cpuid指令可以用来了解不同TLB的大小，这样就知道了不同页表缓存的大小了。但是，在一些x86_64微体系结构上，cpuid指令并不会给出所有TLB的大小。例如，尽管在Intel Sandy Bridge和Ivy Bridge处理器上存在可以缓存1 GB页面的TLB，但这些信息根本无法通过cpuid指令获取。此外，在其他CPU体系结构上，可能没有办法获取TLB的大小，或者页表缓存可能已经实现为完全独立的单元。因此，我们需要一个更通用的方法来探索页表缓存的重要属性。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">页表缓存逆向技术</span></strong></span></p><hr><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">我们现在开始讨论如何改造AnC技术，以探测页表缓存的各种属性。实际上，我们需要克服许多挑战，才能使AnC适用于不同的架构，这些将在后面展开详细的讨论。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">使用MMU的缓存信号&nbsp;</span></strong></span></p><p style="text-align:center"><img src="http://p7.qhimg.com/t0157edf8ac3bdb1710.png" title="t0122307c8196661603.png" alt="http://p8.qhimg.com/t0122307c8196661603.png"></p><p style="text-align: center; text-indent: 0em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">代码清单1：设计原理示意代码</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在了解页表缓存时，我们依赖于这样一个事实，即MMU的页表查询结束于目标处理器的数据缓存处。下面以Intel x86 64为例进行说明，这里假设使用了四个页表级别，那么给定虚拟地址v的MMU的页表查询会将来自4个页表内存页的4个缓存行放入L1数据缓存以及L3，假设L3包括L1。这样一来，如果高速缓存行仍然位于数据缓中的话，那么再次对虚拟地址v进行页面查询的时候，就会变得相当快。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">CPU数据缓存被分为不同的缓存集。每个缓存组可以存储多达N个缓存行，这被称为N路组相关缓存。Oren等人发现，给定两个不同的（物理）内存页面，如果它们的第一个缓存行属于同一缓存组，那么页面中的其他缓存行也会共享（不同的）缓存组，即如果我们在一个与缓存行边界对齐的页面内选择了偏移t，那么另一内存页中的偏移t处的缓存行就会共享相同的缓存组。这是因为：为了让两个内存页的第一个缓存行位于同一个缓存组中，那么决定缓存组和切片（slice）的两个页面的物理地址的所有位必须是相同的，并且两个页面内的偏移将共享相同的低位。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">利用缓存的这个特性，我们可以轻松利用一些内存页来用作驱逐缓冲区。假设用于转换虚拟地址v的四个页表项中的一个正好位于页表内存页的偏移零处。当我们访问驱逐缓冲区中所有页面的第一个缓存行的时候，我们将从缓存中驱逐掉MMU的最近转换虚拟地址v时的页表查询结果。因此，虚拟地址v的下一次页表查询将会变得稍微慢一些，因为它需要从内存获取前面提到过的页表项。这就是一个EVICT + TIME攻击的例子，通过它，AnC就能够在存储页表项的内存页面中，从潜在的64个缓存行中找出4个缓存行。注意，通过尝试来自虚拟地址v之外的各种偏移，我们可以弄清楚每个级别中的页表项对应于哪些缓存行中。例如，如果我们在v + 32 KB上执行EVICT + TIME，与在v上执行EVICT + TIME时相比发生变化的缓存行对应于级别1页表的缓存行。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">这是因为在x86 64架构上，每个缓存行可以存储8个页表项，映射32 KB的虚拟内存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">假设一个页表缓存对应于一个页表级别，若不刷新该级别的页表缓存的话，我们就无法观察MMU在该级别上的活动。举例来说，假设有一个页表缓存，它用来缓存具有32个表项的2级页表。假设2级页表中的每个表项可以映射2 MB的虚拟内存，当我们访问连续的64 MB虚拟缓冲区（以2MB为边界）的时候，我们将刷新该页表缓存。因此，我们可以轻松地通过蛮力方式穷举每个级别的潜在页表缓存的大小。例如，如果在x86 64架构的Intel处理器上我们无法通过AnC观察到上面三级页表的信号，那是因为该页面（转译）缓存位于2级页表中。然后，我们可以蛮力破解该缓存的大小，然后移动到上一级。代码清单1为我们展示了具体的实现过程。注意，与AnC不同，我们采用了一个已知的虚拟地址，所以我们可以准确知道MMU信号应该出现在缓存中的什么地方。当然，为了提高清单1中代码的鲁棒性，使其适用于多种处理器架构，我们还需要解决许多问题，具体将在后文中详细展开。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">确保存取顺序</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">许多现代CPU架构都实现了乱序执行技术，其中指令的执行顺序取决于输入数据的可用性，而不是它们在原始程序中的顺序。在应用乱序执行技术之后，指令在解码之后被插入等待队列中，直到它们的输入操作数可用为止。一旦输入操作数可用，该指令就会被发送到相应的执行单元，这样的话，这条指令就会先于前面的指令由该单元执行了。此外，这种CPU架构通常都是超标量的，因为它们具有多个执行单元，并且允许将多条指令调度到这些不同的执行单元中并行执行。在指令执行完成之后，它们的结果将被写入另一个现已“退休的”队列中，该队列以原始程序的顺序进行排序，以保证正确的逻辑顺序。此外，有些现代CPU架构不仅具有针对指令的乱序执行的能力，而且它们还具有对内存操作进行重新排序的能力。为了测量这种CPU体系结构上单个指令的执行时间，我们必须在定时指令之前和之后注入内存屏障，并目标代码之前和之后插入代码屏障，以清除正在运行的指令和内存操作。为了串行化内存存取顺序，我们可以在ARMv7-A和ARMv8-A上面使用dsb指令，而在x86_64上，可以通过rdtscp和mfence指令保证串行化的内存存取顺序。为了串行化指令顺序，我们可以在x86_64上使用cpuid指令，在ARMv7-A和ARMv8-A上使用isb sy指令。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">定时</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在缓存命中和缓存未命中的情况下，存在从几百纳秒或甚至几十纳秒的性能差异，因此我们需要高精度的定时源才能能够区分缓存是否命中。虽然在兼容POSIX的操作系统上可以通过clock_gettime（）来获取定时信息，但是在各种ARMv7-A和ARMv8-A平台上，它们提高的定时信息却不够精确。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">许多现代处理器架构都提供了专用寄存器来计数处理器的周期数，从而提供高精度的定时源。虽然这些寄存器可通过各种rdtscp指令中的非特权rdtsc进行访问，但默认情况下，ARMv7-A和ARMv8-A上的性能监视单元（PMU）提供的PMCCNTR寄存器是无法访问的。此外，当最初引入这些寄存器时，没有确保它们在内核之间是同步的，并且直接利用处理器时钟使其计数进行递增。在这些情况下，进程迁移和动态频率调整会对定时造成一定程度的影响，甚至让它变得不再可靠。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">考虑到当今大多数处理器都具有多个内核，在循环中简单递增全局变量的线程可以提供一个基于软件的周期计数器。我们发现这种方法在各种平台上都能够可靠地工作，并且可以提供很高的精度度。请注意，JavaScript版本的AnC也采用了类似的技术来构建高精度的计时器。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">讨论</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">利用x86_64平台上的cpuid以及ARMv7-A和ARMv8-A上的扁平设备树（FDT），我们可以检测包括处理器属性（如TLB、缓存、处理器和供应商的名称）和微架构的等处理器拓扑信息。有了这些信息，我们就可以构建一个适当的驱逐组，以便在缺少页表和转译缓存的架构上成功地自动执行AnC攻击。因此，在带有页表或转译缓存的体系结构上，我们可以通过构建驱逐组并尝试渐进式执行AnC攻击来逆向这些缓存的大小。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">评测</span></strong></span></p><hr><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">我们使用Intel、ARM和AMD等公司从2008年到2016年期间发布的20个不同的CPU对我们的技术进行了全面的评估，并发现了每个页表级的页表缓存的具体大小（我们称2级页表为PL2），以及利用我们的技术逆向这个信息所需要的时间。同时，我们还提供了每种CPU的缓存和TLB的大小。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">我们的研究结果总结见表1。下面，我们将逐一介绍各个供应商产品在这些方面的特点和差异。</span></p><p style="text-align:center"><img src="http://p1.qhimg.com/t0199001842b2ddad50.png" title="t01a2b8b8d5f2b39f23.png" alt="http://p8.qhimg.com/t01a2b8b8d5f2b39f23.png"></p><p style="text-align: center; text-indent: 0em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">表1：22种不同微架构的规格和逆向结果</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">Intel</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在英特尔的处理器中，最后一级缓存是包含型的，这意味着最后一级缓存中可用的数据必须在较低级别的缓存中可用。由于这个特性，只要从最后一级缓存中逐出缓存行就足够了，因为这将导致它们将被从较低级别的缓存中逐出。我们发现，英特尔的页面结构缓存或切片转译缓存是在Intel Core和Xeon处理器上实现的，至少是Nehalem微架构。在Intel Core和Xeon处理器上，具有可供24-32个PL2表项和4-6个PL3表项的高速缓存，而在Silvermont处理器上，只有一个高速缓存，仅仅可以供12-16个PL2表项使用。在我们的多次测试期间，我们注意到，它们主要集中于几个彼此接近的数字。保守的攻击者可以总是选择更大的数字。在Intel Core和Xeon处理器以及Silvermont处理器上，我们发现cpuid报告的TLB的大小正好适用于完全刷新这些缓存，这很可能是因为用于缓存巨型页面的TLB也包含了缓存中间页面查询的逻辑。最后，我们发现，当Sandy Bridge和Ivy Bridge实现一个TLB来缓存1G页面时，cpuid指令不会报告这个TLB的存在，并且Nehalem和Westmere都实现了一个PL3页面结构缓存，但是没有提供这样的TLB实现。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">AMD</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">在AMD的处理器上，LLC是独占型的，这意味着数据最多可以放入一个高速缓存中，以便可以一次存储更多的数据。为了能够正确驱逐缓存行，我们必须分配一个驱逐组，其大小等于高速缓存大小的总和。我们经测试发现，AMD K10微体系结构实现了AMD的页面查询缓存具有24个表项。此外，我们的测试表明，AMD的页面查询缓存没有被Bulldozer微体系结构的设计和该微体系结构的后代所采用。因此，AMD的Bulldozer架构似乎没有提供任何页表或转译缓存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">最后，AMD的Bobcat架构似乎实现了一个带有8到12个表项的页面目录缓存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">ARMv7-A</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">与Intel和AMD的处理器不同，根据片上系统的供应商的不同，有些ARM处理器上的L2缓存可以配置为包含型、独占型或非包含型。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">然而，对于大多数ARMv7-A处理器来说，这些缓存都是配置为非包含型的。在ARMv7-A上，有两个页面级别可用，其中的页表分别提供256和4096个表项，分别可以映射4K和1M空间。对于支持大容量物理内存地址扩展（LPAE）的处理器，则使用三个页面级别，其中每个页表分别提供了512、512和4个表项，可以映射4K、1M和1G空间。即使最后一级页表仅由适合单个缓存行的四个表项组成，但是AnC攻击仍然可以应用于其他两个页面级别，以确定页表和转译缓存的存在性。此外，其低功耗版本（例如ARM Cortex A7）则实现了统一的页表缓存，而面向高性能的版本（例如ARM Cortex A15和A17）则实现了统一的转译缓存。但是，较旧的设计，如ARM Cortex A8和A9，却根本没有任何MMU缓存。同时，我们发现带有64个表项的页表缓存和带有16个表项的转译缓存分别可用于ARM Cortex A7和ARM Cortex A15。此外，我们的程序可以可靠地确定出所有支持和不支持LPAE的ARMv7-A的这些高速缓存的大小，即使在启用所有核心的ARM big.LITTLE处理器上，也可以透明地在不同类型的核心之间来回切换。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; color: rgb(0, 112, 192);"><strong>ARMv8-A</strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">ARMv8-A处理器也实现了类似于Intel和AMD的包含型LLC。此外，ARMv8-A使用与x86_64类似的模型，提供了四个页面级别，每级512个表项。然而，在Linux系统上，仅使用了三个页面级别来提高页表查找的性能。与ARMv7-A类似，ARMv8-A在其低功耗版本（例如ARM Cortex A53）上实现了4路关联64项统一页表缓存，并在注重性能的版本，例如ARM Cortex A57， A72和A73中实现了一个统一的转译缓存。此外，我们还发现ARM Cortex A53实现了一个具有64个表项的页表缓存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">讨论</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">如代码清单2所示，我们可以通过分配与缓存项一样多的页面，然后“触动”每个页面级别中的每个页面来刷新TLB和页面结构。通过触动这些页面，MMU就会被迫执行虚拟地址转换以替换缓存中的现有的表项。此外，通过使用页面大小作为每个页面级别的步幅，我们可以利用巨型页面来刷新页面结构缓存或TLB。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"></span></p><pre class="brush:plain;toolbar:false">1&nbsp;/<em>&nbsp;Flush&nbsp;the&nbsp;TLBs&nbsp;and&nbsp;page&nbsp;structure&nbsp;caches.&nbsp;</em>/<br>2&nbsp;for&nbsp;(j&nbsp;=&nbsp;0,&nbsp;level&nbsp;=&nbsp;fmt-&gt;levels;&nbsp;j&nbsp;&lt;=&nbsp;page_level;&nbsp;++level,&nbsp;++j)<br>3&nbsp;{<br>4&nbsp;p&nbsp;=&nbsp;cache-&gt;data&nbsp;+&nbsp;cache_line&nbsp;<em>&nbsp;cache-&gt;line_size;<br>5&nbsp;6<br>for&nbsp;(i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;level-&gt;ncache_entries;&nbsp;++i)&nbsp;{<br>7&nbsp;</em>p&nbsp;=&nbsp;0x5A;<br>8&nbsp;p&nbsp;+=&nbsp;level-&gt;page_size;<br>9&nbsp;}<br>10&nbsp;}</pre><p style="text-align: center; text-indent: 0em;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">代码清单2：刷新TLB和页面结构缓存。</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">相关工作</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;"></span></p><hr><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">针对页表的硬件攻击</span></strong></span><br></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">AnC攻击可以根据MMU将PTE缓存到LLC中的方式来发动EVICT + TIME攻击，从而利用JavaScript给用户空间ASLR去随机化。而使用预取指令的硬件攻击则依赖于缓存的TLB表项和部分转译来实现内核空间ASLR的去随机化。页表是Rowhammer攻击最有吸引力的目标。Drammer和Seaborn的硬件攻击会破坏PTE，使其指向页表页面。但是，如果不能正确刷新页表缓存的话，所有这些攻击都将失败。本文提供了一种用于在各种体系结构上刷新这些缓存的通用技术。</span></p><p style="text-indent: 2em; text-align: left;"><span style="color: rgb(0, 112, 192);"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">逆向硬件</span></strong></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">针对商品化硬件的逆向工程已经随着对硬件的攻击的增加而变得日益流行。Hund等人对英特尔处理器如何将物理内存地址映射到LLC进行了逆向工程。Maurice 等人则使用性能计数器来简化了该映射功能的逆向过程。DRAMA则使用DRAM总线的被动探测以及对DRAM行缓冲器的定时攻击，对内存控制器将数据放置在DRAM模块上的原理进行了逆向工程。在本文中，我们对现有处理器的MMU中常见的页表缓存的各种未公开的特性进行了相应的逆向工程。</span></p><p style="text-indent: 2em; text-align: left;"><br></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">结束语</span></strong></span></p><hr><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">当前，基于硬件的攻击（如缓存或Rowhammer攻击）开始变得越来越流行，因为针对软件的攻击已经变得越来越具有挑战性。对于跨处理器的鲁棒性攻击方法来说，掌握各种处理器内缓存的相关特性是至关重要的。由于这些缓存通常对软件来说是不可见的，因此通常很难找到相关的文档说明。在本文中，我们改进了针对MMU的现有EVICT + TIME攻击，使其能够逆向最新处理器上常见的页表缓存的各种特性。我们将该技术应用于20个不同的微架构，发现其中17个实现了这样的页表缓存。我们的开源实现提供了一个便利的接口，可以用于在这16个微体系结构上刷新这些缓存，并可以在未来的微架构上自动检测页表缓存。更多信息，请访问：&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;"><a href="https://www.vusec.net/projects/anc" _src="https://www.vusec.net/projects/anc" target="_blank" rel="external">https://www.vusec.net/projects/anc</a>&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;"><br></span></p><p style="text-indent: 2em; text-align: left;"><span style="font-size: 18px;"><strong><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">参考文献</span></strong></span></p><hr><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">[1] M. Abadi, M. Budiu, U. Erlingsson, and J. Ligatti.</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Control-flow Integrity. CCS’05.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[2] T. W. Barr, A. L. Cox, and S. Rixner. Translation&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">caching: skip, don’t walk (the page table). ISCA’10.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[3] A. Bhattacharjee. Large-reach memory management&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">unit caches. MICRO’13.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[4] E. Bosman, K. Razavi, H. Bos, and C. Giuffrida.</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Dedup Est Machina: Memory Deduplication as an&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Advanced Exploitation Vector. SP’16.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[5] X. Chen, A. Slowinska, D. Andriesse, H. Bos, and&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">C. Giuffrida. StackArmor: Comprehensive Protection&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">From Stack-based Memory Error Vulnerabilities for&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Binaries. NDSS.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[6] D. Cock, Q. Ge, T. Murray, and G. Heiser. The Last&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Mile: An Empirical Study of Timing Channels on&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">seL4. CCS’14.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[7] S. Crane, C. Liebchen, A. Homescu, L. Davi,&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">P. Larsen, A.-R. Sadeghi, S. Brunthaler, and&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">M. Franz. Readactor: Practical Code Randomization&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Resilient to Memory Disclosure. NDSS’15.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[8] T. H. Dang, P. Maniatis, and D. Wagner. The&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">performance cost of shadow stacks and stack canaries.&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">ASIA CCS’15.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[9] D. Evtyushkin, D. Ponomarev, and N. Abu-Ghazaleh.</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Jump Over ASLR: Attacking Branch Predictors to&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Bypass ASLR. MICRO’16.&nbsp;</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[10] C. Giuffrida, A. Kuijsten, and A. S. Tanenbaum.</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Enhanced Operating System Security Through&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Efficient and Fine-grained Address Space&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Randomization. SEC’12.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[11] B. Gras, K. Razavi, E. Bosman, H. Bos, and&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">C. Giuffrida. ASLR on the Line: Practical Cache&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Attacks on the MMU. NDSS’17.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[12] D. Gruss, C. Maurice, A. Fogh, M. Lipp, and&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">S. Mangard. Prefetch Side-Channel Attacks:&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Bypassing SMAP and Kernel ASLR. CCS’16.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[13] R. Hund, C. Willems, and T. Holz. Practical Timing&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Side Channel Attacks Against Kernel Space ASLR.&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">SP’13.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[14] AMD64 Architecture Programmer’s Manual, Volume&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">2: System Programming. Publication No.: 24593, May&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">2013.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[15] Intel 64 and IA-32 Architectures Optimization&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Reference Manual. Order Number: 248966-032,&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">January 2016.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[16] Y. Jang, S. Lee, and T. Kim. Breaking kernel address&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">space layout randomization with intel tsx. CCS’16.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[17] K. Koning, H. Bos, and C. Giuffrida. Secure and&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Efficient Multi-Variant Execution Using&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Hardware-Assisted Process Virtualization. DSN’16.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[18] V. Kuznetsov, L. Szekeres, M. Payer, G. Candea,&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">R. Sekar, and D. Song. Code-pointer integrity.&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">OSDI’14.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[19] M. Lipp, D. Gruss, R. Spreitzer, C. Maurice, and&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">S. Mangard. Armageddon: Cache attacks on mobile&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">devices. SEC’16.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[20] K. Lu, C. Song, B. Lee, S. P. Chung, T. Kim, and&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">W. Lee. ASLR-Guard: Stopping Address Space&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Leakage for Code Reuse Attacks. CCS’15.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[21] C. Maurice, N. L. Scouarnec, C. Neumann, O. Heen,&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">and A. Francillon. Reverse Engineering Intel&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Last-Level Cache Complex Addressing Using&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Performance Counters. RAID’15.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[22] Y. Oren, V. P. Kemerlis, S. Sethumadhavan, and A. D.&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Keromytis. The Spy in the Sandbox: Practical Cache&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Attacks in JavaScript and their Implications. CCS’15.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[23] P. Pessl, D. Gruss, C. Maurice, M. Schwarz, and&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">S. Mangard. DRAMA: Exploiting DRAM Addressing&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">for Cross-CPU Attacks. SEC’16.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[24] K. Razavi, B. Gras, E. Bosman, B. Preneel,</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">C. Giuffrida, and H. Bos. Flip Feng Shui: Hammering&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">a Needle in the Software Stack. SEC’16.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[25] M. Seaborn. Exploiting the DRAM Rowhammer Bug&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">to Gain Kernel Privileges. In Black Hat USA,&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">BH-US’15.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[26] V. van der Veen, Y. Fratantonio, M. Lindorfer,&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">D. Gruss, C. Maurice, G. Vigna, H. Bos, K. Razavi,&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">and C. Giuffrida. Drammer: Deterministic&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Rowhammer Attacks on Mobile Platforms. CCS’16.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[27] Y. Yarom and K. Falkner. FLUSH+RELOAD: A High&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Resolution, Low Noise, L3 Cache Side-channel Attack.&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">SEC’14.</span></p><p style="text-indent: 2em; text-align: left;"><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;;">[28] X. Zhang, Y. Xiao, and Y. Zhang. Return-Oriented&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Flush-Reload Side Channels on ARM and Their&nbsp;</span><span style="font-family: 微软雅黑, &#39;Microsoft YaHei&#39;; text-indent: 2em;">Implications for Android Devices. CCS’16.&nbsp;</span></p><p></p><br><hr><br><p>本文由 安全客 翻译，转载请注明“转自安全客”，并附上链接。<br><a class="text-more" href="http://www.cs.vu.nl/~herbertb/download/papers/revanc_ir-cs-77.pdf" target="_blank">原文链接：http://www.cs.vu.nl/~herbertb/download/papers/revanc_ir-cs-77.pdf</a></p><br>                      </div><br><br></div></div></div></head></html>







      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/系统安全/">系统安全<span class="article-category-count">4</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/">System</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-memorysafety-defense"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170605/memorysafety-defense/">内存持久战之防御措施</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170605/memorysafety-defense/" class="article-date">
	  <time datetime="2017-06-05T02:11:39.000Z" itemprop="datePublished">六月 5, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本系列主要介绍内存的安全性问题，以及相应的攻击模型及防御措施，对整个系统安全问题的概览有很大的帮助。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170513/memorysafety-defense/" target="_blank" rel="external">内存持久战之防御措施</a>》与作者信息：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>
<hr>
<blockquote>
<ul>
<li>0X01 广泛部署的防御机制</li>
<li>0X02 防御机制Step-by-step </li>
</ul>
</blockquote>
<p>继前两篇文章 <a href="http://www.csyssec.org/20170513/memorysafety/" target="_blank" rel="external">内存持久战-内存安全性</a>, <a href="http://www.csyssec.org/20170513/memorysafety-attack/" target="_blank" rel="external">内存持久战-攻击模型</a>, 再加上防御措施，才能算是完整的内存战争。本文首先介绍目前广泛部署的防御机制，然后根据 <a href="http://www.csyssec.org/20170513/memorysafety-attack/" target="_blank" rel="external">内存持久战-攻击模型</a> 每一步实施的攻击破坏介绍相对应的防御细节。</p>
<h3 id="0X01-广泛部署的防御机制"><a href="#0X01-广泛部署的防御机制" class="headerlink" title="0X01 广泛部署的防御机制"></a>0X01 广泛部署的防御机制</h3><p>目前广泛部署的防御机制有栈粉碎性保护（Stack smashing protection)，DEP/W⊕X以及ASLR(Address Space Layout Randomization)。针对Windows平台，也提出了一些特殊的机制，比如 SafeSEH 与 SEHOP 用来保护堆的元数据和异常处理器。</p>
<p>栈粉碎性保护,SafeSEH以及SEHOP的基本思想是在返回地址与缓冲区(比如函数入口）之间放置随机数作为哨兵（称为cookie或canary),在函数返回前先检测哨兵的值是否被篡改，以达到检测缓冲区溢出攻击的目的。这些机制都属于代码指针保护方式（code pointer integrity),主要检测一些特殊代码指针，如栈上的返回地址、异常处理器指针的完整性，然而对于直接修改（比如索引错误）却无能为力。有关stack smashing 可参考这篇文章 <a href="http://www.drdobbs.com/security/anatomy-of-a-stack-smashing-attack-and-h/240001832?pgno=1" target="_blank" rel="external">Anatomy of a Stack Smashing Attack and How GCC Prevents It
</a></p>
<p>W⊕X（write XOR executable)属于DEP（data execution prevention)的子集，是不可执行数据（Non-executable data）与代码完整性(code integrity)的结合。所有现代CPU都支持设置不可执行页面权限，结合不可写代码权限，就可以实施W⊕X机制，很简单也很实际。然而无法防御ROP（return oriented programming),ROP指的是在将现有代码中的可复用代码（可以是现有的函数）以及一些指令序列（gadgets)连接起来实施恶意操作。有关ROP可参考这篇文章，<a href="https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf" target="_blank" rel="external">Return-oriented Programming:<br>Exploitation without Code Injection</a>.</p>
<p>ASLR在下文会详细描述。</p>
<h3 id="0X02-防御机制Step-by-step"><a href="#0X02-防御机制Step-by-step" class="headerlink" title="0X02 防御机制Step-by-step"></a>0X02 防御机制Step-by-step</h3><p>从目前提出的所有防御机制来看，可将其划分为两大类：概率性以及确定性防御。概率性机制用来随机化一些对象，如ISR(Instruction Set Randomization), ASLR(Address Space Randomizatioin)以及DSR(Data Space Randomization),可选手段相对较少。 确定性防御机制实施reference monitor, 有关reference monitor的定义可参考，<a href="https://en.wikipedia.org/wiki/Reference_monitor" target="_blank" rel="external">wikipedia page on reference monior</a>, 主要就是在参考验证机制上定义了一些设计要求。 其主要利用静态与动态注入技术，静态注入可在编译阶段实施，动态注入需要在运行时加入代码，损耗相对较大。有关注入技术，可参考前面的文章 <a href="http://www.chongh.wiki/blog/2015/12/18/pin-for-dynamic-binary-instrumentation/" target="_blank" rel="external">PIN for Dynamic Binary Instrumentation</a>。</p>
<p>下面将针对攻击模型中实施的每个步骤介绍相对应的防御机制，每种防御机制对应每一步的攻击过程。<br>可以先去回顾一下 <a href="http://www.csyssec.org/20170513/memorysafety-attack/" target="_blank" rel="external">内存持久战之攻击模型</a> 的完整实施过程。注意，以下介绍的防御机制并没有时序关系,以横向关系依次描述。</p>
<p><strong><em>Step 1&amp;2: Memory safety.</em></strong> 考虑完整的内存安全性，空间错误和时域错误都需要阻止。类型安全（Type-safe)的语言通过检查数组边界并使用自动垃圾回收来实施空间与时域安全性。对于非类型安全语言，可嵌入reference monitor针对非安全代码实施类似的策略，对象可以是源码、中间语言、二进制。</p>
<p>针对空间安全，可跟踪指针边界，将指针结构体的表示方法扩展，加入额外信息。但是这种需要源码标注(annotation)，对于庞大的代码基是不实用的，甚至会改变内存结构带来二进制兼容性问题。可参考 <a href="https://www.cs.virginia.edu/~weimer/p/p477-necula.pdf" target="_blank" rel="external">CCured</a> 项目。为解决兼容性问题，越来越多研究者开始追踪对象边界，不但要知道对象分配的内存区域边界，并利用指针运算而不是引用指针来保护指针边界。</p>
<p>然而，检测边界并不能解决use-after-free, double-free(use-after-free的特列)问题. 此时，实施时域安全可作为补充。1）特殊的分配器：释放的内存只能被同类型对象重用并对齐。此策略可阻止user-after-free攻击，但对dangling pointers无效；2）基于对象的方法：利用影子内存标记每一块释放的内存位置，如果访问最近被释放的空间就能被检测到。著名的Valgrind内存检测就是利用此方法来检测user-after-free错误的。有关Valgrind的内存检测技术将会在后续的文章<a href="http://www.chongh.wiki/blog/2016/02/20/valgrind-memory/" target="_blank" rel="external">Valgrind内存检测</a> 详细介绍。如果标记的内存区域重新被新的指针指向，对其的非法访问就检测不到了；3）基于指针的方法：同时维护指针的边界信息与内存分配信息实施全面的内存安全。</p>
<p><strong><em>Step 3: 代码完整性(code integrity, 对应修改代码),代码指针完整性(code pointer integrity，对应修改代码指针)以及数据完整性（data integrity，对应修改数据变量).</em></strong></p>
<p>代码完整性保证程序中的代码不可写性，可以将含有代码的所有内存页面设置为read-only,所有现代CPU都支持此操作。但是，代码完整性并不支持自我修改(self-modifying)的代码以及即时(Just-In-Time, JIT)编译。代码指针完整性保护指针不被修改，对于不变指针，如全局偏移表、虚拟函数表（vtable),可将其内存页设置read-only。但大部分指针，如定义的函数指针或保存的返回地址必须是可写的。另外，就算内存中所有的函数指针都能实施代码指针完整性，并不能防御use-after-free攻击，例如，通过悬挂指针读取错误的vtable<br>来改变程序的控制流并不会涉及内存中的覆盖代码指针操作。</p>
<p>数据完整性的实施近似空间安全保护，但并没有实施时域安全保护。数据完整性包括基于对象的完整性保护以及基于points-to集合的完整性保护。基于对象的完整性保护利用静态指针分析来鉴别出不安全的指针集(比如可能会越界的指针)以及指针的points-to集合，然后在代码中插入用影子内存跟踪对象的创建与释放的代码，当对不安全的指针进行写操作或引用操作时会检测指针的位置是否标记在影子内存中。基于points-to集合的完整性保护在基于对象的完整性保护上加了一个限制，每个解引用只能写它自己指向的集合对象，是对其保护的加强。</p>
<p><strong><em>Step 4: ISR(对应指针转向攻击者特定代码),ASLR（对应指向shellcode或者gadget的地址),DSR(对应解析输出的数据变量).</em></strong></p>
<p>ISR随机化系统指令来保护代码破坏攻击，随着硬件的更新与发展,ISR技术已经废弃；ASLR随机化代码和数据的存储位置来防御控制流劫持攻击，如果payload(指恶意代码中执行恶意操作的部分）在虚拟内存空间的地址不是固定的，攻击者就无法转移控制流。ASLR也是目前用来保护劫持攻击运用最广泛的技术，然后ASLR的随机化是可预测的，尤其是32位机器，heap-spraying以及JIT-spraying技术可以多次填充payload使随机化失效；</p>
<p>DSR将存储在内存中的数据形式，而不是存储位置，进行随机化。它为每个变量,包括指针，生成不同的key并进行加密操作，数据的每次读取/存储操作都多了个加解密过程。该方法在代码注入之前都要对指针进行静态分析，overhead较大，但保护比较健壮，能有效防止信息泄露，还能防御控制流劫持以及数据攻击。</p>
<p><strong><em>Step 5: 控制流完整性（control-flow integrity,对应利用间接跳转指令 call/jump 引用指针，利用返回指令引用指针)以及数据流完整性(data-flow integrity，对应引用破坏后的数据变量).</em></strong></p>
<p>控制流完整性包括动态返回完整性以及静态控制流图完整性。前文提到的栈粉碎性保护机制不能保护间接调转（call and jump)，不能防御直接修改破坏以及信息泄露，但开销小，兼容性好，所以运用比较广泛。影子栈技术能够解决栈粉碎性保护的信息泄露以及直接修改破坏问题，它把返回地址存入隔离的影子栈中，当函数返回时，对原有栈和影子栈两处保存的值做比较，已保证不被篡改。为了防御控制流劫持，不但要保护返回值，还要保护间接跳转，静态控制流图完整性的方式标记所有的call,jump，并将其标记信息存储在特殊的影子内存中或直接放进代码里; 数据流完整性在数据被使用前，通过检查read指令检测数据是否被破坏。它使用静态points-to分析构建一个全局的可达定义集合（reaching definition sets)，保证数据变量最近一次被写是通过程序中的写指令写入的，而不是攻击者可控制的写入。有关reaching definition sets的定义可参考 <a href="https://en.wikipedia.org/wiki/Reaching_definition" target="_blank" rel="external">wikipedia page on Reaching definition</a>.</p>
<p><strong><em>Step 6: 不可写数据策略(Non-executable data,对应执行注入的shellcode).</em></strong><br>Non-executable data 保护栈、堆之类的内存页面不可执行，只需要设置内存页面的执行位即可。实际上Non-executable data策略与代码完整性结合就是W⊕X机制。</p>
<p>每个攻击过程对应的防御机制都已讲完。横向来看，所有攻击模型的每个步骤都有多个防御方法；纵向来看，每种攻击在不同的实施阶段也有不同的防御方法，如控制流劫持攻击，从Step1-6分别有，内存安全性机制（step 1-2),代码指针完整性(step 3),ASLR(step 4), 控制流完整性（step 5）以及不可写数据策略（step 6)不同的防御机制。要阻止某种攻击或多种攻击，需要结合多种防御机制，每种机制也都有其优势与弱点。评判防御机制的性质，可从以下方面去衡量，保护强度、误报率、漏报率、性能开销、内存开销、兼容性，是否模块化等。</p>
<p>至此，内存持久战系列文章就到这里了，水平有限，很多不到位的地方欢迎补充修正。 回顾一下，最后用下面这张图总结，就清晰明了了。[图来源于S&amp;P’13]</p>
<figure><br>    <a href="http://7xppf1.com1.z0.glb.clouddn.com/memorywar.png" target="_blank" rel="external"><img src="http://7xppf1.com1.z0.glb.clouddn.com/memorywar.png" width="350"></a><br>    <figcaption></figcaption><br></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.drdobbs.com/security/anatomy-of-a-stack-smashing-attack-and-h/240001832?pgno=1" target="_blank" rel="external">Anatomy of a Stack Smashing Attack and How GCC Prevents It
</a></p>
<p><a href="https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf" target="_blank" rel="external">Return-oriented Programming: Exploitation without Code Injection</a>.</p>
<p><a href="https://en.wikipedia.org/wiki/Reference_monitor" target="_blank" rel="external">wikipedia page on reference monior</a></p>
<p><a href="https://www.cs.virginia.edu/~weimer/p/p477-necula.pdf" target="_blank" rel="external">CCured</a></p>
<p><a href="https://nebelwelt.net/publications/files/13Oakland.pdf" target="_blank" rel="external">S&amp;P’13 Eternal War in Memory </a></p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170513/memorysafety-defense/" target="_blank" rel="external">内存持久战之防御措施</a>》与作者信息：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/内存安全/">内存安全<span class="article-category-count">3</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Memory/">Memory</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/">System</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-ravel"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170531/ravel/">会找漏洞的时光机-Pinpointing Vulnerabilities</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170531/ravel/" class="article-date">
	  <time datetime="2017-05-31T13:33:58.000Z" itemprop="datePublished">五月 31, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>来源： <a href="https://www.inforsec.org/wp/?p=1993" target="_blank" rel="external">InforSec</a><br>作者：Yue CHEN, Florida State University, 博士在读<br>转载请注明来源与原作者信息。</p>
<hr>
<p>当我们的系统遭受攻击时，即便我们已经检测到攻击，如何知道被利用的漏洞在哪里呢？</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/ravel1.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/ravel1.png" width="450"></a><br>    <figcaption></figcaption><br></figure>

<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/ravel2.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/ravel2.png" width="450"></a><br>    <figcaption></figcaption><br></figure>



<p>先让我们来看一个简单的例子(见上图)：假如用户输入的argv[1]是个巨长无比的字符串，由于strcpy不限制拷贝的字符数，buf会被溢出，那么在第6行函数return时候，很可能会控制流异常。假如使用攻击检测，很可能检测到第6行的return 0，但是真正的漏洞在第4行。症状(Symptom)和根本原因(Root Cause)在不同的地方。对于复杂的大程序，想要定位到Root Cause还是非常困难的。</p>
<p>目前基于memory instrumentation的漏洞检测，由于要instrument所有的内存访问，其开销特别大，因此不适合用于程序运行时使用。所以这篇论文提出个系统叫Ravel (Root-cause Analysis of Vulnerabilities from Exploitation Log), 它包含一个online模块和一个offline模块. <strong>Online的模块把运行的不确定事件都记录(Record)下来，并且提供攻击检测功能；Offline的模块可以重放(Replay)程序的运行，并且可以instrument memory并且定位漏洞。</strong></p>
<p>这样做有若干优势:</p>
<ul>
<li>可以把真实世界里的攻击，在实验室环境进行重放(Replay)并分析。</li>
<li>运行时候性能开销很小，开销大的漏洞定位阶段被放在了Offline的实验室里。</li>
<li>可扩展。可以自由添加新的攻击检测和漏洞定位方法。</li>
<li>对于攻击检测，Ravel用了现有的方法，比如程序崩溃，异常系统调用，CFI等。 对于Record &amp; Replay,  Ravel主要记录了不确定事件，比如系统调用(syscall)结果，内核到用户空间的数据拷贝，同步原语等等 (具体参看幻灯片或者论文)。</li>
</ul>
<p>对于Replay阶段的Memory Instrumentation，Ravel集成了二进制翻译引擎(Binary Translation Engine，简称BT)。其中很重要的功能 (也是一项挑战) ， 是可以把BT发出的syscall和目标程序本身的syscall区分开来，以确保replay和record的一致性。</p>
<p>对于漏洞定位，Ravel设计了一系列功能。首先是<strong>数据流分析(Data-flow Analysis)</strong>。我们把写入一块内存叫做define, 简称def；把从这块内存里读出数据叫use。假如指令A写入这块内存，指令B接着读了出来，他们就构成了一组def-use关系。一堆这种关系可以构成一张图，叫DFG (Data-flow Graph).</p>
<p>我们可以预先把这些关系找出来，做一张DFG。假如运行时候有之前没见过的def-use关系出现，可以视为发现 违规(violation)，意味着很可能有漏洞。那么如何知道出问题的地方是在def，还是在use呢？</p>
<p>Ravel用了一些启发式搜索(heuristics)。这里用buffer overflow举个例子。</p>
<p>比如我们本来有三个use (也就是read from memory):</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/ravel3.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/ravel3.png" width="450"></a><br>    <figcaption></figcaption><br></figure>

<p>然后有一个大的def (write to memory) 把这仨use都覆盖了:</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/ravel4.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/ravel4.png" width="450"></a><br>    <figcaption></figcaption><br></figure>

<p>假如发现这些def-use关系是violation，那么很有可能，漏洞在def的指令及其周围。</p>
<p>并且很有可能是buffer overflow, memory overwriting之类的。Violation关系如下图:</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/ravel5.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/ravel5.png" width="450"></a><br>    <figcaption></figcaption><br></figure>


<p>别的漏洞，比如information leakage，也可以用类似的方法来定位。</p>
<p>对于<strong>整数错误(Integer Errors)</strong>, Ravel关注的是一些用整数计数(比如放在RCX/ECX寄存器里)的指令，比如MOVS, STOS 等； 和有整数参数的函数，比如memcpy, recvfrom 等。从这些参数开始，Ravel进行backwards search来定位漏洞。</p>
<p>可以定位的整数错误漏洞包括:</p>
<p>Assignment Truncation (比如0x12345678 → 0x5678)</p>
<ul>
<li>检测方法：从longer type赋值到shorter type</li>
</ul>
<p>Integer Overflow/underflow (比如0xFFFFFFFF + 1)</p>
<ul>
<li><p>检测方法：检测RFLAGS/EFLAGS寄存器<br>Signedness Error (比如 unsigned_int_var = signed_int_var)</p>
</li>
<li><p>检测方法：收集Hint。比如一些指令或者函数会指定特定的signed或者unsigned参数。详情参见slides或者<br>那么有些整数错误是程序员/编译器故意设置的，如何区分呢？</p>
</li>
<li><p>由于这些错误已经和reported的漏洞相关，所以非常大可能是漏洞，而不是正常的整数操作。<br>假如Race Condition存在，replay的execution trace会和record下来的不一样，所以可以用该方法来检测。</p>
</li>
</ul>
<p>一旦检测到，Ravel继续用happens-before relation来进一步尝试定位漏洞。</p>
<p>Ravel还能检测以下一系列漏洞，具体参见paper，此处不再赘述:</p>
<p>Use-after-free and Double-free</p>
<p>Buffer Overflow</p>
<p>Integer Errors</p>
<p>Information Leakage</p>
<p>Format String Vulnerabilities</p>
<p>Ravel的Record &amp; Replay功能基于FreeBSD 10.2实现，漏洞定位基于Valgrind实现。</p>
<p>下图用Nginx的CVE-2013-2028 漏洞举了一个Ravel如何从攻击定位到漏洞的例子, 具体描述参见论文。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/ravel6.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/ravel6.png" width="450"></a><br>    <figcaption></figcaption><br></figure>


<p>更多的Evaluation实验, 比如Heartbleed，以及别的漏洞类型比如</p>
<p>Null Pointer Dereference,</p>
<p>Heap Overflow,</p>
<p>Out-of-bounds Read,</p>
<p>Untrusted Pointer Dereference,</p>
<p>也可以在论文里找到。</p>
<p>最后是Online Performance Overhead的Evaluation, 实验是在流行的web服务器和SPEC CPU 2006上做的， 可以看出性能开销非常小。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/ravel7.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/ravel7.png" width="450"></a><br>    <figcaption></figcaption><br></figure>


<p>论文链接: <a href="http://ww2.cs.fsu.edu/~ychen/paper/ravel.pdf" target="_blank" rel="external">http://ww2.cs.fsu.edu/~ychen/paper/ravel.pdf</a></p>
<p>Slides链接(pptx): <a href="http://ww2.cs.fsu.edu/~ychen/paper/ravel.pptx" target="_blank" rel="external">http://ww2.cs.fsu.edu/~ychen/paper/ravel.pptx</a></p>
<p>Slides链接(pdf): <a href="http://ww2.cs.fsu.edu/~ychen/paper/ravel_slides.pdf" target="_blank" rel="external">http://ww2.cs.fsu.edu/~ychen/paper/ravel_slides.pdf</a></p>
<p>作者简介:</p>
<p>Yue CHEN, Florida State University, 博士在读。期间曽有幸在 百度美研X-Lab, 华为美研大数据组 等地实习。</p>
<p>研究兴趣为系统安全，移动安全。个人主页: <a href="http://YueChen.me" target="_blank" rel="external">http://YueChen.me</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/系统安全/">系统安全<span class="article-category-count">4</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Exploit/">Exploit</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div class="widget-wrap" style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 75%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 42px;" placeholder=" 搜索…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="搜索">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">集思广益</h3>
      <p>我们推崇的是黑客与分享精神，如果您觉得本站对您有帮助，不妨自己也参与进来共同建设，期待您能推荐好文章或投稿至本站，
让更多人受益。本站热烈欢迎志同道合者与志愿者参与本站的共同维护和建设，您可通过微博[@Diting0x](http://weibo.com/diting0x)联系我</p>
       <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="null" title="Words"><i class="fa fa-words" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a> </li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>


        	</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>最新推荐</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170808/rowhammer/">神乎其神的Rowhammer：用比特位翻转实现云虚拟机夺权</a></h6>
          <!--  <span>八月 8, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170808/googleprojectzero/">谷歌Project Zero：通过“Row hammer”漏洞获取系统权限</a></h6>
          <!--  <span>八月 8, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170807/bypassaslr-analysis/">ASLR保护机制被突破的攻击技术分析</a></h6>
          <!--  <span>八月 7, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170605/memorysafety-defense/">内存持久战之防御措施</a></h6>
          <!--  <span>六月 5, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170531/ravel/">会找漏洞的时光机-Pinpointing Vulnerabilities</a></h6>
          <!--  <span>五月 31, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170513/memorysafety-attack/">内存支持战之攻击模型</a></h6>
          <!--  <span>五月 13, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170513/memorysafety/">内存持久战之内存安全性</a></h6>
          <!--  <span>五月 13, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170508/intro-aslr/">系统安全浅薄知识系列(一)-ASLR</a></h6>
          <!--  <span>五月 8, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170505/cfi-mathias/">控制流完整性-Mathias Payer</a></h6>
          <!--  <span>五月 5, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170505/vmi-xenproject/">虚拟机自省技术-一个有新商业应用的安全性创造</a></h6>
          <!--  <span>五月 5, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/cf-exception/">控制流分支指令上的控制流处理器异常(单步执行)</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/cfi-development/">控制流完整性的发展历程</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/cfi-ccs05/">控制流完整性-CCS05年论文</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/rop-intel/">因特尔发布新的技术规范去防御 ROP 攻击</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/ropjop-research/">ROP/JOP攻击与防御最新研究进展</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/nmi-virtual/">虚拟化技术的NMI窗口退出</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类导航</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hypervisor安全/">Hypervisor安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/主流会议/">主流会议</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/二进制分析/">二进制分析</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存安全/">内存安全</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内核安全/">内核安全</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内核完整性/">内核完整性</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/博士之路/">博士之路</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/名人课堂/">名人课堂</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学术专家/">学术专家</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全圈子/">安全圈子</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/恶意代码/">恶意代码</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/漏洞利用/">漏洞利用</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/硬件特性/">硬件特性</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/硬件虚拟化/">硬件虚拟化</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统内核/">系统内核</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统安全/">系统安全</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统安全科普/">系统安全科普</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟化原理/">虚拟化原理</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟化基础/">虚拟化基础</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟化综合/">虚拟化综合</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机快照/">虚拟机快照</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机监控/">虚拟机监控</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机记录与重放/">虚拟机记录与重放</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机迁移/">虚拟机迁移</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签导航</h3>
    <div class="widget tagcloud">
      <a href="/tags/ASLR/" style="font-size: 12.31px;">ASLR</a> <a href="/tags/ASPLOS/" style="font-size: 10px;">ASPLOS</a> <a href="/tags/Attack/" style="font-size: 12.31px;">Attack</a> <a href="/tags/Binary/" style="font-size: 10.77px;">Binary</a> <a href="/tags/CFI/" style="font-size: 12.31px;">CFI</a> <a href="/tags/Cloud/" style="font-size: 10px;">Cloud</a> <a href="/tags/Compiler/" style="font-size: 10px;">Compiler</a> <a href="/tags/Conference/" style="font-size: 12.31px;">Conference</a> <a href="/tags/Conferences/" style="font-size: 10px;">Conferences</a> <a href="/tags/Course/" style="font-size: 13.08px;">Course</a> <a href="/tags/Exception/" style="font-size: 10px;">Exception</a> <a href="/tags/Exploit/" style="font-size: 16.92px;">Exploit</a> <a href="/tags/Forensics/" style="font-size: 10px;">Forensics</a> <a href="/tags/HAV/" style="font-size: 12.31px;">HAV</a> <a href="/tags/Hardware/" style="font-size: 13.85px;">Hardware</a> <a href="/tags/Heap/" style="font-size: 10.77px;">Heap</a> <a href="/tags/Hooking/" style="font-size: 10px;">Hooking</a> <a href="/tags/Instrumentation/" style="font-size: 10.77px;">Instrumentation</a> <a href="/tags/Introspection/" style="font-size: 13.85px;">Introspection</a> <a href="/tags/JOP/" style="font-size: 10px;">JOP</a> <a href="/tags/KVM/" style="font-size: 16.15px;">KVM</a> <a href="/tags/Kernel/" style="font-size: 17.69px;">Kernel</a> <a href="/tags/Libvmi/" style="font-size: 13.08px;">Libvmi</a> <a href="/tags/Linux/" style="font-size: 13.08px;">Linux</a> <a href="/tags/Malware/" style="font-size: 15.38px;">Malware</a> <a href="/tags/Memory/" style="font-size: 13.08px;">Memory</a> <a href="/tags/Migration/" style="font-size: 11.54px;">Migration</a> <a href="/tags/Monitoring/" style="font-size: 13.08px;">Monitoring</a> <a href="/tags/NX/" style="font-size: 10px;">NX</a> <a href="/tags/Overflow/" style="font-size: 10.77px;">Overflow</a> <a href="/tags/PIN/" style="font-size: 10px;">PIN</a> <a href="/tags/Paper/" style="font-size: 11.54px;">Paper</a> <a href="/tags/Ph-D/" style="font-size: 10.77px;">Ph.D</a> <a href="/tags/Ppaerwriting/" style="font-size: 10px;">Ppaerwriting</a> <a href="/tags/Professor/" style="font-size: 12.31px;">Professor</a> <a href="/tags/QEMU/" style="font-size: 14.62px;">QEMU</a> <a href="/tags/RE/" style="font-size: 10px;">RE</a> <a href="/tags/ROP/" style="font-size: 10.77px;">ROP</a> <a href="/tags/Rootkit/" style="font-size: 11.54px;">Rootkit</a> <a href="/tags/Rowhammer/" style="font-size: 10.77px;">Rowhammer</a> <a href="/tags/SYSCALL/" style="font-size: 10px;">SYSCALL</a> <a href="/tags/Sandbox/" style="font-size: 10.77px;">Sandbox</a> <a href="/tags/Security/" style="font-size: 20px;">Security</a> <a href="/tags/Shellcode/" style="font-size: 10px;">Shellcode</a> <a href="/tags/Snapshot/" style="font-size: 10px;">Snapshot</a> <a href="/tags/Stack/" style="font-size: 10.77px;">Stack</a> <a href="/tags/Syscall/" style="font-size: 10px;">Syscall</a> <a href="/tags/System/" style="font-size: 18.46px;">System</a> <a href="/tags/Systemcall/" style="font-size: 11.54px;">Systemcall</a> <a href="/tags/TSX/" style="font-size: 10px;">TSX</a> <a href="/tags/TrustZone/" style="font-size: 10px;">TrustZone</a> <a href="/tags/VT-x/" style="font-size: 10px;">VT-x</a> <a href="/tags/Valgrind/" style="font-size: 10px;">Valgrind</a> <a href="/tags/Virtualization/" style="font-size: 19.23px;">Virtualization</a> <a href="/tags/Volatility/" style="font-size: 10px;">Volatility</a> <a href="/tags/XEN/" style="font-size: 13.08px;">XEN</a>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      版权所有&copy; 2017 Index of Computer System and Security 保留所有权利.
      </div>
      <div class="site-credit">
       <!--  自豪地使用 <a href="https://github.com/iTimeTraveler/hexo-theme-hiero" target="_blank">hiero</a> --> 
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
</script>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/syssec" class="mobile-nav-link">Syssec</a>
  
    <a href="/architecture" class="mobile-nav-link">Architecture</a>
  
    <a href="/virtualization" class="mobile-nav-link">Virtualization</a>
  
    <a href="/malware" class="mobile-nav-link">Malware</a>
  
    <a href="/conferences" class="mobile-nav-link">Conferences</a>
  
    <a href="/courses" class="mobile-nav-link">Courses</a>
  
    <a href="/academy" class="mobile-nav-link">Academy</a>
  
    <a href="/news" class="mobile-nav-link">News</a>
  
    <a href="/knowledge" class="mobile-nav-link">Knowledge</a>
  
    <a href="/share" class="mobile-nav-link">Share</a>
  
    <a href="/contribution" class="mobile-nav-link">Contribution</a>
  
</nav> -->
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>





  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
  

  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1261078922&web_id=1261078922" language="JavaScript"></script>
  </div>


</body>
</html>
