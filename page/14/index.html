<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Index of Computer System and Security</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="computer system, computer security" />
  
  
  
  
  <meta name="description" content="Diting0x@">
<meta property="og:type" content="website">
<meta property="og:title" content="Index of Computer System and Security">
<meta property="og:url" content="http://yoursite.com/page/14/index.html">
<meta property="og:site_name" content="Index of Computer System and Security">
<meta property="og:description" content="Diting0x@">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Index of Computer System and Security">
<meta name="twitter:description" content="Diting0x@">
  
    <link rel="alternate" href="/atom.xml" title="Index of Computer System and Security" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/hiero.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>

<body>
  <header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            <a href="/" title="Index of Computer System and Security" rel="home">
              Index of Computer System and Security</a>
          </h1>
          <div class="site-description">Diting0x@</div>

            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>
            <div class="clearfix sf-menu">

              <ul id="main-nav" class="nmenu sf-js-enabled">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/syssec">系统安全</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/architecture">系统结构</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/virtualization">虚拟化</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/malware">恶意代码</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/conferences">主流会议</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/courses">名人课堂</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/academy">学术专家</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/news">安全事件</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/knowledge">小科普</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/share">技术分享</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/contribution">本站达人</a> </li>
                    
              </ul>
            </div>
          </nav>


      </div>
  </div>
</header>




  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-drakvuf"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170302/drakvuf/">虚拟机监控-DRAKVUF</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170302/drakvuf/" class="article-date">
	  <time datetime="2017-03-02T08:56:54.000Z" itemprop="datePublished">三月 2, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p> <strong>[译文]</strong> 来源：<a href="https://drakvuf.com/" target="_blank" rel="external">https://drakvuf.com/</a> </p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170302/drakvuf/" target="_blank" rel="external">虚拟机监控-DRAKVUF</a>》</p>
<hr>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>DRAKVUF是一款无 Agent 的恶意软件动态分析系统，它基于Xen、LibVMI、Volatility、Rekall。它能深度追踪病毒样本，从内存中提取被删除的文件，并且无需在虚拟机里安装别的分析软件。</p>
<h3 id="硬件要求"><a href="#硬件要求" class="headerlink" title="硬件要求"></a>硬件要求</h3><p>DRAKVUF使用Intel CPU 中的硬件虚拟化扩展技术。你需要支持虚拟化(VT-x)和EPT(ExtendedPage Tables)的Intel CPU。DRAKVUF不能在其他CPU上运行(如AMD)或者不支持虚拟化扩展的CPU。</p>
<h3 id="支持系统"><a href="#支持系统" class="headerlink" title="支持系统"></a>支持系统</h3><p>DRAKVUF目前支持Windows 7，32位和64位系统演示使用DRAKVUF追踪Windows内部内核函数，包括堆分配。</p>
<p><a href="https://www.youtube.com/watch?v=ZJPHfpDiN4o" target="_blank" rel="external">DRAKVUF追踪Windows内部内核函数</a></p>
<p>这个演示展示的是DRAKVUF中的进程注入组件，它能够在客机中执行任意可执行文件，不需要任何在客机中安装的帮助程序。演示中我们劫持了Windows任务管理器来执行我们的任务。</p>
<p><a href="https://www.youtube.com/watch?v=0Dk5RehrA-Q" target="_blank" rel="external">劫持了Windows任务管理器</a></p>
<p>从内存中提取被删除的文件。很多病毒droppes的文件只会出现在内存中，不会在硬盘出现。</p>
<p><a href="https://www.youtube.com/watch?v=sOmD9tDU3lM" target="_blank" rel="external">从内存中提取被删除的文件</a></p>
<h3 id="报告展示"><a href="#报告展示" class="headerlink" title="报告展示"></a>报告展示</h3><p><a href="http://www.slideshare.net/slideshow/embed_code/key/72sSuElfARSGhI" target="_blank" rel="external">这是</a>2014年年度计算机安全应用会议(ACSAC)的展示</p>
<p>这是2014年在Hacktivity上的<a href="https://www.youtube.com/watch?v=EZPXy314q3E" target="_blank" rel="external">展示</a></p>
<h3 id="目前状态"><a href="#目前状态" class="headerlink" title="目前状态"></a>目前状态</h3><p>目前有以下的核心功能：</p>
<pre><code>无Agent执行恶意软件
无Agent监控Windows内部内核函数
客机多vCPU支持
追踪堆分配
追踪被访问的文件
在文件被删除前从内存中提取文件
通过写时拷贝内存和硬盘来克隆分析虚拟机
</code></pre><p>注意DRAKVUF仍在早期开发阶段，因此缺少其他恶意软件分析器具备的功能。还有很多的提升空间，例如：</p>
<pre><code>生成JSON/MySQL/MongoDB的结构化的日志
将提取的文件自动提交到VirusTotal
Linux支持
使用Run-time重复数据删除技术删除Xen共享内存中未使用的内存
整合恶意软件分析功能，如[CRITS](https://crits.github.io/)
</code></pre><h3 id="安装指导"><a href="#安装指导" class="headerlink" title="安装指导"></a>安装指导</h3><p>12/31/2015更新</p>
<p>如果安装了旧版本的DRAKVUF，阅读指导打开系统中的Xen altp2m！</p>
<p>要在基于Debian 的Linux上buildXen和DRAKVUF就需要安装以下的包。以下内容在Debian Jessie和Ubuntu14.04 LTS上测试通过。</p>
<pre><code>sudo apt-get install wget git bcc bin86 gawk bridge-utilsiproute libcurl3 libcurl4-openssl-dev bzip2 module-init-tools pciutils-devbuild-essential make gcc clang libc6-dev libc6-dev-i386 linux-libc-devzlib1g-dev python python-dev python-twisted python-gevent python-setuptoolslibncurses5-dev patch libvncserver-dev libssl-dev libsdl-dev iasl libbz2-deve2fslibs-dev git-core uuid-dev ocaml libx11-dev bison flex ocaml-findlibxz-utils gettext libyajl-dev libpixman-1-dev libaio-dev libfdt-dev cabextractlibglib2.0-dev autoconf automake libtool check libjson-c-dev libfuse-devlibsystemd-daemon-dev
</code></pre><p>你可以从repository安装Xen，但是我们还是建议用源码build。</p>
<pre><code>wget http://bits.xensource.com/oss-xen/release/4.6.1/xen-4.6.1.tar.gz 
wget http://bits.xensource.com/oss-xen/release/4.6.1/xen-4.6.1.tar.gz.sig
gpg --keyserver pgp.mit.edu --recv-keys 0x83fe14c957e82bd9
gpg --verify xen-4.6.1.tar.gz.sig
</code></pre><p>安装Xen dom0，分配4GB RAM和两个专用的CPU内核：</p>
<pre><code>sudo su make -j4 install-xen make -j4 install-tools
echo&quot;GRUB_CMDLINE_XEN_DEFAULT=\&quot;dom0_mem=4096M,max:4096M dom0_max_vcpus=4dom0_vcpus_pin=true hap_1gb=false hap_2mb=false altp2m=1\&quot;&quot; &gt;&gt;/etc/default/grub
echo &quot;/usr/local/lib&quot; &gt;/etc/ld.so.conf.d/xen.conf
ldconfig
update-grub
echo &quot;none /proc/xen xenfs defaults,nofail 0 0&quot;&gt;&gt;         /etc/fstab
echo &quot;xen-evtchn&quot; &gt;&gt; /etc/modules
echo &quot;xen-privcmd&quot; &gt;&gt; /etc/modules
update-rc.d xencommons defaults 19 18
update-rc.d xendomains defaults 21 20
update-rc.d xen-watchdog defaults 22 23
reboot
</code></pre><p>还要确保你的内核相对较新(版本大于3.8应该就行了)</p>
<pre><code>uname -r
</code></pre><p>进入Xen之后，验证一切是否正常：</p>
<pre><code>sudo xen-detect
</code></pre><p>输出的结果应该是：Running in PV context on Xen v4.6</p>
<pre><code>xl list
</code></pre><p>输出的结果应该类似于：</p>
<pre><code>Name                                        ID   Mem VCPUs           State     Time(s)
Domain-0                                     0  4096    2     r-----     614.0
</code></pre><p>建立一个LVM卷组存档虚拟机磁盘，然后创建卷：</p>
<pre><code>lvcreate -L20G -n windows7-sp1 vg
</code></pre><p>用ISO安装Windows 7：</p>
<pre><code>arch = &apos;x86_64&apos;
name = &quot;windows7-sp1&quot;
maxmem = 3000
memory = 3000
vcpus = 1
maxcpus = 1
builder = &quot;hvm&quot;
boot = &quot;cd&quot;
hap = 1
acpi = 1
on_poweroff = &quot;destroy&quot;
on_reboot = &quot;destroy&quot;
on_crash = &quot;destroy&quot;
vnc=1
vnclisten=&quot;0.0.0.0&quot;
usb = 1
usbdevice = &quot;tablet&quot;
altp2mhvm = 1
shadow_memory = 16
vif =[&apos;type=ioemu,model=e1000,bridge=xenbr0,mac=00:06:5B:BA:7C:01&apos;]
disk = [
 &apos;phy:/dev/vg/windows7-sp1,xvda,w&apos;,
 &apos;file:/path/to/your/windows7.iso,hdc:cdrom,r&apos;
]
</code></pre><p>下载LibVMI 的DRAKVUF分支，并准备build：</p>
<pre><code>git clone -b drakvuf https://github.com/tklengyel/libvmi
cd libvmi
./autogen.sh
./configure --enable-xen         --enable-xen-events--disable-address-cache
</code></pre><p>输出的结果应该类似于：</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Option</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td>Xen Support</td>
<td>–enable-xen=yes</td>
<td>yes</td>
</tr>
<tr>
<td>Xen Events</td>
<td>–enable-xen-events=yes</td>
<td>yes</td>
</tr>
<tr>
<td>KVM Support</td>
<td>–enable-kvm=no</td>
<td>libvirt missing</td>
</tr>
<tr>
<td>File Support</td>
<td>–enable-file=yes</td>
<td>yes</td>
</tr>
<tr>
<td>Shm-snapshot</td>
<td>–enable-shm-snapshot=no</td>
<td>no</td>
</tr>
<tr>
<td>————-</td>
<td>—————————</td>
<td>—————————-</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Tools</th>
<th>Option</th>
<th>Reason</th>
</tr>
</thead>
<tbody>
<tr>
<td>Examples</td>
<td>–enable-examples=yes</td>
<td>yes</td>
</tr>
<tr>
<td>VMIFS</td>
<td>–enable-vmifs=yes</td>
<td>yes</td>
</tr>
</tbody>
</table>
<p><strong>Extra features</strong><br>Support of Rekall profiles: yes</p>
<p>Build并安装LibVMI：</p>
<pre><code>make
sudo make install
echo &quot;exportLD_LIBRARY_PATH=\$LD_LIBRARY_PATH:/usr/local/lib&quot; &gt;&gt; ~/.bashrc
cd tools/pyvmi
python setup.py build
sudo python setup.py install
cd ../../..
</code></pre><p>下载Volatility：</p>
<pre><code>git clone https://github.com/volatilityfoundation/volatility
cd volatility
cp ../libvmi/tools/pyvmi/pyvmiaddressspace.pyvolatility/plugins/addrspaces
python setup.py build
sudo python setup.py install
cd ..
</code></pre><p>下载Rekall并安装：</p>
<pre><code>git clone --branch v1.4.1     https://github.com/google/rekall
cd rekall/rekall-core
python setup.py build
sudo python setup.py install
cd ../..
</code></pre><p>接下来我们要为Windows域创建Rekall档案，首先我们要用LibVMI win-guid工具获得WIndows内核的调试信息。例如：</p>
<pre><code>$ xl list
Name             ID   Mem   VCPUs   State     Time(s)
Domain-0         0    4024    4     r-----     848.8
windows7-sp1-x86 7    3000    1     -b----      94.7
$ win-guid name windows7-sp1-x86
Windows Kernel found @ 0x2604000
            Version:32-bit Windows 7
            PEGUID: 4ce78a09412000
            PDBGUID: 684da42a30cc450f81c535b4d18944b12
            Kernelfilename: ntkrpamp.pdb
            Multi-processorwith PAE (version 5.0 and higher)
            Signature:17744.
            Machine:332.
            # ofsections: 22.
            # ofsymbols: 0.
            Timestamp:1290242569.
            Characteristics:290.
            Optionalheader size: 224.
            Optionalheader type: 0x10b
            Section1: .text
            Section2: _PAGELK
            Section3: POOLMI
            Section4: POOLCODE
            Section5: .data
            Section6: ALMOSTRO
            Section7: SPINLOCK
            Section8: PAGE
            Section9: PAGELK
            Section10: PAGEKD
            Section11: PAGEVRFY
            Section12: PAGEHDLS
            Section13: PAGEBGFX
            Section14: PAGEVRFB
            Section15: .edata
            Section16: PAGEDATA
            Section17: PAGEKDD
            Section18: PAGEVRFC
            Section19: PAGEVRFD
            Section20: INIT
            Section21: .rsrc
            Section22: .reloc
</code></pre><p>关键的地方：</p>
<pre><code>PDB GUID: 684da42a30cc450f81c535b4d18944b12
Kernel filename: ntkrpamp.pdb
</code></pre><p>生成Rekall档案：</p>
<pre><code>cd /tmp
rekall fetch_pdb --pdb_filename ntkrpamp.pdb --guid684da42a30cc450f81c535b4d18944b12
rekall parse_pdb ntkrpamp.pdb &gt; windows7-sp1.rekall.json
sudo mv windows7-sp1.rekall.json /root
</code></pre><p>档案生成后我们可以创建LibVMI config：</p>
<pre><code>sudo su
printf &quot;windows7-sp1 { \n\
ostype =\&quot;Windows\&quot;; \n\
sysmap =\&quot;/root/windows7-sp1.rekall.json\&quot;; \n\
}&quot; &gt; /etc/libvmi.conf
</code></pre><p>用进程列表查看LibVMI是否在运行</p>
<pre><code>process-list windows7-sp1
</code></pre><p>输出结果应该类似于：</p>
<pre><code>Process listing for VM windows7-sp1-x86 (id=7)
[    4] System (structaddr:84aba980)
[  220] smss.exe(struct addr:85a44020)
[  300] csrss.exe(struct addr:85f67a68)
[  336] wininit.exe(struct addr:8601e030)
[  348] csrss.exe(struct addr:84ba4030)
[  384] winlogon.exe(struct addr:85966d40)
[  444] services.exe(struct addr:8614c030)
[  460] lsass.exe(struct addr:86171030)
[  468] lsm.exe(struct addr:8617b4f8)
[  564] svchost.exe(struct addr:861d9bc8)
[  628] svchost.exe(struct addr:863fb8a8)
[  816] sppsvc.exe(struct addr:86426838)
[  856] svchost.exe(struct addr:854abd40)
[  880] svchost.exe(struct addr:854c5030)
[  916] svchost.exe(struct addr:854d7a70)
[ 1240] svchost.exe (struct addr:8614cb80)
[ 1280] svchost.exe (struct addr:854f7d40)
[ 1608] spoolsv.exe (struct addr:85578660)
[ 1636] svchost.exe (struct addr:85554af0)
[  792] SearchIndexer.(struct addr:8562ac08)
[ 1128] taskhost.exe (struct addr:858d9d40)
[ 1524] dwm.exe (struct addr:857f3a60)
[ 1728] explorer.exe (struct addr:858d9180)
[ 1720] regsvr32.exe (struct addr:8605f398)
[  248] svchost.exe(struct addr:863ed030)
[ 1024] svchost.exe (struct addr:86420390)
[  256] WmiPrvSE.exe (structaddr:854014a0)
</code></pre><p>开始build并安装DRAKVUF：</p>
<pre><code>git clone https://github.com/tklengyel/drakvuf
cd drakvuf
autoreconf -vi
./configure
make
</code></pre><p>追踪系统的执行：</p>
<pre><code>./src/drakvuf -r &lt;rekall profile&gt; -d &lt;domid&gt;
</code></pre><p>例如：</p>
<pre><code>./src/drakvuf -r /root/windows7-sp1.rekall.json -d 7
</code></pre><hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170302/drakvuf/" target="_blank" rel="external">虚拟机监控-DRAKVUF</a>》</p>
<hr>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/虚拟机监控/">虚拟机监控<span class="article-category-count">11</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Introspection/">Introspection</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtualization/">Virtualization</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/XEN/">XEN</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-virtualization-overview"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170301/virtualization-overview/">虚拟化技术大观</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170301/virtualization-overview/" class="article-date">
	  <time datetime="2017-03-01T09:19:42.000Z" itemprop="datePublished">三月 1, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者：<a href="http://ring0.me/2014/12/virtualization-overview/" target="_blank" rel="external">Bojie Li</a> 来源：<a href="http://ring0.me/2014/12/virtualization-overview/" target="_blank" rel="external">http://ring0.me/2014/12/virtualization-overview/</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本文是一篇虚拟机技术的科普文，从虚拟化历史，到CPU虚拟化，内存虚拟化，设备虚拟化，操作系统虚拟化，以及Docker技术，循序渐进，全面有序。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170301/virtualization-overview/" target="_blank" rel="external">虚拟化技术大观</a>》</p>
<hr>
<p>虚拟化技术大家都不陌生，我们大都使用过诸如 VMWare、VirtualBox<br>的虚拟机软件。一些人认为，虚拟化技术是近几年跟着云计算的潮流才火起来的，十年前只是桌面用户测试其他操作系统的玩具。非也。只要计算机上同时运行着多个任务，就会有任务隔离的需求，虚拟化就是让每个任务看起来独占整个计算机、隔离任务之间影响的技术。早在计算机还是庞然大物的 20 世纪 60 年代，虚拟化技术就开始发展了。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview1.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview1.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<h3 id="IBM-7044-黑历史：硬件虚拟化"><a href="#IBM-7044-黑历史：硬件虚拟化" class="headerlink" title="IBM 7044  黑历史：硬件虚拟化"></a>IBM 7044  黑历史：硬件虚拟化</h3><p>1964 年的 IBM M44/44X 被认为是世界上第一个支持虚拟化的系统。它采用专门的硬件和软件，能够在一台物理机器上虚拟多个当时流行的 IBM 7044 大型机。它使用的虚拟化方法是非常原始的：像分时系统一样，在每个时间片，一个 IBM 7044 大型机独占所有硬件资源来运行。</p>
<p>值得一提的是，这个研究用的原型系统不仅开启了虚拟化技术的时代，也提出了 “分页” 这样一个重要的概念（因为每个虚拟机需要使用虚拟地址，这就需要一层虚拟地址到物理地址的映射）。</p>
<p>在那个 “进程” 概念尚未被发明的年代，多任务操作系统和虚拟化技术事实上是难以分开的，因为 “虚拟机” 就是一个任务，而且当时还没有 Intel x86 这种霸主地位的体系结构，各家的大型机各自为政，也谈不上兼容别家的体系结构。这种 “任务级” 或者说 “进程级” 虚拟化，从概念上延续到今天，就是以 LXC 和 OpenVZ 为代表的操作系统级虚拟化。</p>
<p>这种主要依赖定制的硬件来实现虚拟化的技术，史称 “硬件虚拟化”。在这个什么都要 “软件定义” 的时代，大型机已经日薄西山，大部分依赖硬件的虚拟化也进了历史博物馆。今天我们看到的虚拟化技术，大多是软件为主，硬件为辅。下图所示的划分没有严格的界限，而且一种虚拟化解决方案可能同时使用了下图中的多种技术，因此不要在意这些细节啦~</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview2.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview2.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<h3 id="从模拟执行到二进制翻译"><a href="#从模拟执行到二进制翻译" class="headerlink" title="从模拟执行到二进制翻译"></a>从模拟执行到二进制翻译</h3><p>前面提到大型机时代各大厂商各有各的体系结构和指令集，为什么没有出现各种指令集之间的翻译软件呢？须知，思科就是靠兼容各家网络设备和协议起家的（这里面还有八卦，创办思科的那对小情侣希望使用计算机网络传递情书，但网络设备五花八门的，于是他们就发明了兼容多种协议的路由器）。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview3.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview3.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>在网络协议之间翻译和在指令集之间翻译，都是机械、冗长、繁琐的事情，能把它做对，考虑到各种边角情况，是需要无比天才和细心的事情。指令集比网络协议麻烦的地方是，指令的边界（哪里是第一条指令，哪里是最后一条指令）未知，可能执行特权操作（如重启），还能把动态生成的数据作为代码来执行（冯·诺依曼体系结构中，数据和代码共享线性内存空间）。因此，在二进制代码运行之前就做好指令集之间的静态翻译，是不可能的。</p>
<p>最简单粗暴的解决方法是 “模拟执行”。开一个大数组当 “虚拟机” 的内存，拿来指令集手册，写一个无数个 case 的 switch 语句，判断当前要执行的是什么指令，按照手册的说法模拟执行。这样做自然是可行的，但效率就不敢恭维了，虚拟机至少比物理机慢一个数量级。所谓的 “动态类型语言”，如 Python、PHP、Ruby，在编译成中间代码后，大多也是用这种 “模拟执行” 的方法，因此快不起来。著名的 x86 模拟器 Bochs 就是模拟执行的，虽然慢，但兼容性好，而且不容易有安全漏洞。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview4.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview4.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>不能因为指令翻译难做就因噎废食，一个运行 1 亿次的 for 循环，里面如果都是加加减减一类的操作，翻译成机器码直接执行，肯定比模拟执行要快。在二进制翻译前面，要加上 “动态” 两个字，也就是在程序执行的过程中，能翻译的部分翻译成目标架构的机器码直接执行（并缓存起来以便重复利用），不能翻译的部分就陷入到模拟器里，模拟执行特权指令，再对后面的代码进行翻译。如今 Java、.NET、JavaScript 等使用的 JIT（Just-In-Time）技术也是类似的套路。</p>
<p>有人会问，如果我只是虚拟相同的体系结构，比如在 64 位 x86 系统上虚拟一个 64 位 x86 系统，需要做指令翻译吗？需要的。比如，虚拟机可能读取特权寄存器 GDT、LDT、IDT 和 TR，并不会触发处理器异常（即虚拟机管理器无法捕获到这样的行为），但这些特权寄存器的值又是需要对虚拟机 “伪造”<br>的。这就需要在虚拟机读取特权寄存器的指令执行之前，把它替换成调用虚拟机管理器的指令。</p>
<p>遗憾的是，在大型机年代，能把动态二进制翻译这件事做好的天才级人物 Fabrice Bellard 才刚刚出生（1972 年）。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview5.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview5.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>Fabrice Bellard 的 QEMU（Quick EMUlator）是目前最流行的采用动态二进制翻译技术的虚拟化软件。它可以模拟 x86、x86_64、ARM、MIPS、SPARC、<br>PowerPC 等多种处理器架构，无修改地运行这些架构上的操作系统。当我们享受视听的乐趣，当我们流畅地运行各种架构的虚拟机系统时，不应忘记 ffmpeg 和 qemu 的创造者 Fabrice Bellard 大神。</p>
<p>以我们最熟悉的 Intel x86 架构为例，分为四个特权级 0~3。一般情况下，操作系统内核（特权代码）运行在 ring 0（最高特权级），而用户进程（非特权代码）运行在 ring 3（最低特权级）。（即使你是 root，你的进程也在 ring 3！只有进了内核才是 ring 0，无上的权力意味着巨大的责任，内核编程的限制很多，吐槽一下）</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview6.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview6.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>使用了虚拟机之后，虚拟机（Guest OS）运行在 ring 1，主机操作系统（VMM，Virtual Machine Monitor）运行在 ring 0。比如在 Windows 上装个 Linux 虚拟机，Windows 内核运行在 ring 0，而被虚拟的 Linux 内核运行在 ring 1，Linux 系统里的应用程序则运行在 ring 3。</p>
<p>当虚拟机系统需要执行特权指令时，虚拟机管理器（VMM）就会立即捕<br>获它（谁让 ring 0 比 ring 1的特权级高呢！）并模拟执行这条特权指令，再返回到虚拟机系统。为了提高系统调用、中断处理的性能，有时会利用动态二进制翻译的技术，在运行前把这些特权指令替换成调用虚拟机管理器 API 的指令。如果所有特权指令都模拟得天衣无缝，虚拟机系统就像运行在物理机器上一样，完全不能发现自己运行在虚拟机里。（当然，事实上还是有一些破绽的）</p>
<p>请虚拟机系统和 CPU 来帮忙，动态二进制翻译虽然比模拟执行快了很多，但由于每条特权指令都要到虚拟机管理器里绕一圈（模拟执行），离物理机的性能仍然有不小的差距。要让虚拟机快起来，人们想到两种方法：</p>
<ul>
<li>让虚拟机操作系统帮忙，所谓 “半虚拟化”（paravirtualization）或 OS-assisted virtualization</li>
<li>让 CPU 帮忙，所谓 “硬件辅助虚拟化”（hardware-assisted virtualization）<br>这两种方法不是互斥的。现代的很多虚拟化解决方案，如 Xen、VMware，都同时使用了两种方法。</li>
</ul>
<h3 id="半虚拟化（paravirtualization）"><a href="#半虚拟化（paravirtualization）" class="headerlink" title="半虚拟化（paravirtualization）"></a>半虚拟化（paravirtualization）</h3><p>既然动态二进制翻译的难点和性能瓶颈在于模拟执行那些杂七杂八的特权指令，我们能不能修改虚拟机系统的内核，把那些特权指令改得好看些？毕竟在多数情况下，我们并不需要对虚拟机刻意 “隐瞒” 虚拟化层的存在，而是要在虚拟机之间提供必要的隔离，同时又不造成太多性能开销。</p>
<p>Paravirtualization 这个单词的前缀是 para-，即 “with” “alongside” 之意。也就是虚拟机系统与虚拟化层（主机系统）不再是严格的上下级关系，而是互信合作的关系，虚拟化层要在一定程度上信任虚拟机系统。在 x86 架构中，虚拟化层（Virtualization Layer）和虚拟机系统的内核（Guest OS）都运行在 ring 0。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview7.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview7.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>虚拟机系统的内核需要经过特殊修改，把特权指令改成对虚拟化层 API 的调用。在现代操作系统中，由于这些体系结构相关的特权操作都被封装起来了（例如 Linux 内核源码中的 arch/ 目录），比起二进制翻译需要考虑各种边角情况，这种对虚拟机内核源码的修改就简单一些了。</p>
<p>相比使用二进制翻译的全虚拟化（full virtualization），半虚拟化是牺牲了通用性来换取性能，因为任何操作系统都可以无修改地运行在全虚拟化平台上，而每个半虚拟化的操作系统内核都要经过人肉修改。</p>
<h3 id="硬件辅助的虚拟化"><a href="#硬件辅助的虚拟化" class="headerlink" title="硬件辅助的虚拟化"></a>硬件辅助的虚拟化</h3><p>同样的功能，专用硬件实现几乎总是比软件实现更快，几乎是一条金科玉律了。在虚拟化这件事上，比尔搞不定的事情，自然也要请安迪来帮忙。（比尔是微软公司创始人，安迪是 Intel 公司创始人）</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview8.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview8.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>让硬件帮助软件实现虚拟化的概念也不是新东西了。早在 1974 年，著名论文 Formal requirements for virtualizable third generation architectures 就提出了可虚拟化体系结构的三个基本条件：</p>
<ul>
<li>虚拟机管理器提供了与真实机器一模一样的虚拟环境；</li>
<li>运行在虚拟机里的程序在最坏情况下也比物理机慢得不多；</li>
<li>虚拟机管理器能够完全控制所有的系统资源。<ul>
<li>虚拟机里的程序不能访问未分配给它的资源</li>
<li>在某些情况下，虚拟机管理器能够收回已经分配给虚拟机的资源</li>
</ul>
</li>
</ul>
<p>早期的 x86 指令集不满足上述条件，因此需要虚拟机管理器做复杂的动态二进制翻译。既然二进制翻译的主要开销在 “捕获” 虚拟机系统的特权指令上，CPU 能做的事就是帮忙把 “捕获” 的事情给做了。Intel 家的解决方案叫做 Virtual Machine Control Structures (VT-x)，于 2005 年冬天推出；AMD 也不甘人后，随后推出了类似的 Virtual Machine Control Blocks (AMD-V)。</p>
<p>Intel 在原有的四个特权级基础上，增加了一个专供虚拟机管理器（VMM）使用的 “Root Mode”。这就好像是天不怕地不怕的孙悟空（ring 0）逃不出如来佛（Root Mode）的手掌心。这样，虚拟机系统尽管运行在 ring 0，其执行的特权指令仍然会被 CPU 自动捕获（触发异常），陷入到 Root Mode 的虚拟机管理器里，处理后再使用 VMLAUNCH 或 VMRESUME 指令返回到虚拟机系统。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview9.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview9.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>


<p>为了方便半虚拟化（paravirtualization）中用 API 调用替代 CPU 异常捕获，Intel 还提供了从虚拟机（Non-root Mode）到虚拟机管理器（Root Mode）的 “系统调用”：VMCALL 指令。</p>
<p>看起来很美好，不是吗？事实上，对刚刚开始支持硬件辅助虚拟化的<br>CPU，使用这个方式未必比动态二进制翻译性能高。因为硬件辅助虚拟化模式对每条特权指令，需要切换到 Root Mode，处理完后再返回，这个模式切换就像实模式和保护模式切换一样，需要初始化很多寄存器，还要保存和恢复现场，更不用说对TLB、高速缓存的影响了。不过，Intel 和 AMD 的工程师也不是吃白饭的，在较新的 CPU 里，硬件辅助虚拟化的性能开销已经比动态二进制翻译做得更好了。</p>
<p>最后说点实用的：在大多数 BIOS 里，硬件辅助虚拟化都是有开关选项的。只有使能了 Intel Virtualization Technology 这样的选项，虚拟机管理器才能用上硬件加速。因此在使用虚拟机的时候，不要忘了进 BIOS 检查一下。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview10.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview10.png" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>CPU 虚拟化不是一切前面说了这么多，给大家一种假象：只要虚拟了 CPU 指令就万事大吉了。CPU 固然是计算机的大脑，但计算机的其他组件也不容忽略。这些组件包括与 CPU 朝夕共处的内存和硬盘、显卡、网卡等形形<em>*</em>的外设。</p>
<h3 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h3><p>前面讲虚拟化的鼻祖 IBM M44/44X 的时候，提到它提出了 “分页”<br>的概念。也就是每个任务（虚拟机）似乎独占所有内存空间，分页机制负责把不同任务的内存地址映射到物理内存。如果物理内存不够了，操作系统就会把不常用的任务的内存交换到磁盘之类的外部存储，等那个不常用任务需要执行时再加载回来（当然，这种机制是后来才发明的）。这样，程序的开发者就不需要考虑物理内存空间有多大，也不需要考虑不同任务的内存地址是否会冲突。</p>
<p>现在我们用的计算机都有分页机制，应用程序（用户态进程）看到的是一片广阔无涯的虚拟内存（Virtual Memory），似乎整台机器都被自己独占；操作系统负责设置用户态进程的虚拟内存到物理内存的映射关系（如下图 VM1<br>框内所示）；CPU 中的 MMU（Memory Management Unit）负责在用户态程序运行时，通过查询映射关系（所谓的页表），把指令中的虚拟地址翻译成物理地址。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview11.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview11.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>有了虚拟机，事情就麻烦了一层。虚拟机之间要隔离，虚拟机的操作系统也就不能直接看到物理内存。上图中的红色部分即 “机器内存”（MA）由虚拟化层负责管理，而虚拟机看到的 “物理内存”（PA）事实上是被虚拟化的，也就是形成了两级地址映射关系。</p>
<p>在Intel 的 Nehalem 架构之前（感谢 jonathan 指正），内存管理器（MMU）只知道按照经典的分段、分页机制来进行内存寻址，不知道虚拟化层的存在。虚拟化层需要负责把两级地址映射 “压缩”<br>成一级映射，如上图红色箭头所示。虚拟化层的做法是：</p>
<ul>
<li>当切换到一台虚拟机时，就用这台虚拟机的内存映射关系（页表）作为物理机的页表；</li>
<li>如果虚拟机操作系统试图修改指向页表的 CR3 寄存器（如在进程间切换页表），会被替换成对 “影子页表” 内存地址的访问（通过动态二进制翻译，或者在硬件辅助虚拟化方案中，触发异常后陷入虚拟化层）；</li>
<li>如果虚拟机操作系统试图修改页表的内容，例如将一块新的物理内存（PA）映射到一个进程的虚拟内存（VA），虚拟化层需要将其截获，为物理地址（PA）在机器内存（MA）中分配空间，并将 “影子页表” 中的虚拟内存（VA）映射到机器内存（MA）；</li>
<li>如果虚拟机访问一个页面时它被换出到外部存储了，就会触发缺页异常，虚拟化层要负责把缺页异常分发到该虚拟机的操作系统。</li>
</ul>
<p>每个对页表的操作都从虚拟化层那里绕一圈是不小的开销。作为硬件辅助虚拟化的一部分，Intel 从 Nehalem 架构开始引入了 EPT (Extent Page Table) 技术，AMD 也引入了 NPT (Nest Page Table)，让内存管理单元（MMU）支持二级内存翻译（Second Level Address Translation，SLAT）：给虚拟化层提供另一套页表，首先根据虚拟地址（VA）查原来的页表得到物理地址（PA），再查新的页表得到机器地址（MA）。这样就不再需要 “影子页表” 了。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview12.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview12.png" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>有人也许会担心增加的一级映射关系会减慢内存访问速度，事实上不论是否启用二级内存翻译（SLAT），页表高速缓存（Translation Lookaside Buffer，TLB）都会存储虚拟地址（VA）到机器地址（MA）的映射。如果 TLB 的命中率较高，则增加的一级内存翻译不会显著影响内存访问性能。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview13.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview13.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<h3 id="设备虚拟化"><a href="#设备虚拟化" class="headerlink" title="设备虚拟化"></a>设备虚拟化</h3><p>除了 CPU 和内存以外的组件，被统称为外设。CPU 与外设之间的通信就是 I/O 了。每台虚拟机需要有硬盘、网络，甚至显卡、鼠标、键盘、光驱等。如果大家使用过虚拟机，应该对这些配置不陌生。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview14.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview14.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p><strong>Hyper-V 中的虚拟设备配置</strong></p>
<ul>
<li>虚拟设备，共享使用</li>
<li>直接分配，独占访问</li>
<li>在物理设备的辅助下，虚拟出多个 “小设备”</li>
</ul>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview15.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview15.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>我们以网卡为例，看看上述三种设备虚拟化方式是怎样的：</p>
<ul>
<li>最经典的做法：<br>对每个虚拟机虚拟出一个与物理设备无关的网卡，虚拟机访问网卡时，就会陷入到虚拟机管理器（VMM）。这个虚拟网卡仿佛有 A/B 两面，A<br>面在虚拟机内，B 面在虚拟机管理器（主机）里。从 A 面发出的数据包会被送到 B 面，而从 B 面的发出的数据包会被送到 A<br>面。虚拟机管理器里有一个虚拟交换机，在各个虚拟机的 B 面以及物理网卡间进行转发。显然，纯软件实现的虚拟交换机是系统的性能瓶颈。</li>
<li>最土豪的做法：<br>给每个虚拟机分配一个真实的物理网卡，把网卡的 PCI-E 地址空间映射到虚拟机内。当虚拟机访问该网卡的 PCI-E 地址空间时，如果 CPU 支持 I/O 虚拟化，CPU 中的 I/O MMU 就会把物理地址（PA）映射到机器地址（MA）；如果 CPU 不支持 I/O 虚拟化，就会触发异常并陷入虚拟机管理器，由虚拟机管理器软件完成从物理地址到机器地址的翻译，并发出真正的 PCI-E 请求。当 CPU 支持 I/O虚拟化时，虚拟机访问网卡不需要经过虚拟化层，性能是比较高的，但这需要每个虚拟机独占一块物理网卡，土豪才能玩得起。</li>
<li>最时髦的做法：<br>物理网卡支持虚拟化，可以虚拟出多个 Virtual Function（VF），虚拟化管理器可以把每个 Virtual Function<br>分配给一个虚拟机，虚拟机里使用定制的驱动程序，就能看到一个独立的 PCI-E 设备。虚拟机访问网卡时也是通过 CPU 的 I/O MMU 直接进行地址翻译，不需要经过虚拟化层。物理网卡内部则有一个简单的交换机，能够在 Virtual Functions和外面连接的网线<br>之间做转发。这种方法可以用单块网卡实现高性能，但需要比较高端的网卡，需要 CPU 支持 I/O虚拟化，还需要虚拟机系统内使用定制的驱动程序。</li>
</ul>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview16.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview16.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>I/O MMU 是让外设和虚拟机能够直接通信的硬件组件，绕过了虚拟机管理器（VMM），提高了 I/O 性能。Intel 的名字叫做 VT-d，而AMD 的名字叫做 AMD-Vi。它可以把设备寄存器和 DMA请求中的物理地址（PA）翻译成机器地址（MA），还可以把设备产生的中断分发到虚拟机里。</p>
<p>又到了实用时间：跟硬件辅助虚拟化一样，I/O MMU 在 BIOS 里也是有开关的，别忘了打开哦~</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview17.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview17.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>设备虚拟化也有 “全虚拟化” 和 “半虚拟化” 之分。如果虚拟机系统里的驱动程序能够修改，就可以直接调用虚拟机管理器（VMM）的 API，减少模拟硬件设备的开销，这种修改虚拟机内的驱动程序来提高性能的行为就属于半虚拟化。</p>
<p>通过在虚拟机系统里安装额外的驱动程序，还可以实现一些主机与虚拟机之间的交互（如共享剪贴板、拖动传文件）。这些驱动程序会在虚拟机系统中加载钩子，调用虚拟化管理器提供的 API 完成与主机系统的交互。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview18.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview18.png" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>在虚拟机里安装额外的驱动程序做个小结，大家可以去喝杯茶，回味一下：</p>
<ul>
<li>根据虚拟化管理器的实现方式，分为硬件虚拟化和软件虚拟化，硬件虚拟化已经退出历史舞台；</li>
<li>根据虚拟机操作系统是否需要修改，分为全虚拟化（Full Virtualization）和半虚拟化（Paravirtualization）；</li>
<li>根据如何处理特权指令，分为模拟执行（效率很低）、二进制翻译（QEMU）和硬件辅助的虚拟化（KVM 等）。</li>
</ul>
<h3 id="操作系统级虚拟化"><a href="#操作系统级虚拟化" class="headerlink" title="操作系统级虚拟化"></a>操作系统级虚拟化</h3><p>很多时候，我们并不是想在虚拟机里运行任意的操作系统，而是希望在不同的任务间实现一定程度的隔离。前面提到的虚拟化技术，每个虚拟机都是一个独立的操作系统，有自己的任务调度、内存管理、文件系统、设备驱动程序等，还会运行一定数量的系统服务（如刷新磁盘缓冲区、日志记录器、定时任务、ssh 服务器、时间同步服务），这些东西都会消耗系统资源（主要是内存），而且虚拟机和虚拟机管理器的两层任务调度、设备驱动等也会增加时间开销。能不能让虚拟机共享操作系统内核，又保持一定的隔离性呢？</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview19.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview19.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>两河缘何入一渠。为了方便开发和测试，1979 年的 UNIX 第七版引入了 chroot 机制。chroot 就是让一个进程把指定的目录作为根目录，它的所有文件系统操作都只能在这个指定目录里进行，这样就不会危害到主机系统。尽管 chroot<br>存在经典的跳出漏洞，而且它没有对进程、网络等资源进行任何隔离，chroot 至今仍然被用作构建和测试软件的干净环境。<br>要成为一个真正的虚拟化解决方案，只有文件系统隔离是不够的。另外两个重要的方面是：</p>
<ul>
<li>进程、网络、IPC（进程间通信）、用户等命名空间的隔离。使得虚拟机内部只能看到自己的进程，只能使用自己的虚拟网卡，进程间通信时不会干扰到虚拟机外面，虚拟机内的 UID/GID 与外面的独立。</li>
<li>资源的限制和审计。不能因为虚拟机内的程序 “跑飞了”，就占掉物理机器的所有 CPU、内存、硬盘等资源。必须要能统计虚拟机占了多少资源，并能够对资源进行限制。</li>
</ul>
<p>上述两件事情就是 BSD 和 Linux 社区在进入 21 世纪以来逐步在做的。在 Linux 中，命名空间的隔离叫做用户命名空间，在创建进程时，通过指定 clone 系统调用的参数来创建新的命名空间；资源的限制和审计是 cgroups 做的，它的 API 位于 proc 虚拟文件系统中。</p>
<p>这种虚拟机里运行一个或多个进程、虚拟机与主机共享一个内核的虚拟化方案，被称为 “操作系统级虚拟化” 或 “任务级虚拟化”。由于 Linux Containers（LXC）从 Linux 3.8 版本开始被纳入内核主线，操作系统级虚拟化又被称为<br>“容器”（container）。为了与虚拟机是一个完整的操作系统的虚拟化方案相区分，被隔离执行的进程（进程组）往往不称为 “虚拟机”，而称为 “容器”。由于没有多余的一层操作系统内核，容器比虚拟机更加轻量，启动更快，内存开销、调度开销也更小，更重要的是访问磁盘等 I/O 设备不需要经过虚拟化层，没有性能损失。</p>
<p>Linux 上的操作系统级虚拟化并不是从 LXC 开始有的，恰恰相反，LXC 是<br>“长江后浪推前浪” 的典型。Linux-Vserver、OpenVZ、Parallels Containers 都是在 Linux 内核里实现操作系统级虚拟化的解决方案。尽管小字辈们赢得了更多的眼球，作为一个长者，OpenVZ 还是比 LXC 多一些 “企业级” 的功能：<br>可以审计并限制每个容器的磁盘配额，通过目录级别的磁盘空间审计来实现（这也是 freeshell 使用 OpenVZ 而非 LXC 的主要原因）；<br>支持检查点（checkpoint）、热迁移（live migration）；<br>free -m、df -lh 等内存和磁盘的容量，在 OpenVZ 容器里看到的是它的配额，而 LXC 里看到的是物理机的容量；<br>支持 swap 空间，当发生 OOM（Out Of Memory）时杀死进程的行为与物理机器相同，而 LXC 会直接分配不出内存。<br>但是，由于 OpenVZ 坚持走 RHEL 路线，RHEL 6 还是 2.6.32 的老内核，RHEL 7 刚发布 OpenVZ 还没跟进，OpenVZ 内核现在看来已经很老了，连新版本的 systemd 都运行不起来，更不用说 3.x 内核的各种酷炫新功能了。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview20.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview20.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<h3 id="容器的好管家-Docker"><a href="#容器的好管家-Docker" class="headerlink" title="容器的好管家 Docker"></a>容器的好管家 Docker</h3><p>好马配好鞍，这么好用的 Linux 容器，自然也要有个好管家。从哪里获得系统镜像？如何对镜像进行版本控制？Docker 就是近来大红大紫的 Linux 容器好管家，据说连巨硬都向 Docker 示好，要为 Windows 开发容器支持了。</p>
<p>Docker 其实是为系统运维而生的，它大大降低了软件安装、部署的成本。软件的安装之所以是个麻烦事，是因为</p>
<ul>
<li>软件之间存在依赖关系。<br>比如，Linux 上依赖标准 C 库 glibc，依赖密码学库 OpenSSL，依赖 Java 运行环境；Windows 上依赖 .NET<br>Framework，依赖 Flash 播放器。如果每个软件都带上它所有的依赖，那就太臃肿了，如何找到并安装软件的依赖，是一门大学问，也是各个<br>Linux 发行版的特色所在。</li>
<li>软件之间存在冲突。比如，程序 A 依赖<br>glibc 2.13，而程序 B 依赖 glibc 2.14；甲脚本需要 Python 3，乙脚本需要 Python 2；Apache 和<br>Nginx 两个 Web 服务器都想要监听 80 端口。互相冲突的软件安装在同一个系统里，总是容易带来一些混乱，比如 Windows 早期的<br>DLL Hell。解决软件冲突之道就是隔离，让多个版本在系统里共存，并提供方法来找到匹配的版本。</li>
</ul>
<p>我们看看 Docker 如何解决这两个问题：</p>
<ul>
<li>把软件的所有依赖关系和运行环境打包在一个镜像里，而不是使用复杂的脚本来在未知的环境里 “安装” 软件；</li>
<li>这个包含了所有依赖的包一定很大，因此 Docker 的镜像是层次化的，即应用程序的镜像一般是基于基本系统镜像，只需要传输和存储增量部分就行了；</li>
<li>Docker 使用基于容器的虚拟化，把每个软件运行在独立的容器里，避免了不同软件的文件系统路径冲突和运行时的资源冲突。</li>
</ul>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview21.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview21.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure> 

<p>其中，Docker 的层次化镜像结构依赖于 Linux 的 AUFS（Another Union File System），AUFS 可以把基础目录 A、增量目录 B 合并挂载为一个目录 C，C 中能够同时看到 A、B 中的文件（有冲突以 B 中的为准），对 C 的修改会被写入 B。当一个 Docker 容器被启动时，就会生成一个增量目录并与作为基础目录的 Docker 镜像合并挂载，Docker 容器的所有写操作都被写入增量目录，而不会修改基础目录。这样就以比较低的开销实现了文件系统的 “版本控制”，也减小了软件的分发体积（只需分发增量部分，基础镜像是大多数人已经有的）。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview22.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview22.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>Docker、LXC 与内核组件的关系Docker 的虚拟化则是基于 libcontainer（上图比较老了，那时还是基于 LXC）。libcontainer 和 LXC 事实上都是基于 Linux 内核提供的 cgroups 资源审计、chroot 文件系统隔离、命名空间隔离等机制。<br>插播：Freeshell 是如何启动的我们知道 freeshell 采用的是 OpenVZ 虚拟化技术，经常有人问能不能换内核，还有人问 freeshell 系统是从哪里启动的。事实上，跟普通的 Linux 系统一样，freeshell 是从虚拟机里的 /sbin/init 开始运行的（看看是不是 1 号进程？），后面就是虚拟机系统自己的启动过程了。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview23.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview23.png" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>Freeshell 控制面板一角事实上，不同类型的虚拟化技术是从不同的地方开始引导虚拟机系统的：</p>
<ul>
<li>从模拟的 BIOS 开始引导的，支持 MBR、EFI、PXE 等启动方式，如 QEMU、VMWare；</li>
<li>从内核开始引导的，虚拟机镜像内不包含内核，如 KVM、Xen；</li>
<li>从 init 进程开始引导的，虚拟机是一个与主机共享内核的容器，会按照操作系统的引导过程启动各种系统服务，如 LXC、OpenVZ；</li>
</ul>
<p>只运行一个特定的应用程序或服务的，也是基于容器，如 Docker。<br>云操作系统 OpenStack前面讲的都是实现虚拟化的具体技术。但要让最终用户用上虚拟机，还需要有管理虚拟机的平台，或称 “云操作系统”。OpenStack 是目前最火的云操作系统。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview24.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview24.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>


<p>OpenStack 云操作系统OpenStack（或者任何靠谱的云操作系统）要对云上的各种资源进行虚拟化，它的管理组件称为 Nova。</p>
<ul>
<li>计算：本文所说的虚拟化技术就是计算的虚拟化。OpenStack 可以使用多种多样的虚拟化解决方案，如Xen、KVM、QEMU、Docker。管理组件 Nova根据各物理节点的负载决定把虚拟机调度到哪台物理机，再调用这些虚拟化解决方案的 API来创建、删除、开机、关机等。</li>
<li>存储：虚拟机镜像如果只能存储在计算节点本地，那么不仅不利于数据的冗余，也不利于虚拟机的迁移。因此在云中，一般采用逻辑上集中、物理上分布式的存储系统，独立于计算节点，也就是计算节点对数据磁盘的访问一般是通过网络访问。</li>
<li>网络：每个客户要有自己的虚拟网络，如何让不同客户的虚拟网络在物理网络上互不干扰，就是网络虚拟化的事情，参见我的另一篇博客《网络虚拟化技术大观》。除了最核心的虚拟化管理器 Nova，OpenStack 还有虚拟机镜像管理器 Glance、对象存储 Swift、块存储 Cinder、虚拟网络 Neutron、身份认证服务 Keystone、控制面板 Horizon 等众多组件。</li>
</ul>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview25.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview25.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>OpenStack 控制面板（Horizon）下面两张图展示了 Nova 分别使用 Docker 和 Xen 作为虚拟化解决方案的架构。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview26.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview26.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>Docker 受 OpenStack Nova 计算组件的调用</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/virtualization-overview27.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/virtualization-overview27.jpeg" width="400"></a><br>    <figcaption></figcaption><br></figure>

<p>使用 Xen 作为 OpenStack 的计算虚拟化方案</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>任务隔离的需求催生了虚拟化，我们都既希望任务隔离得彻底一些，又不希望损失太多的性能。从隔离性最高但慢到不实用的模拟执行，到现代全虚拟化技术所采用的动态二进制翻译与硬件辅助虚拟化，再到修改虚拟机系统的半虚拟化，再到共享内核、基于容器的操作系统级虚拟化，性能始终是虚拟化技术浪潮的第一推动力。不过，当我们选择虚拟化技术时，还是要根据实际需求，在隔离性与性能的天平上找到平衡点。</p>
<p>古老的计算虚拟化技术，加上相对新生的存储、网络虚拟化技术，构成了云操作系统的基石。九层之台，起于垒土，当我们享受云端似乎取之不尽用之不竭的计算资源时，如果能剥开一层层的封装，洞悉计算的本质，也许我们会更加珍惜云端的计算资源，更加赞叹虚拟化技术大厦的宏伟与精致，也更加崇敬和膜拜那些引领人类走进云时代的计算机大师。</p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170301/virtualization-overview/" target="_blank" rel="external">虚拟化技术大观</a>》</p>
<hr>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/虚拟化基础/">虚拟化基础<span class="article-category-count">6</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/">System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtualization/">Virtualization</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-recordreplay-papers"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170301/recordreplay-papers/">虚拟机记录与重放论文推荐</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170301/recordreplay-papers/" class="article-date">
	  <time datetime="2017-03-01T06:56:40.000Z" itemprop="datePublished">三月 1, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p><strong>CSysSec注</strong>： 本系列文章旨在收集相关领域经典论文阅读列表，持续更新中。<br><strong>转载请注明：</strong> <a href="http://www.csyssec.org/20170301/recordreplay-papers/" target="_blank" rel="external">《虚拟机记录与重放论文推荐》</a></p>
<hr>
<ul>
<li><a href="https://www.cs.utah.edu/~regehr/papers/vee16-xentt.pdf" target="_blank" rel="external">Abstractions for Practical Virtual Machine Replay, VEE’16</a></li>
<li><a href="http://www.cl.cam.ac.uk/research/srg/netos/vee_2012/papers/p227.pdf" target="_blank" rel="external">V2e: combining hardware virtualization and softwareemulation for transparent and extensible malware analysis,VEE’12</a></li>
<li><a href="http://www.ispras.ru/en/publications/deterministic_replay_of_system_s_execution_with_multi_target_qemu_simulator_for_dynamic_analysis.pdf" target="_blank" rel="external">Deterministic replay of system’s execution with multi-target QEMU simulator for dynamic analysis and reverse debugging</a></li>
<li><a href="">A KVM-Based Logging and Replay System for Debugging Non-Deterministic Executions A KVM-Based Logging and Replay System for Debugging Non-Deterministic Executions</a></li>
<li><a href="http://net.pku.edu.cn/vc/papers/atc16-final298.pdf" target="_blank" rel="external">Samsara: Efficient Deterministic Replay in Multiprocessor Environments with Hardware Virtualization Extensions,ATC’16</a></li>
<li><a href="https://pdfs.semanticscholar.org/d7c7/5388f0fcc2ac107570066001c191c4e7cbc7.pdf" target="_blank" rel="external">Execution Replay of Multiprocessor Virtual Machines,VEE’08</a></li>
<li><a href="http://web.eecs.umich.edu/virtual/papers/dunlap02.pdf" target="_blank" rel="external">ReVirt: Enabling intrusion analysis through virtual-machine logging and replay,OSDI’02</a></li>
<li><a href="">Don’T Panic: Reverse Debugging of Kernel Drivers</a></li>
<li><a href="http://www.jhuapl.edu/techdigest/TD/td3202/32_02-Grizzard.pdf" target="_blank" rel="external">Analysis of virtual machine record and replay for trustworthy computing,2013</a></li>
<li><a href="http://www-mount.ece.umn.edu/~jjyi/MoBS/2007/program/01C-Xu.pdf" target="_blank" rel="external">ReTrace: Collecting Execution Trace with Virtual Machine Deterministic Replay</a></li>
<li><a href="">XenLR: Xen-based logging for deterministic replay</a></li>
<li><a href="https://www.cse.iitb.ac.in/synerg/lib/exe/fetch.php?media=public:students:kumaran:report.pdf" target="_blank" rel="external">Implementation and Applications of Virtual Machine Record and Replay</a></li>
</ul>
<hr>
<p><strong>转载请注明：</strong> <a href="http://www.csyssec.org/20170301/recordreplay-papers/" target="_blank" rel="external">《虚拟机记录与重放论文推荐》</a></p>
<hr>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/虚拟机记录与重放/">虚拟机记录与重放<span class="article-category-count">1</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Paper/">Paper</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtualization/">Virtualization</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-compile-link"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170301/compile-link/">理清编译链接的那些事儿</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170301/compile-link/" class="article-date">
	  <time datetime="2017-03-01T05:26:03.000Z" itemprop="datePublished">三月 1, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本文来自<a href="http://www.chongh.wiki/about/" target="_blank" rel="external">Diting0x</a>的<a href="http://www.chongh.wiki/blog/2016/05/25/lib-compile-link/" target="_blank" rel="external">个人博客</a>，主要介绍了Linux内核中一系列的内存分配函数及其原理<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170301/compile-link/" target="_blank" rel="external">理清编译链接的那些事儿</a>》与作者信息：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>
<hr>
<p>当你在linux下写C/C++代码的时候，是不是会遇到许多编译链接的问题？ 时不时报个glibc,gcc，g++等相关的错误？ 很多时候都无从下手，而且比较混乱。 这也是编译链接过程中经常出现的问题。</p>
<p>这篇文章不是去介绍如何编译链接，而是理清编译链接过程中碰到的一些概念和出现的问题。尤其是，libc,,glib,glibc,eglibc，libc++，libstdc++，gcc,g++。 </p>
<p>从libc说起。<br>libc是Linux下原来的标准C库，也就是当初写hello world时包含的头文件#include &lt; stdio.h> 定义的地方。 </p>
<p>后来逐渐被glibc取代，也就是传说中的GNU C Library,在此之前除了有libc，还有klibc,uclibc。现在只要知道用的最多的是glibc就行了，主流的一些linux操作系统如 Debian, Ubuntu，Redhat等用的都是glibc（或者其变种，下面会说到).</p>
<p>那glibc都做了些什么呢？ glibc是Linux系统中最底层的API，几乎其它任何的运行库都要依赖glibc。 glibc最主要的功能就是对系统调用的封装，你想想看，你怎么能在C代码中直接用fopen函数就能打开文件？ 打开文件最终还是要触发系统中的sys_open系统调用，而这中间的处理过程都是glibc来完成的。<a href="http://www.chongh.wiki/blog/2016/04/08/linux-syscalls/" target="_blank" rel="external">这篇文章</a>详细介绍了glibc是如何与上层应用程序和系统调用交互的。除了封装系统调用，glibc自身也提供了一些上层应用函数必要的功能,如string,malloc,stdlib,linuxthreads,locale,signal等等。</p>
<p>好了，那eglibc又是什么？ 这里的e是Embedded的意思，也就是前面说到的变种glibc。eglibc的主要特性是为了更好的支持嵌入式架构，可以支持不同的shell(包括嵌入式)，但它是二进制兼容glibc的，就是说如果你的代码之前依赖eglibc库，那么换成glibc后也不需要重新编译。ubuntu系统用的就是eglibc（而不是glibc）,不信，你执行 ldd –version 或者 /lib/i386-linux-gnu/libc.so.6<br>(64位系统运行/lib/x86_64-linux-gnu）看看，便会显示你系统中eglibc/glibc的版本信息。  这里提到了libc.so.6,这个文件就是eglibc/glibc编译后的生成库文件。</p>
<p>好了，还有一个glib看起来也很相似，那它又是什么呢？glib也是个c程序库，不过比较轻量级，glib将C语言中的数据类型统一封装成自己的数据类型，提供了C语言常用的数据结构的定义以及处理函数，有趣的宏以及可移植的封装等(注：glib是可移植的，说明你可以在linux下，也可以在windows下使用它）。那它跟glibc有什么关系吗？其实并没有，除非你的程序代码会用到glib库中的数据结构或者函数，glib库在ubuntu系统中并不会默认安装(可以通过apt-get install libglib2.0-dev手动安装)，著名的GTK+和Gnome底层用的都是glib库。想更详细了解glib？ 可以参考 <a href="https://developer.gnome.org/glib/" target="_blank" rel="external">这里</a></p>
<p>看到这里，你应该知道这些库有多重要了吧？ 你写的C代码在编译的过程中有可能出现明明是这些库里面定义的变,却量还会出现’Undefined’, ‘Unreference’等错误，这时候你可能会怀疑是不是这些库出问题了？ 是不是该动手换个gilbc/eglibc了？ 这里强调一点，在你准备更换/升级这些库之前，你应该好好思考一下，你真的要更换/升级吗？你要知道你自己在做什么！你要时刻知道glibc/eglibc的影响有多大，不管你之前部署的什么程序，linux系统的ls,cd,mv,ps等等全都得依赖它，很多人在更换/升级都有过惨痛的教训，甚至让整个系统奔溃无法启动。所以，强烈不建议更换/升级这些库！</p>
<p>当然如果你写的是C++代码，还有两个库也要非常重视了，libc++/libstdc++,这两个库有关系吗？有。两个都是C++标准库。libc++是针对clang编译器特别重写的C++标准库，那libstdc++自然就是gcc的事儿了。libstdc++与gcc的关系就像clang与libc++. 其中的区别这里不作详细介绍了。</p>
<p>再说说libstdc++，glibc的关系。 libstdc++与gcc是捆绑在一起的，也就是说安装gcc的时候会把libstdc++装上。 那为什么glibc和gcc没有捆绑在一起呢？<br>相比glibc，libstdc++虽然提供了c++程序的标准库，但它并不与内核打交道。对于系统级别的事件，libstdc++首先是会与glibc交互，才能和内核通信。相比glibc来说，libstdc++就显得没那么基础了。</p>
<p>说完了这些库，这些库最终都是拿来干嘛的？当然是要将它们与你的程序链接在一起！ 这时候就不得不说说gcc了(当然还有前文提到的clang以及llvm等编译器，本文就不细说它们的区别了)。</p>
<p>你写的C代码.c文件通过gcc首先转化为汇编.S文件，之后汇编器as将.S文件转化为机器代码.o文件，生成的.o文件再与其它.o文件，或者之前提到的libc.so.6库文件通过ld链接器链接在一块生成可执行文件。当然，在你编译代码使用gcc的时候，gcc命令已经帮你把这些细节全部做好了。</p>
<p>那g++是做什么的? 慢慢说来，不要以为gcc只能编译C代码，g++只能编译c++代码。 后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序，注意，虽然c++是c的超集，但是两者对语法的要求是有区别的。在编译阶段，g++会调用gcc,对于c++代码，两者是等价的，但是因为gcc命令不能自动和C++程序使用的库联接，需要这样，gcc -lstdc++, 所以如果你的Makefile文件并没有手动加上libstdc++库，一般就会提示错误，要求你安装g++编译器了。</p>
<p>好了，就说到这，理清这些库与编译器之间的关系，相信会对你解决编译链接过程中遇到的错误起到一点帮助。</p>
<p>如果你的编译器不支持一些新的C/C++特性，想升级gcc/g++, 这里也给出一个基于ubuntu系统的参考方法。</p>
<p>添加ppa</p>
<pre><code>sudo add-apt-repository ppa:ubuntu-toolchain-r/test
sudo apt-get update
</code></pre><p>添加ppa，是因为你所用的ubuntu版本的更新源中可能并没有你想要的gcc/g++版本。</p>
<p>安装新版gcc/g++</p>
<pre><code>sudo apt-get install gcc-4.8
sudo apt-get install g++-4.8
</code></pre><p>可以到/usr/bin/gcc查看新安装的gcc,g++</p>
<p>配置系统gcc/g++</p>
<p>使用update-alternatives,统一更新gcc/g++</p>
<pre><code>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.6 60 --slave /usr/bin/g++ g++ /usr/bin/g++-4.6
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 80 --slave /usr/bin/g++ g++ /usr/bin/g++-4.8
sudo update-alternatives --config gcc
</code></pre><p>数字优先级(如60，80)高的会被系统选择为默认的编译器,也可以执行第三条命令就是来手动配置系统的gcc,此处按照提示,选择4.8版本的即可。</p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170301/compile-link/" target="_blank" rel="external">理清编译链接的那些事儿</a>》与作者信息：<a href="http://weibo.com/diting0x" target="_blank" rel="external">Diting0x</a></p>
<hr>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/系统内核/">系统内核<span class="article-category-count">11</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Compiler/">Compiler</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/">Kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/">System</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-kernel-malloc"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170301/kernel-malloc/">深入理解Linux内存分配</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170301/kernel-malloc/" class="article-date">
	  <time datetime="2017-03-01T05:22:46.000Z" itemprop="datePublished">三月 1, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        

          
            <div class="entry-summary" style="margin-left:0;">
            作者：Diting0x

CSysSec注： 本文来自Diting0x的个人博客，主要介绍了Linux内核中一系列的内存分配函数及其原理转载本文请务必注明，文章出处：《深入理解Linux内核分配》与作者信息：Diting0x

为了写一个用户层程序，你也许会声明一个全局变量，这个全局变量可能是一个int类型也可能是一个数组，而声明之后你有可能会先初始化它，也有可能放在之后用到它的时候再初始化。除此之外，你有可能会选择在函数内部去声明局部变量，又或者为变量动态申请内存。

不管你在用户程序中采取哪种方式申请内存，这些都对应着不同的内存分配方式以及不同的数据段，如果再加上代码段，就构成了一个完整的进程。由此可见，一个完整的进程在内存空间中对应着不同的数据区，具体来说，对应着五种不同的数据区...
          

        
          <p class="article-more-link">
            <a href="/20170301/kernel-malloc/#more">阅读全文</a>
          </p>
        </div>
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/系统内核/">系统内核<span class="article-category-count">11</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/">Kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/">System</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/13/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/15/">下一页</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div class="widget-wrap" style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 75%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 42px;" placeholder=" 搜索…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="搜索">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">集思广益</h3>
      <p>我们推崇的是黑客与分享精神，如果您觉得本站对您有帮助，不妨自己也参与进来共同建设，期待您能推荐好文章或投稿至本站，
让更多人受益。本站热烈欢迎志同道合者与志愿者参与本站的共同维护和建设，您可通过微博[@Diting0x](http://weibo.com/diting0x)联系我</p>
       <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="null" title="Words"><i class="fa fa-words" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a> </li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>


        	</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>最新推荐</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170822/rop-attack-defense/">ROP攻与防</a></h6>
          <!--  <span>八月 22, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170821/intel-pml/">Intel VT 页面修改记录(PML)</a></h6>
          <!--  <span>八月 21, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170819/cachekit/">CacheKit 利用cache不一致性绕过内存监控</a></h6>
          <!--  <span>八月 19, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170808/rowhammer/">神乎其神的Rowhammer：用比特位翻转实现云虚拟机夺权</a></h6>
          <!--  <span>八月 8, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170808/googleprojectzero/">谷歌Project Zero：通过“Row hammer”漏洞获取系统权限</a></h6>
          <!--  <span>八月 8, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170807/bypassaslr-analysis/">ASLR保护机制被突破的攻击技术分析</a></h6>
          <!--  <span>八月 7, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170605/memorysafety-defense/">内存持久战之防御措施</a></h6>
          <!--  <span>六月 5, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170531/ravel/">会找漏洞的时光机-Pinpointing Vulnerabilities</a></h6>
          <!--  <span>五月 31, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170513/memorysafety-attack/">内存支持战之攻击模型</a></h6>
          <!--  <span>五月 13, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170513/memorysafety/">内存持久战之内存安全性</a></h6>
          <!--  <span>五月 13, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170508/intro-aslr/">系统安全浅薄知识系列(一)-ASLR</a></h6>
          <!--  <span>五月 8, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170505/cfi-mathias/">控制流完整性-Mathias Payer</a></h6>
          <!--  <span>五月 5, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170505/vmi-xenproject/">虚拟机自省技术-一个有新商业应用的安全性创造</a></h6>
          <!--  <span>五月 5, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/cf-exception/">控制流分支指令上的控制流处理器异常(单步执行)</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/cfi-development/">控制流完整性的发展历程</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/cfi-ccs05/">控制流完整性-CCS05年论文</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类导航</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hypervisor安全/">Hypervisor安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Notes/">Notes</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/主流会议/">主流会议</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/二进制分析/">二进制分析</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存安全/">内存安全</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内核安全/">内核安全</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内核完整性/">内核完整性</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/博士之路/">博士之路</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/名人课堂/">名人课堂</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学术专家/">学术专家</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全圈子/">安全圈子</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/恶意代码/">恶意代码</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/漏洞利用/">漏洞利用</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/硬件特性/">硬件特性</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/硬件虚拟化/">硬件虚拟化</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统内核/">系统内核</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统安全/">系统安全</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统安全科普/">系统安全科普</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟化原理/">虚拟化原理</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟化基础/">虚拟化基础</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟化综合/">虚拟化综合</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机快照/">虚拟机快照</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机监控/">虚拟机监控</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机记录与重放/">虚拟机记录与重放</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机迁移/">虚拟机迁移</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签导航</h3>
    <div class="widget tagcloud">
      <a href="/tags/ASLR/" style="font-size: 12.31px;">ASLR</a> <a href="/tags/ASPLOS/" style="font-size: 10px;">ASPLOS</a> <a href="/tags/Attack/" style="font-size: 12.31px;">Attack</a> <a href="/tags/Binary/" style="font-size: 10.77px;">Binary</a> <a href="/tags/CFI/" style="font-size: 12.31px;">CFI</a> <a href="/tags/Cache/" style="font-size: 10px;">Cache</a> <a href="/tags/Cloud/" style="font-size: 10px;">Cloud</a> <a href="/tags/Compiler/" style="font-size: 10px;">Compiler</a> <a href="/tags/Conference/" style="font-size: 12.31px;">Conference</a> <a href="/tags/Conferences/" style="font-size: 10px;">Conferences</a> <a href="/tags/Course/" style="font-size: 13.08px;">Course</a> <a href="/tags/EPT/" style="font-size: 10px;">EPT</a> <a href="/tags/Exception/" style="font-size: 10px;">Exception</a> <a href="/tags/Exploit/" style="font-size: 16.92px;">Exploit</a> <a href="/tags/Forensics/" style="font-size: 10px;">Forensics</a> <a href="/tags/HAV/" style="font-size: 12.31px;">HAV</a> <a href="/tags/Hardware/" style="font-size: 13.85px;">Hardware</a> <a href="/tags/Heap/" style="font-size: 10.77px;">Heap</a> <a href="/tags/Hooking/" style="font-size: 10px;">Hooking</a> <a href="/tags/Instrumentation/" style="font-size: 10.77px;">Instrumentation</a> <a href="/tags/Introspection/" style="font-size: 13.85px;">Introspection</a> <a href="/tags/JOP/" style="font-size: 10px;">JOP</a> <a href="/tags/KVM/" style="font-size: 16.15px;">KVM</a> <a href="/tags/Kernel/" style="font-size: 17.69px;">Kernel</a> <a href="/tags/Libvmi/" style="font-size: 13.08px;">Libvmi</a> <a href="/tags/Linux/" style="font-size: 13.08px;">Linux</a> <a href="/tags/Malware/" style="font-size: 15.38px;">Malware</a> <a href="/tags/Memory/" style="font-size: 13.08px;">Memory</a> <a href="/tags/Migration/" style="font-size: 11.54px;">Migration</a> <a href="/tags/Monitoring/" style="font-size: 13.08px;">Monitoring</a> <a href="/tags/NX/" style="font-size: 10px;">NX</a> <a href="/tags/Overflow/" style="font-size: 10.77px;">Overflow</a> <a href="/tags/PIN/" style="font-size: 10px;">PIN</a> <a href="/tags/Paper/" style="font-size: 11.54px;">Paper</a> <a href="/tags/Ph-D/" style="font-size: 10.77px;">Ph.D</a> <a href="/tags/Ppaerwriting/" style="font-size: 10px;">Ppaerwriting</a> <a href="/tags/Professor/" style="font-size: 12.31px;">Professor</a> <a href="/tags/QEMU/" style="font-size: 14.62px;">QEMU</a> <a href="/tags/RE/" style="font-size: 10px;">RE</a> <a href="/tags/ROP/" style="font-size: 11.54px;">ROP</a> <a href="/tags/Rootkit/" style="font-size: 11.54px;">Rootkit</a> <a href="/tags/Rowhammer/" style="font-size: 10.77px;">Rowhammer</a> <a href="/tags/SYSCALL/" style="font-size: 10px;">SYSCALL</a> <a href="/tags/Sandbox/" style="font-size: 10.77px;">Sandbox</a> <a href="/tags/Security/" style="font-size: 20px;">Security</a> <a href="/tags/Shellcode/" style="font-size: 10px;">Shellcode</a> <a href="/tags/Snapshot/" style="font-size: 10px;">Snapshot</a> <a href="/tags/Stack/" style="font-size: 10.77px;">Stack</a> <a href="/tags/Syscall/" style="font-size: 10px;">Syscall</a> <a href="/tags/System/" style="font-size: 18.46px;">System</a> <a href="/tags/Systemcall/" style="font-size: 11.54px;">Systemcall</a> <a href="/tags/TSX/" style="font-size: 10px;">TSX</a> <a href="/tags/TrustZone/" style="font-size: 10px;">TrustZone</a> <a href="/tags/TrustZong/" style="font-size: 10px;">TrustZong</a> <a href="/tags/VT-x/" style="font-size: 10px;">VT-x</a> <a href="/tags/Valgrind/" style="font-size: 10px;">Valgrind</a> <a href="/tags/Virtualization/" style="font-size: 19.23px;">Virtualization</a> <a href="/tags/Volatility/" style="font-size: 10px;">Volatility</a> <a href="/tags/XEN/" style="font-size: 13.08px;">XEN</a>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      版权所有&copy; 2017 Index of Computer System and Security 保留所有权利.
      </div>
      <div class="site-credit">
       <!--  自豪地使用 <a href="https://github.com/iTimeTraveler/hexo-theme-hiero" target="_blank">hiero</a> --> 
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
</script>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/syssec" class="mobile-nav-link">Syssec</a>
  
    <a href="/architecture" class="mobile-nav-link">Architecture</a>
  
    <a href="/virtualization" class="mobile-nav-link">Virtualization</a>
  
    <a href="/malware" class="mobile-nav-link">Malware</a>
  
    <a href="/conferences" class="mobile-nav-link">Conferences</a>
  
    <a href="/courses" class="mobile-nav-link">Courses</a>
  
    <a href="/academy" class="mobile-nav-link">Academy</a>
  
    <a href="/news" class="mobile-nav-link">News</a>
  
    <a href="/knowledge" class="mobile-nav-link">Knowledge</a>
  
    <a href="/share" class="mobile-nav-link">Share</a>
  
    <a href="/contribution" class="mobile-nav-link">Contribution</a>
  
</nav> -->
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>





  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
  

  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1261078922&web_id=1261078922" language="JavaScript"></script>
  </div>


</body>
</html>
