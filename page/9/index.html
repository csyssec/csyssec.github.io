<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Index of Computer System and Security</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="computer system, computer security" />
  
  
  
  
  <meta name="description" content="Diting0x@">
<meta property="og:type" content="website">
<meta property="og:title" content="Index of Computer System and Security">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="Index of Computer System and Security">
<meta property="og:description" content="Diting0x@">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Index of Computer System and Security">
<meta name="twitter:description" content="Diting0x@">
  
    <link rel="alternate" href="/atom.xml" title="Index of Computer System and Security" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/hiero.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>

<body>
  <header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            <a href="/" title="Index of Computer System and Security" rel="home">
              Index of Computer System and Security</a>
          </h1>
          <div class="site-description">Diting0x@</div>

            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>
            <div class="clearfix sf-menu">

              <ul id="main-nav" class="nmenu sf-js-enabled">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/syssec">系统安全</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/architecture">系统结构</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/virtualization">虚拟化</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/malware">恶意代码</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/conferences">主流会议</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/courses">名人课堂</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/academy">学术专家</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/news">安全事件</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/knowledge">小科普</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/share">技术分享</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/contribution">本站达人</a> </li>
                    
              </ul>
            </div>
          </nav>


      </div>
  </div>
</header>




  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-kvm-migration"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170504/kvm-migration/">KVM迁移中脏页位图机制源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170504/kvm-migration/" class="article-date">
	  <time datetime="2017-05-04T07:09:30.000Z" itemprop="datePublished">五月 4, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者:<a href="http://blog.csdn.net/mrbuffoon" target="_blank" rel="external">Mr_buffoon</a><br><strong>转载请注明</strong>：原作者信息以及<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec</a></p>
<hr>
<p>我们都知道KVM支持在线迁移，而其在线迁移是通过内存预拷贝（迭代拷贝）机制来实现的。预拷贝的一个思想就是不断记录脏页并每一轮迭代拷贝脏页面，直至达到一定的条件就退出迭代，进行最后的停机拷贝。关于预拷贝的原理我之前有博客进行了简单分析，在这里就不重复说明了。那这篇文章主要是就其中的脏页记录机制从源码层面进行分析。</p>
<p>这里分析的代码版本是kvm3.10.1和qemu 1.5.3。我们直接进入到迁移（migration）的线程函数Migration.c—&gt;migration_thread()，直接看代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">migration_thread</span><span class="params">(<span class="keyword">void</span> *opaque)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="comment">//.........//省略部分代码  </span></div><div class="line">    qemu_savevm_state_begin(s-&gt;file, &amp;s-&gt;params);  </div><div class="line">  </div><div class="line">    <span class="keyword">while</span> (s-&gt;state == MIG_STATE_ACTIVE) &#123;  </div><div class="line">        <span class="keyword">int64_t</span> current_time;  </div><div class="line">        <span class="keyword">uint64_t</span> pending_size;  </div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (!qemu_file_rate_limit(s-&gt;file)) &#123;  </div><div class="line">            DPRINTF(<span class="string">"iterate\n"</span>);  </div><div class="line">            pending_size = qemu_savevm_state_pending(s-&gt;file, max_size);  </div><div class="line">            DPRINTF(<span class="string">"pending size %lu max %lu\n"</span>, pending_size, max_size);  </div><div class="line">            <span class="keyword">if</span> (pending_size &amp;&amp; pending_size &gt;= max_size) &#123;  </div><div class="line">                qemu_savevm_state_iterate(s-&gt;file);  </div><div class="line">            &#125; <span class="keyword">else</span> &#123;  </div><div class="line">                <span class="comment">//..........//省略部分代码  </span></div><div class="line">                qemu_savevm_state_complete(s-&gt;file);  </div><div class="line">                <span class="comment">//..........//省略部分代码  </span></div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="comment">//..........//省略部分代码  </span></div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">//..........//省略部分代码  </span></div><div class="line">  </div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 这个函数主要是完成迁移的初始化以及内存拷贝过程，这里先看一下里面qemu_savevm_state_begin()这个函数，他里面调用了save_live_setup这个函数指针，这个函数指针在之前被注册，指向了ram_save_setup()这个函数，具体的注册过程这里不进行分析，根据代码追一下可以追到的。ram_save_setup()主要是进行一些初始化的工作，下面看ram_save_setup()这个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ram_save_setup</span><span class="params">(QEMUFile *f, <span class="keyword">void</span> *opaque)</span>  </span></div><div class="line">&#123;  </div><div class="line">    ........  </div><div class="line">  </div><div class="line">    migration_bitmap = bitmap_new(ram_pages);  </div><div class="line">    bitmap_set(migration_bitmap, <span class="number">0</span>, ram_pages);  </div><div class="line">    migration_dirty_pages = ram_pages;  </div><div class="line">  </div><div class="line">    ........  </div><div class="line">  </div><div class="line">    memory_global_dirty_log_start();  </div><div class="line">    migration_bitmap_sync();  </div><div class="line">    ........  </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看这个函数，里面有一个migration_bitmap，没错，这就是迁移过程中用到的脏页位图，看其定义可以发现这是一个unsigned long *类型的全局变量，这个函数代码中首先给位图分配了内存空间，然后初始化为全0。memory_global_dirty_log_start()这个函数是开启脏页记录，实际上就是对内存页面进行写保护，这里略过不谈。migration_bitmap_sync()函数是同步脏页位图。那为什么要同步脏页位图呢？到底有多少脏页位图？我们下面来思考一下。</p>
<p>我们知道脏页就是修改了内存页面，kvm可以认为是qemu和kvm内核两个层次，I/O主要是在qemu层次进行的，那qemu层可能会有大量的内存的修改。那kvm内核有没有页面的修改呢？实际上，kvm内核也可能发生少量的内存的修改。这样，kvm就需要在两个层次都要维持各自的脏页位图，并且要将这两层的位图进行同步。通过分析代码，kvm两个层次我们可以认为维护了三套位图：一是kvm内核维护的脏页位图memslot-&gt;dirty_bitmap，这个位图记录kvm内核中的脏页，kvm内核中所有的对内存页面的修改都会对应着修改这个位图的位；二是qemu层次维护的一个脏页位图ram_list_phys_dirty[]，qemu层次对内存页面的修改都会相应的修改这个位图的位，并且它还会通过系统调用获取内核中的位图，并进行同步修改；三是迁移时具体使用的位图migration_btimap，这也是在qemu层的，但是它是复制ram_list_phys_dirty[]的相应位。</p>
<p><br><br>我们一项一项分析，先看看migration_bitmap是如何复制ram_list_phys_dirty[]的。这个复制的过程是在migration_bitmap_sync()函数实现的，先看代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">migration_bitmap_sync</span><span class="params">(<span class="keyword">void</span>)</span>  </span></div><div class="line">&#123;  </div><div class="line">    ........  </div><div class="line">    trace_migration_bitmap_sync_start();  </div><div class="line">    memory_global_sync_dirty_bitmap(get_system_memory());  </div><div class="line">  </div><div class="line">    QTAILQ_FOREACH(block, &amp;ram_list.blocks, next) &#123;  </div><div class="line">        <span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; block-&gt;length; addr += TARGET_PAGE_SIZE) &#123;  </div><div class="line">            <span class="keyword">if</span> (memory_region_test_and_clear_dirty(block-&gt;mr,  </div><div class="line">                                                   addr, TARGET_PAGE_SIZE,  </div><div class="line">                                                   DIRTY_MEMORY_MIGRATION)) &#123;  </div><div class="line">                migration_bitmap_set_dirty(block-&gt;mr, addr);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    trace_migration_bitmap_sync_end(migration_dirty_pages  </div><div class="line">                                    - num_dirty_pages_init);  </div><div class="line">    ........  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们分析这个函数，里面memory_global_sync_dirty_bitmap()就是将kvm内核中的位图同步到ram_list_phys_dirty[]中，这样就保证了现在ram_list_phys_dirty[]是完整的位图。memory_region_test_and_clear_dirty()是判断ram_list_phys_dirty[]该位是否置位，如果置位则清位，migration_bitmap_set_dirty()这个函数则是将migration_bitmap置位，这两个函数结合，就将ram_list_phys_dirty[]中为1的位复制到了migration_bitmap中。这里引申一点做个说明，迁移时，如果migration_bitmap相应位为1，就将页面保存，并将migration_bitmap位图相应位清位（migration_bitmap_find_and_reset_dirty()函数来实现的），这样就能保证migration_bitmap的准确性和实时性。</p>
<p>我们再分析一下前面提到的几个函数。memory_global_sync_dirty_bitmap()这里先不分析，后面在分析内核与qemu位图同步时候再分析。先看memory_region_test_and_clear_dirty()这个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">memory_region_test_and_clear_dirty</span><span class="params">(MemoryRegion *mr, hwaddr addr,  </span></span></div><div class="line">                                        hwaddr size, <span class="keyword">unsigned</span> client)  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">bool</span> ret;  </div><div class="line">    assert(mr-&gt;terminates);  </div><div class="line">    ret = cpu_physical_memory_get_dirty(mr-&gt;ram_addr + addr, size,  </div><div class="line">                                        <span class="number">1</span> &lt;&lt; client);  </div><div class="line">    <span class="keyword">if</span> (ret) &#123;  </div><div class="line">        cpu_physical_memory_reset_dirty(mr-&gt;ram_addr + addr,  </div><div class="line">                                        mr-&gt;ram_addr + addr + size,  </div><div class="line">                                        <span class="number">1</span> &lt;&lt; client);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> ret;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> cpu_physical_memory_get_dirty()  —&gt;  cpu_physical_memory_get_dirty_flag()  –&gt;  return ram_list.phys_dirty[addr &gt;&gt; TARGET_PAGE_BITS]  这就获得了ram_list.phys_dirty[]相应位的数值，然后判断如果是1，执行cpu_physical_memory_reset_dirty()  –&gt;  cpu_physical_memory_mask_dirty_range()  –&gt;  cpu_physical_memory_clear_dirty_flags()  –&gt;  ram_list.phys_dirty[addr &gt;&gt; TARGET_PAGE_BITS] &amp;= mask  ，这就清了相应位。</p>
<p>再看 migration_bitmap_set_dirty()这个函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">migration_bitmap_set_dirty</span><span class="params">(MemoryRegion *mr,  </span></span></div><div class="line">                                              <span class="keyword">ram_addr_t</span> offset)  </div><div class="line">&#123;  </div><div class="line">    <span class="keyword">bool</span> ret;  </div><div class="line">    <span class="keyword">int</span> nr = (mr-&gt;ram_addr + offset) &gt;&gt; TARGET_PAGE_BITS;  </div><div class="line">  </div><div class="line">    ret = test_and_set_bit(nr, migration_bitmap);  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (!ret) &#123;  </div><div class="line">        migration_dirty_pages++;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> ret;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 里面test_and_set_bit(nr, migration_bitmap)，这个函数将migration_bitmap置位。</p>
<p><br><br>分析完migration_bitmap是如何复制ram_list_phys_dirty[]的，我们再分析ram_list_phys_dirty[]是如何维护的。跟内核的同步这一部分前面也提到过，具体的后面讲解。这里就分析qemu中如何随时修改的这个位图。实际上修改这个位图的函数是cpu_physical_memory_set_dirty_flags()，qemu中大概有几十处直接或间接调用这个函数，在这里就不再一一讲解。</p>
<p>最后我们分析内核与qemu位图的同步以及内核中位图的维护。内核中的位图是memslot-&gt;dirty_bitmap，它的修改是通过mark_page_dirty_in_slot()这个函数，而mark_page_dirty_in_slot()这个函数又被kvm_write_guest_cached()和mark_page_dirty()这两个函数调用，kvm中大概有十几处调用了这两个函数，这里也不一一讲解了。</p>
<p>关于内核与qemu位图的同步我们前面提到过memory_global_sync_dirty_bitmap()这个函数，这个过程实际上是qemu主动发起的系统调用，具体分析其代码：<br>memory_global_sync_dirty_bitmap()  –&gt;  log_sync  –&gt;  kvm_log_sync() –&gt;  kvm_physical_sync_dirty_bitmap()，分析kvm_physical_sync_dirty_bitmap()这个函数，里面有几行代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">memset</span>(d.dirty_bitmap, <span class="number">0</span>, allocated_size);  </div><div class="line">  </div><div class="line">d.slot = mem-&gt;slot;  </div><div class="line">  </div><div class="line"><span class="keyword">if</span> (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &amp;d) == <span class="number">-1</span>) &#123;  </div><div class="line">    DPRINTF(<span class="string">"ioctl failed %d\n"</span>, errno);  </div><div class="line">    ret = <span class="number">-1</span>;  </div><div class="line">    <span class="keyword">break</span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">kvm_get_dirty_pages_log_range(section, d.dirty_bitmap);</div></pre></td></tr></table></figure></p>
<p>  我们可以看到，这就是ioctl系统调用，命令参数是KVM_GET_DIRTY_LOG，将内核中的位图复制到了d.dirty_bitmap中，后面又利用d来修改了ram_list_phys_dirty[]。既然是系统调用，那我们追踪到kvm内核中来看，找到kvm_vm_ioctl()函数，其中一段代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> KVM_GET_DIRTY_LOG: &#123;  </div><div class="line">    <span class="keyword">struct</span> kvm_dirty_log <span class="built_in">log</span>;  </div><div class="line">  </div><div class="line">    r = -EFAULT;  </div><div class="line">    <span class="keyword">if</span> (copy_from_user(&amp;<span class="built_in">log</span>, argp, <span class="keyword">sizeof</span> <span class="built_in">log</span>))  </div><div class="line">        <span class="keyword">goto</span> out;  </div><div class="line">    r = kvm_vm_ioctl_get_dirty_log(kvm, &amp;<span class="built_in">log</span>);  </div><div class="line">    <span class="keyword">break</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这一段代码里看一下kvm_vm_ioctl_get_dirty_log()函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_vm_ioctl_get_dirty_log</span><span class="params">(<span class="keyword">struct</span> kvm *kvm, <span class="keyword">struct</span> kvm_dirty_log *<span class="built_in">log</span>)</span>  </span></div><div class="line">&#123;  </div><div class="line">    ......  </div><div class="line">  </div><div class="line">    dirty_bitmap = memslot-&gt;dirty_bitmap;  </div><div class="line">    r = -ENOENT;  </div><div class="line">    <span class="keyword">if</span> (!dirty_bitmap)  </div><div class="line">        <span class="keyword">goto</span> out;  </div><div class="line">  </div><div class="line">    n = kvm_dirty_bitmap_bytes(memslot);  </div><div class="line">  </div><div class="line">    dirty_bitmap_buffer = dirty_bitmap + n / <span class="keyword">sizeof</span>(<span class="keyword">long</span>);  </div><div class="line">    <span class="built_in">memset</span>(dirty_bitmap_buffer, <span class="number">0</span>, n);  </div><div class="line">  </div><div class="line">    spin_lock(&amp;kvm-&gt;mmu_lock);  </div><div class="line">  </div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n / <span class="keyword">sizeof</span>(<span class="keyword">long</span>); i++) &#123;  </div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> mask;  </div><div class="line">        <span class="keyword">gfn_t</span> offset;  </div><div class="line">  </div><div class="line">        <span class="keyword">if</span> (!dirty_bitmap[i])  </div><div class="line">            <span class="keyword">continue</span>;  </div><div class="line">  </div><div class="line">        is_dirty = <span class="literal">true</span>;  </div><div class="line">  </div><div class="line">        mask = xchg(&amp;dirty_bitmap[i], <span class="number">0</span>);  </div><div class="line">        dirty_bitmap_buffer[i] = mask;  </div><div class="line">  </div><div class="line">        offset = i * BITS_PER_LONG;  </div><div class="line">        kvm_mmu_write_protect_pt_masked(kvm, memslot, offset, mask);  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">if</span> (is_dirty)  </div><div class="line">        kvm_flush_remote_tlbs(kvm);  </div><div class="line">  </div><div class="line">    spin_unlock(&amp;kvm-&gt;mmu_lock);  </div><div class="line">  </div><div class="line">    r = -EFAULT;  </div><div class="line">    <span class="keyword">if</span> (copy_to_user(<span class="built_in">log</span>-&gt;dirty_bitmap, dirty_bitmap_buffer, n))  </div><div class="line">        <span class="keyword">goto</span> out;  </div><div class="line">  </div><div class="line">    r = <span class="number">0</span>;  </div><div class="line">out:  </div><div class="line">    mutex_unlock(&amp;kvm-&gt;slots_lock);  </div><div class="line">    <span class="keyword">return</span> r;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数实际上是将memslot-&gt;dirty_bitmap最终通过copy_to_user()函数复制到了qemu层。这就实现了两个层次的位图同步。</p>
<hr>
<p><strong>转载请注明</strong>：原作者信息以及<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/虚拟机迁移/">虚拟机迁移<span class="article-category-count">3</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KVM/">KVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Migration/">Migration</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-kvm-exception"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170504/kvm-exception/">KVM异常处理流程源码简要分析</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170504/kvm-exception/" class="article-date">
	  <time datetime="2017-05-04T07:06:21.000Z" itemprop="datePublished">五月 4, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者:<a href="http://blog.csdn.net/mrbuffoon" target="_blank" rel="external">Mr_buffoon</a><br><strong>转载请注明</strong>：原作者信息以及<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec</a></p>
<hr>
<p>前面文章中我们讲过Qemu、KVM、Guest OS这三种层次以及对应的三种模式，也知道这三种模式之间的配合，下面上一张图回顾一下。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/4-1.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/4-1.png" width="450"></a><br>    <figcaption></figcaption><br></figure>  

<p>那现在我们就从代码的角度来讲一下这三层之间具体是如何配合的。</p>
<p>前面我们也讲过，首先Qemu层用户发起启动虚拟机命令后会通过ioctl调用进入到kvm内核层，完成相关初始化工作之后就运行虚拟机。</p>
<p>在kvm内核层中，当接收到ioctl的KVM_RUN命令后，实际调用的是kvm_arch_vcpu_ioctl_run()函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> KVM_RUN:  </div><div class="line">                   r = -EINVAL;  </div><div class="line">                   <span class="keyword">if</span> (arg)  </div><div class="line">                            <span class="keyword">goto</span> out;  </div><div class="line">                   r =kvm_arch_vcpu_ioctl_run(vcpu, vcpu-&gt;run);<span class="comment">//  </span></div><div class="line">                   trace_kvm_userspace_exit(vcpu-&gt;run-&gt;exit_reason,r);  </div><div class="line">                   <span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<p> 随后依次调用__vcpu_run()，vcpu_enter_guest()，kvm_x86_ops-&gt;run()，vmx_vcpu_run()，在vmx_vcpu_run()函数中有一段汇编语言被调用，这段汇编中执行了ASM_VMX_VMLAUNCH或者ASM_VMX_VMRESUME指令进入到客户模式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">asm</span>(  </div><div class="line">                   .........<span class="comment">//省略部分代码  </span></div><div class="line">                   <span class="comment">/* Enter guest mode */</span>  </div><div class="line">                   <span class="string">"jne 1f \n\t"</span>  </div><div class="line">                   __ex(ASM_VMX_VMLAUNCH)<span class="string">"\n\t"</span>  </div><div class="line">                   <span class="string">"jmp 2f \n\t"</span>  </div><div class="line">                   <span class="string">"1: "</span>__ex(ASM_VMX_VMRESUME) <span class="string">"\n\t"</span>  </div><div class="line">        ........<span class="comment">//省略部分代码  </span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>执行汇编指令进入到客户模式能够实现是因为KVM采用了硬件虚拟化的技术，比如Intel的芯片上提供了硬件支持并提供了相关一系列指令。再具体我也不知道了，查看Intel手册吧。那么进入到客户模式后，客户模式因为一些异常需要退出到KVM内核进行处理，这个是怎么实现的呢？</p>
<p>首先我们要说一下一个与异常处理相关的重要的数据结构VMCS。VMCS是虚拟机控制结构，他分为三部分：版本信息；终止标识符；VMCS数据域。其中VMCS数据域包含六类信息：客户状态域，宿主机状态域，VM-Entry控制域，VM-Execution控制域，VM-Exit控制域以及VM-Exit信息域。宿主机状态域保存了基本的寄存器信息，其中CS:RIP指向KVM中异常处理程序的入口地址，VM-Exit信息域中存放异常退出原因等信息。实际上，在KVM内核初始化vcpu时就将异常处理程序入口地址装载进VMCS中CS:RIP寄存器结构，当客户机发生异常时，就根据这个入口地址退出到内核模式执行异常处理程序。</p>
<p>KVM内核中异常处理总入口函数是vmx_handle_exit()函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">intvmx_handle_exit</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span>  </span></div><div class="line">&#123;  </div><div class="line">         <span class="keyword">struct</span> vcpu_vmx *vmx = to_vmx(vcpu);  </div><div class="line">         u32 exit_reason = vmx-&gt;exit_reason;  </div><div class="line">         ........<span class="comment">//一些处理，省略这部分代码  </span></div><div class="line">         <span class="keyword">if</span> (exit_reason &lt;kvm_vmx_max_exit_handlers  </div><div class="line">            &amp;&amp; kvm_vmx_exit_handlers[exit_reason])  </div><div class="line">                   returnkvm_vmx_exit_handlers[exit_reason](vcpu);  </div><div class="line">         <span class="keyword">else</span> &#123;  </div><div class="line">                   vcpu-&gt;run-&gt;exit_reason= KVM_EXIT_UNKNOWN;  </div><div class="line">                   vcpu-&gt;run-&gt;hw.hardware_exit_reason= exit_reason;  </div><div class="line">         &#125;  </div><div class="line">         <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该函数中，首先读取exit_reason，然后进行一些必要的处理，最后调用kvm_vmx_exit_handlers<a href="vcpu">exit_reason</a>，我们来看一下这个结构，实际上是一个函数指针数组，里面对应着所有的异常相应的异常处理函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span><span class="params">(*<span class="keyword">const</span> kvm_vmx_exit_handlers[])</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span> </span>= &#123;  </div><div class="line">         [EXIT_REASON_EXCEPTION_NMI]           = handle_exception,  </div><div class="line">         [EXIT_REASON_EXTERNAL_INTERRUPT]      = handle_external_interrupt,  </div><div class="line">         [EXIT_REASON_TRIPLE_FAULT]            = handle_triple_fault,  </div><div class="line">         [EXIT_REASON_NMI_WINDOW]          = handle_nmi_window,  </div><div class="line">         [EXIT_REASON_IO_INSTRUCTION]          = handle_io,  </div><div class="line">         [EXIT_REASON_CR_ACCESS]               = handle_cr,  </div><div class="line">         [EXIT_REASON_DR_ACCESS]               = handle_dr,  </div><div class="line">         [EXIT_REASON_CPUID]                   = handle_cpuid,  </div><div class="line">         [EXIT_REASON_MSR_READ]                = handle_rdmsr,  </div><div class="line">         [EXIT_REASON_MSR_WRITE]               = handle_wrmsr,  </div><div class="line">         [EXIT_REASON_PENDING_INTERRUPT]       = handle_interrupt_window,  </div><div class="line">         [EXIT_REASON_HLT]                     = handle_halt,  </div><div class="line">         [EXIT_REASON_INVD]                     = handle_invd,  </div><div class="line">         [EXIT_REASON_INVLPG]               = handle_invlpg,  </div><div class="line">         [EXIT_REASON_RDPMC]                   = handle_rdpmc,  </div><div class="line">         [EXIT_REASON_VMCALL]                  = handle_vmcall,  </div><div class="line">         [EXIT_REASON_VMCLEAR]                    = handle_vmclear,  </div><div class="line">         [EXIT_REASON_VMLAUNCH]                = handle_vmlaunch,  </div><div class="line">         [EXIT_REASON_VMPTRLD]                 = handle_vmptrld,  </div><div class="line">         [EXIT_REASON_VMPTRST]                 = handle_vmptrst,  </div><div class="line">         [EXIT_REASON_VMREAD]                  = handle_vmread,  </div><div class="line">         [EXIT_REASON_VMRESUME]                = handle_vmresume,  </div><div class="line">         [EXIT_REASON_VMWRITE]                 = handle_vmwrite,  </div><div class="line">         [EXIT_REASON_VMOFF]                   = handle_vmoff,  </div><div class="line">         [EXIT_REASON_VMON]                    = handle_vmon,  </div><div class="line">         [EXIT_REASON_TPR_BELOW_THRESHOLD]     = handle_tpr_below_threshold,  </div><div class="line">         [EXIT_REASON_APIC_ACCESS]             = handle_apic_access,  </div><div class="line">         [EXIT_REASON_APIC_WRITE]              = handle_apic_write,  </div><div class="line">         [EXIT_REASON_EOI_INDUCED]             = handle_apic_eoi_induced,  </div><div class="line">         [EXIT_REASON_WBINVD]                  = handle_wbinvd,  </div><div class="line">         [EXIT_REASON_XSETBV]                  = handle_xsetbv,  </div><div class="line">         [EXIT_REASON_TASK_SWITCH]             = handle_task_switch,  </div><div class="line">         [EXIT_REASON_MCE_DURING_VMENTRY]      = handle_machine_check,  </div><div class="line">         [EXIT_REASON_EPT_VIOLATION]         = handle_ept_violation,  </div><div class="line">         [EXIT_REASON_EPT_MISCONFIG]           = handle_ept_misconfig,  </div><div class="line">         [EXIT_REASON_PAUSE_INSTRUCTION]       = handle_pause,  </div><div class="line">         [EXIT_REASON_MWAIT_INSTRUCTION]       =handle_invalid_op,  </div><div class="line">         [EXIT_REASON_MONITOR_INSTRUCTION]     = handle_invalid_op,  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这里面比如handle_ept_violation就是影子页（EPT页）缺页异常的处理函数。</p>
<p>我们以handle_ept_violation()为例向下说明，依次调用kvm_mmu_page_fault()，vcpu-&gt;arch.mmu.page_fault()，tdp_page_fault()等后续函数完成缺页处理。</p>
<p>在这里，我们要注意kvm_vmx_exit_handlers<a href="vcpu">exit_reason</a>的返回值，比如当实际调用handle_ept_violation()时返回值大于0，就直接切回客户模式。但是有时候可能需要Qemu的协助。在实际调用（r = kvm_x86_ops-&gt;handle_exit(vcpu);）时，返回值大于0，那么就说明KVM已经处理完成，可以再次切换进客户模式，但如果返回值小于等于0，那就说明需要Qemu的协助，KVM会在run结构体中的exit_reason中记录退出原因，并进入到Qemu中进行处理。这个判断过程是在__vcpu_run()函数中进行的，实际是一个while循环。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="title">int__vcpu_run</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span>  </span></div><div class="line">&#123;  </div><div class="line">         ......<span class="comment">//省略部分代码  </span></div><div class="line">         r = <span class="number">1</span>;  </div><div class="line">         <span class="keyword">while</span> (r &gt; <span class="number">0</span>) &#123;  </div><div class="line">                   <span class="keyword">if</span> (vcpu-&gt;arch.mp_state ==KVM_MP_STATE_RUNNABLE &amp;&amp;  </div><div class="line">                       !vcpu-&gt;arch.apf.halted)  </div><div class="line">                            r =vcpu_enter_guest(vcpu);  </div><div class="line">                   <span class="keyword">else</span> &#123;  </div><div class="line">                            ......<span class="comment">//省略部分代码  </span></div><div class="line">                   &#125;  </div><div class="line">                   <span class="keyword">if</span> (r &lt;= <span class="number">0</span>)  </div><div class="line">                            <span class="keyword">break</span>;  </div><div class="line">           ......<span class="comment">//省略部分代码  </span></div><div class="line">         &#125;  </div><div class="line">         srcu_read_unlock(&amp;kvm-&gt;srcu,vcpu-&gt;srcu_idx);  </div><div class="line">         vapic_exit(vcpu);  </div><div class="line">         <span class="keyword">return</span> r;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面函数中vcpu_enter_guest()我们前面讲过，是在kvm内核中转入客户模式的函数，他处于while循环中，也就是如果不需要Qemu的协助，即r&gt;0，那就继续循环，然后重新切换进客户系统运行，如果需要Qemu的协助，那返回值r&lt;=0,退出循环，向上层返回r。</p>
<p>上面说的r一直往上层返回，直到kvm_vcpu_ioctl()函数中的<br>case KVM_RUN：<br>trace_kvm_userspace_exit(vcpu-&gt;run-&gt;exit_reason, r);<br>这一条语句就是将退出原因注入到Qemu层。<br>Qemu层这时候读取到ioctl的返回值，然后继续执行，就会判断有没有KVM的异常注入，这里其实我在前一篇文章中简单提及了一下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_cpu_exec</span><span class="params">(CPUArchState *env)</span>  </span></div><div class="line">&#123;  </div><div class="line">    .......  </div><div class="line">    <span class="keyword">do</span> &#123;  </div><div class="line">        ......  </div><div class="line">        run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN,<span class="number">0</span>);  </div><div class="line">        ......  </div><div class="line">        trace_kvm_run_exit(cpu-&gt;cpu_index,run-&gt;exit_reason);  </div><div class="line">        <span class="keyword">switch</span> (run-&gt;exit_reason) &#123;  </div><div class="line">        <span class="keyword">case</span> KVM_EXIT_IO:  </div><div class="line">            ......  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        <span class="keyword">case</span> KVM_EXIT_MMIO:  </div><div class="line">            ......  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        <span class="keyword">case</span> KVM_EXIT_IRQ_WINDOW_OPEN:  </div><div class="line">            .......  </div><div class="line">           <span class="keyword">break</span>;  </div><div class="line">        <span class="keyword">case</span> KVM_EXIT_SHUTDOWN:  </div><div class="line">            ......  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        <span class="keyword">case</span> KVM_EXIT_UNKNOWN:  </div><div class="line">            ......  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        <span class="keyword">case</span> KVM_EXIT_INTERNAL_ERROR:  </div><div class="line">            ......  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        <span class="keyword">default</span>:  </div><div class="line">            ......  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125; <span class="keyword">while</span> (ret == <span class="number">0</span>);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> trace_kvm_run_exit(cpu-&gt;cpu_index,run-&gt;exit_reason);这条语句就是接收内核注入的退出原因，后面switch语句进行处理，每一个case对应一种退出原因，这里你也可以自己添加的。因为也是在while循环中，处理完一次后又进行ioctl调用运行虚拟机并切换到客户模式，这就形成了一个完整的闭环。</p>
<hr>
<p> <strong>转载请注明</strong>：原作者信息以及<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/虚拟化基础/">虚拟化基础<span class="article-category-count">6</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KVM/">KVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtualization/">Virtualization</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-qemukvm-source2"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170504/qemukvm-source2/">Qemu-KVM虚拟机初始化及创建过程源码简要分析（二）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170504/qemukvm-source2/" class="article-date">
	  <time datetime="2017-05-04T07:02:19.000Z" itemprop="datePublished">五月 4, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者: <a href="http://blog.csdn.net/mrbuffoon" target="_blank" rel="external">Mr_buffoon</a><br><strong>转载请注明</strong>：原作者信息以及<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec</a></p>
<hr>
<p> 前面我们讲了KVM内核层创建及初始化虚拟机的一些工作过程，现在讲一下Qemu层的流程以及与KVM内核层的配合过程。<br>Qemu层是从vl.c中的main()函数开始的，这里通过在代码中添加一些注释的方式来进行讲解,中间省略了很多不重要或者我也没有搞清楚的代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, charchar **argv, charchar **envp)</span>  </span></div><div class="line">&#123;  </div><div class="line">    ......  </div><div class="line">    atexit(qemu_run_exit_notifiers);<span class="comment">//注册了Qemu的退出函数  </span></div><div class="line">    ......  </div><div class="line">    module_call_init(MODULE_INIT_QOM);<span class="comment">//初始化Qemu的各个模块，具体见下面注释  </span></div><div class="line">      </div><div class="line"><span class="comment">/* </span></div><div class="line">    module_call_init实际上是设计了一个函数链表ModuleTypeList，参数作为一个Type，相关的函数注册到这个函数链表上， </div><div class="line">    然后内部通过调用e-&gt;init()函数完成所有Type相关的设备的初始化。关于e-&gt;init()的具体内容后面再细说。 </div><div class="line">    Type总计有这些类型： </div><div class="line">    typedef enum &#123; </div><div class="line">    MODULE_INIT_BLOCK, </div><div class="line">    MODULE_INIT_MACHINE, </div><div class="line">    MODULE_INIT_QAPI, </div><div class="line">    MODULE_INIT_QOM, </div><div class="line">    MODULE_INIT_MAX </div><div class="line">    &#125; module_init_type; </div><div class="line">*/   </div><div class="line">  </div><div class="line">    qemu_add_opts(&amp;qemu_drive_opts);<span class="comment">//将各种函数指针（也就是操作）集合添加到链表中   </span></div><div class="line">    qemu_add_opts(&amp;qemu_chardev_opts);   </div><div class="line">    qemu_add_opts(&amp;qemu_device_opts);   </div><div class="line">    qemu_add_opts(&amp;qemu_netdev_opts);   </div><div class="line">    qemu_add_opts(&amp;qemu_net_opts);   </div><div class="line">    qemu_add_opts(&amp;qemu_rtc_opts);   </div><div class="line">    qemu_add_opts(&amp;qemu_global_opts);   </div><div class="line">    qemu_add_opts(&amp;qemu_mon_opts);   </div><div class="line">    qemu_add_opts(&amp;qemu_trace_opts);   </div><div class="line">    qemu_add_opts(&amp;qemu_option_rom_opts);   </div><div class="line">    qemu_add_opts(&amp;qemu_machine_opts);   </div><div class="line">    qemu_add_opts(&amp;qemu_boot_opts);   </div><div class="line">    qemu_add_opts(&amp;qemu_sandbox_opts);   </div><div class="line">    qemu_add_opts(&amp;qemu_add_fd_opts);   </div><div class="line">    qemu_add_opts(&amp;qemu_object_opts);   </div><div class="line">    qemu_add_opts(&amp;qemu_tpmdev_opts);   </div><div class="line">    qemu_add_opts(&amp;qemu_realtime_opts);  </div><div class="line">     ......   </div><div class="line">    init_clocks();<span class="comment">//时钟初始化相关   </span></div><div class="line">    rtc_clock = host_clock;   </div><div class="line">    ......   </div><div class="line">    module_call_init(MODULE_INIT_MACHINE);   </div><div class="line">    machine = find_default_machine();  </div><div class="line">    ......   </div><div class="line">    ......   </div><div class="line">    cpudef_init();<span class="comment">//初始化CPU def相关  </span></div><div class="line">     ......   </div><div class="line">    <span class="keyword">if</span> (log_mask) &#123;<span class="comment">//日志相关的设置，KVM对外的日志在这里配置   </span></div><div class="line">        <span class="keyword">int</span> mask;   </div><div class="line">        <span class="keyword">if</span> (log_file) &#123;   </div><div class="line">            qemu_set_log_filename(log_file);   </div><div class="line">        &#125;  </div><div class="line">        mask = qemu_str_to_log_mask(log_mask);   </div><div class="line">        <span class="keyword">if</span> (!mask) &#123;   </div><div class="line">            qemu_print_log_usage(<span class="built_in">stdout</span>);   </div><div class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);   </div><div class="line">        &#125;  </div><div class="line">        qemu_set_log(mask);  </div><div class="line">     &#125;   </div><div class="line">    ......   </div><div class="line">    configure_accelerator();<span class="comment">//进行虚拟机模拟器的配置，这里重点注意，它内部调用了accel_list[i].init()函数   </span></div><div class="line">  </div><div class="line"><span class="comment">/* </span></div><div class="line">    for (i = 0; i &lt; ARRAY_SIZE(accel_list); i++) &#123; </div><div class="line">        if (strcmp(accel_list[i].opt_name, buf) == 0) &#123; </div><div class="line">            if (!accel_list[i].available()) &#123; </div><div class="line">                printf("%s not supported for this target\n",accel_list[i].name); </div><div class="line">                continue; </div><div class="line">            &#125; </div><div class="line">            *(accel_list[i].allowed) = true; </div><div class="line">            ret = accel_list[i].init(); </div><div class="line">            if (ret &lt; 0) &#123; </div><div class="line">                init_failed = true; </div><div class="line">                fprintf(stderr, "failed to initialize %s: %s\n",accel_list[i].name,strerror(-ret)); </div><div class="line">               *(accel_list[i].allowed) = false;         </div><div class="line">            &#125; else &#123;             </div><div class="line">                accel_initialised = true;        </div><div class="line">            &#125;        </div><div class="line">            break;    </div><div class="line">         &#125; </div><div class="line">     &#125;  </div><div class="line">    //accel_list定义如下，实际上在kvm平台，我们就关注kvm_init即可。     </div><div class="line">    static struct &#123; </div><div class="line">        const char *opt_name;   </div><div class="line">        const char *name;   </div><div class="line">        int (*available)(void); </div><div class="line">        int (*init)(void); </div><div class="line">        bool *allowed;  </div><div class="line">    &#125; accel_list[] = &#123; </div><div class="line">       &#123; "tcg", "tcg", tcg_available, tcg_init, &amp;tcg_allowed &#125;, </div><div class="line">       &#123; "xen", "Xen", xen_available, xen_init, &amp;xen_allowed &#125;, </div><div class="line">       &#123; "kvm", "KVM", kvm_available, kvm_init, &amp;kvm_allowed &#125;, </div><div class="line">       &#123; "qtest", "QTest", qtest_available, qtest_init, &amp;qtest_allowed &#125;,  </div><div class="line">    &#125;;     </div><div class="line">    //kvm_init函数内首先打开用于用户层以及内核层交互的字符设备文件/dev/kvm，然后通过kvm_ioctl()与内核进行交互，比如     KVM_GET_API_VERSION，KVM_CREATE_VM等命令，其中KVM_CREATE_VM命令创建虚拟机并获得虚拟机句柄，后续kvm_arch_init()、 kvm_irqchip_create()等函数就可以通过kvm_vm_ioctl系统调用进行更进一步的一些配置。这些系统调用实际上是传递到内核层，由内核来完成相应的操作并返回到用户层，内核层的相关函数很多就是前一篇文章注册过的函数指针。 </div><div class="line">*/  </div><div class="line">    ......       </div><div class="line">    ......       </div><div class="line">    cpu_exec_init_all();<span class="comment">//记录CPU执行前的一些初始化工作     </span></div><div class="line">    ......      </div><div class="line">    ......       </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>前面提到过e-&gt;init()函数，并没有展开细说，现在来说一下这个函数。实际上e-&gt;init()函数是在machine_init(pc_machine_init)函数注册时注册到ModuleTypeList的ModuleEntry上的，module_call_init()针对X86架构时调用amchine_init(),随即调用pc_machine_init()函数，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pc_machine_init</span><span class="params">(<span class="keyword">void</span>)</span>  </span></div><div class="line">&#123;  </div><div class="line">    qemu_register_machine(&amp;pc_i440fx_machine_v1_5);  </div><div class="line">    qemu_register_machine(&amp;pc_i440fx_machine_v1_4);  </div><div class="line">    qemu_register_machine(&amp;pc_machine_v1_3);  </div><div class="line">    qemu_register_machine(&amp;pc_machine_v1_2);  </div><div class="line">    qemu_register_machine(&amp;pc_machine_v1_1);  </div><div class="line">    qemu_register_machine(&amp;pc_machine_v1_0);  </div><div class="line">    qemu_register_machine(&amp;pc_machine_v0_15);  </div><div class="line">    qemu_register_machine(&amp;pc_machine_v0_14);  </div><div class="line">    qemu_register_machine(&amp;pc_machine_v0_13);  </div><div class="line">    qemu_register_machine(&amp;pc_machine_v0_12);  </div><div class="line">    qemu_register_machine(&amp;pc_machine_v0_11);  </div><div class="line">    qemu_register_machine(&amp;pc_machine_v0_10);  </div><div class="line">    qemu_register_machine(&amp;isapc_machine);  </div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_XEN  </span></div><div class="line">    qemu_register_machine(&amp;xenfv_machine);  </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></div><div class="line">&#125;  </div><div class="line">  </div><div class="line">machine_init(pc_machine_init);</div></pre></td></tr></table></figure></p>
<p>注意这里注册的第一个为pc_i440fx_machine_v1_5，这个结构体定义为下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> QEMUMachine pc_i440fx_machine_v1_5 = &#123;  </div><div class="line">    .name = <span class="string">"pc-i440fx-1.5"</span>,  </div><div class="line">    .alias = <span class="string">"pc"</span>,  </div><div class="line">    .desc = <span class="string">"Standard PC (i440FX + PIIX, 1996)"</span>,  </div><div class="line">    .init = pc_init_pci,  </div><div class="line">    .hot_add_cpu = pc_hot_add_cpu,  </div><div class="line">    .max_cpus = <span class="number">255</span>,  </div><div class="line">    .is_default = <span class="number">1</span>,  </div><div class="line">    DEFAULT_MACHINE_OPTIONS,  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p> .init=pc_init_pci, pc_init_pci()即为初始化时候调用的函数，一路跟下去，其实最终调到pc_init1()这个函数。再看pc_init1()这个函数，这里面进行了内存（pc_memory_init）、cpu（pc_cpus_init）、中断等等多种的初始化，这里不细说，重点看cpu的初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">pc_cpus_init</span><span class="params">(<span class="keyword">const</span> charchar *cpu_model, DeviceState *icc_bridge)</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">int</span> i;  </div><div class="line">    X86CPU *cpu = <span class="literal">NULL</span>;  </div><div class="line">    Error *error = <span class="literal">NULL</span>;  </div><div class="line">  </div><div class="line">    <span class="comment">/* init CPUs */</span>  </div><div class="line">    <span class="keyword">if</span> (cpu_model == <span class="literal">NULL</span>) &#123;  </div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_X86_64  </span></div><div class="line">        cpu_model = <span class="string">"qemu64"</span>;  </div><div class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></div><div class="line">        cpu_model = <span class="string">"qemu32"</span>;  </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></div><div class="line">    &#125;  </div><div class="line">    current_cpu_model = cpu_model;  </div><div class="line">  </div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; smp_cpus; i++) &#123;  </div><div class="line">        cpu = pc_new_cpu(cpu_model, x86_cpu_apic_id_from_index(i),<span class="comment">//对每一个CPU进行初始化及创建  </span></div><div class="line">                         icc_bridge, &amp;error);  </div><div class="line">        <span class="keyword">if</span> (error) &#123;  </div><div class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, error_get_pretty(error));  </div><div class="line">            error_free(error);  </div><div class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">/* map APIC MMIO area if CPU has APIC */</span>  </div><div class="line">    <span class="keyword">if</span> (cpu &amp;&amp; cpu-&gt;env.apic_state) &#123;  </div><div class="line">        <span class="comment">/* <span class="doctag">XXX:</span> what if the base changes? */</span>  </div><div class="line">        sysbus_mmio_map_overlap(SYS_BUS_DEVICE(icc_bridge), <span class="number">0</span>,  </div><div class="line">                                APIC_DEFAULT_ADDRESS, <span class="number">0x1000</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 该函数内调用pc_new_cpu()函数对每一个CPU进行初始化，其后依次调用关系为：</p>
 <figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/3-1.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/3-1.png" width="450"></a><br>    <figcaption></figcaption><br></figure>

<p>下面来看kvm_init_vcpu()函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_init_vcpu</span><span class="params">(CPUState *cpu)</span>  </span></div><div class="line">&#123;  </div><div class="line">    KVMState *s = kvm_state;  </div><div class="line">    <span class="keyword">long</span> mmap_size;  </div><div class="line">    <span class="keyword">int</span> ret;  </div><div class="line">  </div><div class="line">    DPRINTF(<span class="string">"kvm_init_vcpu\n"</span>);  </div><div class="line">  </div><div class="line">    ret = kvm_vm_ioctl(s, KVM_CREATE_VCPU, (voidvoid *)kvm_arch_vcpu_id(cpu));<span class="comment">//通过ioctl调用向内核发起创建CPU请求，内核完成相关工作。  </span></div><div class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;  </div><div class="line">        DPRINTF(<span class="string">"kvm_create_vcpu failed\n"</span>);  </div><div class="line">        <span class="keyword">goto</span> err;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    cpu-&gt;kvm_fd = ret;  </div><div class="line">    cpu-&gt;kvm_state = s;  </div><div class="line">    cpu-&gt;kvm_vcpu_dirty = <span class="literal">true</span>;  </div><div class="line">  </div><div class="line">    mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, <span class="number">0</span>);<span class="comment">//通过ioctl调用获取内核与用户层共享的内存大小，这部分内存以内存映射的方式进行共享。  </span></div><div class="line">    <span class="keyword">if</span> (mmap_size &lt; <span class="number">0</span>) &#123;  </div><div class="line">        ret = mmap_size;  </div><div class="line">        DPRINTF(<span class="string">"KVM_GET_VCPU_MMAP_SIZE failed\n"</span>);  </div><div class="line">        <span class="keyword">goto</span> err;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    cpu-&gt;kvm_run = mmap(<span class="literal">NULL</span>, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,<span class="comment">//获取内存大小后，用户层进行共享内存映射。  </span></div><div class="line">                        cpu-&gt;kvm_fd, <span class="number">0</span>);  </div><div class="line">    <span class="keyword">if</span> (cpu-&gt;kvm_run == MAP_FAILED) &#123;  </div><div class="line">        ret = -errno;  </div><div class="line">        DPRINTF(<span class="string">"mmap'ing vcpu state failed\n"</span>);  </div><div class="line">        <span class="keyword">goto</span> err;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> (s-&gt;coalesced_mmio &amp;&amp; !s-&gt;coalesced_mmio_ring) &#123;  <span class="comment">//mmio相关的一部分共享内存设置  </span></div><div class="line">        s-&gt;coalesced_mmio_ring =  </div><div class="line">            (voidvoid *)cpu-&gt;kvm_run + s-&gt;coalesced_mmio * PAGE_SIZE;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    ret = kvm_arch_init_vcpu(cpu);<span class="comment">//相关初始化  </span></div><div class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;  </div><div class="line">        qemu_register_reset(kvm_reset_vcpu, cpu);  </div><div class="line">        kvm_arch_reset_vcpu(cpu);  </div><div class="line">    &#125;  </div><div class="line">err:  </div><div class="line">    <span class="keyword">return</span> ret;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>回到上面一些列调用中的qemu_kvm_cpu_thread_fn()函数中，在调用了kvm_init_vcpu()函数完成cpu的初始化之后，又调用kvm_cpu_exec()函数运行cpu，也就是运行了整个虚拟机。<br>我们来看kvm_cpu_exec()这个函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_cpu_exec</span><span class="params">(CPUArchState *env)</span>  </span></div><div class="line">&#123;  </div><div class="line">    .......  </div><div class="line">    <span class="keyword">do</span>&#123;   </div><div class="line">        run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, <span class="number">0</span>);  </div><div class="line">  </div><div class="line">       .......  </div><div class="line">        trace_kvm_run_exit(cpu-&gt;cpu_index, run-&gt;exit_reason);  </div><div class="line">        <span class="keyword">switch</span> (run-&gt;exit_reason) &#123;  </div><div class="line">        <span class="keyword">case</span> KVM_EXIT_IO:  </div><div class="line">            ......  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        <span class="keyword">case</span> KVM_EXIT_MMIO:  </div><div class="line">            ......  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        <span class="keyword">case</span> KVM_EXIT_IRQ_WINDOW_OPEN:  </div><div class="line">            ......  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        <span class="keyword">case</span> KVM_EXIT_SHUTDOWN:  </div><div class="line">            ......  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        <span class="keyword">case</span> KVM_EXIT_UNKNOWN:  </div><div class="line">            ......  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        <span class="keyword">case</span> KVM_EXIT_INTERNAL_ERROR:  </div><div class="line">           ......  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        <span class="keyword">default</span>:  </div><div class="line">            ......  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125; <span class="keyword">while</span> (ret == <span class="number">0</span>);  </div><div class="line">  </div><div class="line">    .......  </div><div class="line">    <span class="keyword">return</span> ret;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先一个kvm_vcpu_ioctl系统调用，向内核请求运行虚拟机，然后内核运行虚拟机，kvm_cpu_exec()内是有一个while循环，只要是没有错误就会不断运行不会终止，后面的switch语句实际上是接收内核传来的退出原因，因为I/O等是需要Qemu即用户层来完成的，这样虚拟机运行时内核层遇到I/O等就需要退出到Qemu层并记录退出原因，Qemu根据退出原因执行相关操作，完成后再次执行ioctl操作转到内核层继续运行虚拟机。关于异常退出的具体流程下篇文章再详细讲解。<br><br></p>
<p>关于内存初始化相关工作，在之前提到过的kvm初始化主函数kvm_init()函数里，依次调用：<br>    memory_listener_register(&amp;kvm_memory_listener, &amp;address_space_memory);<br>    listener_add_address_space(listener, as);<br>    listener-&gt;region_add(listener, &amp;section);<br>    .region_add = kvm_region_add,<br>    kvm_set_phys_mem(section, true);<br>    err = kvm_set_user_memory_region(s, mem);<br>    return kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &amp;mem);<br>    这些函数依次调用，基本完成内存初始化过程，这里最后的ioctl调用是设置影子页表信息以及设置页面访问权限等。<br><br></p>
<p>最终，在内核与用户层的配合下完成整个虚拟机的创建和初始化工作，并运行虚拟机。</p>
<hr>
<p><strong>转载请注明</strong>：原作者信息以及<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/虚拟化基础/">虚拟化基础<span class="article-category-count">6</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KVM/">KVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/QEMU/">QEMU</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtualization/">Virtualization</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-qemukvm-source1"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170504/qemukvm-source1/">Qemu-KVM虚拟机初始化及创建过程源码简要分析（一）</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170504/qemukvm-source1/" class="article-date">
	  <time datetime="2017-05-04T07:01:06.000Z" itemprop="datePublished">五月 4, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>作者:</strong> <a href="http://blog.csdn.net/mrbuffoon" target="_blank" rel="external">Mr_buffoon</a></p>
<p><strong>转载请注明</strong>：原作者信息以及<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec</a></p>
<hr>
<p> 我们知道，Qemu-KVM实际上包括Qemu和KVM两部分，那么在创建以及初始化虚拟机时，实际上也是在这两部分进行的。</p>
<p>KVM实际上就是kvm内核模块，包括kvm.ko、kvm-intel.ko、kvm-amd.ko三部分，后两部分分别对应Intel体系的VMX技术以及AMD体系的SVM技术。</p>
<p>首先，我们需要加载模块，当我们加载kvm-xxx.ko模块时，会调用对应的module_init()函数，然后调用vmx_init()或者svm_init()函数，最后进入到统一的kvm.ko模块中的kvm_init()函数，现在正式开始进行虚拟机的初始化工作。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/2-1.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/2-1.png" width="450"></a><br>    <figcaption></figcaption><br></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">module_init(vmx_init)    <span class="comment">//位于vmx.c文件</span></div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">vmx_init</span><span class="params">(<span class="keyword">void</span>)</span>    <span class="comment">//位于vmx.c文件  </span></span></div><div class="line">&#123;  </div><div class="line">       ..............<span class="comment">//省略部分代码  </span></div><div class="line">       r= kvm_init(&amp;vmx_x86_ops, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> vcpu_vmx),  </div><div class="line">                   __alignof__(<span class="keyword">struct</span> vcpu_vmx),THIS_MODULE);  </div><div class="line">       ................<span class="comment">//省略部分代码  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kvm_init</span><span class="params">(voidvoid *opaque, <span class="keyword">unsigned</span> vcpu_size,<span class="keyword">unsigned</span> vcpu_align,  </span></span></div><div class="line">                <span class="keyword">struct</span> <span class="keyword">module</span> *<span class="keyword">module</span>)    <span class="comment">//位于kvm_main.c文件  </span></div><div class="line">&#123;  </div><div class="line">       ......................<span class="comment">//省略部分代码  </span></div><div class="line">       r= kvm_arch_init(opaque);  </div><div class="line">       ........................<span class="comment">//省略部分代码  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 在进入到kvm_init()函数后，进行了很多初始化的相关工作，这里单独强调一下kvm_arch_init()函数。<br>    在vmx.c文件中声明并定义了一个结构体vmx_x86_ops，这是函数指针的集合，其实就是各种操作的一个集合。内部很多函数是后续的初始化工作需要具体调用到的，比如很多Qemu层的ioctl调用到内核层实际上就是执行这内部的一些函数。具体的内容如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> kvm_x86_ops vmx_x86_ops = &#123;  </div><div class="line">       .cpu_has_kvm_support= cpu_has_kvm_support,  </div><div class="line">       .disabled_by_bios= vmx_disabled_by_bios,  </div><div class="line">       .hardware_setup= hardware_setup,  </div><div class="line">       .hardware_unsetup= hardware_unsetup,  </div><div class="line">       .check_processor_compatibility= vmx_check_processor_compat,  </div><div class="line">       .hardware_enable= hardware_enable,  </div><div class="line">       .hardware_disable= hardware_disable,  </div><div class="line">       .cpu_has_accelerated_tpr= report_flexpriority,  </div><div class="line">   </div><div class="line">       .vcpu_create= vmx_create_vcpu,  </div><div class="line">       .vcpu_free= vmx_free_vcpu,  </div><div class="line">       .vcpu_reset= vmx_vcpu_reset,  </div><div class="line">   </div><div class="line">       .prepare_guest_switch= vmx_save_host_state,  </div><div class="line">       .vcpu_load= vmx_vcpu_load,  </div><div class="line">       .vcpu_put= vmx_vcpu_put,  </div><div class="line">   </div><div class="line">       .update_db_bp_intercept= update_exception_bitmap,  </div><div class="line">       .get_msr= vmx_get_msr,  </div><div class="line">       .set_msr= vmx_set_msr,  </div><div class="line">       .get_segment_base= vmx_get_segment_base,  </div><div class="line">       .get_segment= vmx_get_segment,  </div><div class="line">       .set_segment= vmx_set_segment,  </div><div class="line">       .get_cpl= vmx_get_cpl,  </div><div class="line">       .get_cs_db_l_bits= vmx_get_cs_db_l_bits,  </div><div class="line">       .decache_cr0_guest_bits= vmx_decache_cr0_guest_bits,  </div><div class="line">       .decache_cr3= vmx_decache_cr3,  </div><div class="line">       .decache_cr4_guest_bits= vmx_decache_cr4_guest_bits,  </div><div class="line">       .set_cr0= vmx_set_cr0,  </div><div class="line">       .set_cr3= vmx_set_cr3,  </div><div class="line">       .set_cr4= vmx_set_cr4,  </div><div class="line">       .set_efer= vmx_set_efer,  </div><div class="line">       .get_idt= vmx_get_idt,  </div><div class="line">       .set_idt= vmx_set_idt,  </div><div class="line">       .get_gdt= vmx_get_gdt,  </div><div class="line">       .set_gdt= vmx_set_gdt,  </div><div class="line">       .set_dr7= vmx_set_dr7,  </div><div class="line">       .cache_reg= vmx_cache_reg,  </div><div class="line">       .get_rflags= vmx_get_rflags,  </div><div class="line">       .set_rflags= vmx_set_rflags,  </div><div class="line">       .fpu_activate= vmx_fpu_activate,  </div><div class="line">       .fpu_deactivate= vmx_fpu_deactivate,  </div><div class="line">   </div><div class="line">       .tlb_flush= vmx_flush_tlb,  </div><div class="line">   </div><div class="line">       .run= vmx_vcpu_run,  </div><div class="line">       .handle_exit= vmx_handle_exit,  </div><div class="line">       .skip_emulated_instruction= skip_emulated_instruction,  </div><div class="line">       .set_interrupt_shadow= vmx_set_interrupt_shadow,  </div><div class="line">       .get_interrupt_shadow= vmx_get_interrupt_shadow,  </div><div class="line">       .patch_hypercall= vmx_patch_hypercall,  </div><div class="line">       .set_irq= vmx_inject_irq,  </div><div class="line">       .set_nmi= vmx_inject_nmi,  </div><div class="line">       .queue_exception= vmx_queue_exception,  </div><div class="line">       .cancel_injection= vmx_cancel_injection,  </div><div class="line">       .interrupt_allowed= vmx_interrupt_allowed,  </div><div class="line">       .nmi_allowed= vmx_nmi_allowed,  </div><div class="line">       .get_nmi_mask= vmx_get_nmi_mask,  </div><div class="line">       .set_nmi_mask= vmx_set_nmi_mask,  </div><div class="line">       .enable_nmi_window= enable_nmi_window,  </div><div class="line">       .enable_irq_window= enable_irq_window,  </div><div class="line">       .update_cr8_intercept= update_cr8_intercept,  </div><div class="line">       .set_virtual_x2apic_mode= vmx_set_virtual_x2apic_mode,  </div><div class="line">       .vm_has_apicv= vmx_vm_has_apicv,  </div><div class="line">       .load_eoi_exitmap= vmx_load_eoi_exitmap,  </div><div class="line">       .hwapic_irr_update= vmx_hwapic_irr_update,  </div><div class="line">       .hwapic_isr_update= vmx_hwapic_isr_update,  </div><div class="line">       .sync_pir_to_irr= vmx_sync_pir_to_irr,  </div><div class="line">       .deliver_posted_interrupt= vmx_deliver_posted_interrupt,  </div><div class="line">   </div><div class="line">       .set_tss_addr= vmx_set_tss_addr,  </div><div class="line">       .get_tdp_level= get_ept_level,  </div><div class="line">       .get_mt_mask= vmx_get_mt_mask,  </div><div class="line">   </div><div class="line">       .get_exit_info= vmx_get_exit_info,  </div><div class="line">   </div><div class="line">       .get_lpage_level= vmx_get_lpage_level,  </div><div class="line">   </div><div class="line">       .cpuid_update= vmx_cpuid_update,  </div><div class="line">   </div><div class="line">       .rdtscp_supported= vmx_rdtscp_supported,  </div><div class="line">       .invpcid_supported= vmx_invpcid_supported,  </div><div class="line">   </div><div class="line">       .set_supported_cpuid= vmx_set_supported_cpuid,  </div><div class="line">   </div><div class="line">       .has_wbinvd_exit= cpu_has_vmx_wbinvd_exit,  </div><div class="line">   </div><div class="line">       .set_tsc_khz= vmx_set_tsc_khz,  </div><div class="line">       .read_tsc_offset= vmx_read_tsc_offset,  </div><div class="line">       .write_tsc_offset= vmx_write_tsc_offset,  </div><div class="line">       .adjust_tsc_offset= vmx_adjust_tsc_offset,  </div><div class="line">       .compute_tsc_offset= vmx_compute_tsc_offset,  </div><div class="line">       .read_l1_tsc= vmx_read_l1_tsc,  </div><div class="line">   </div><div class="line">       .set_tdp_cr3= vmx_set_cr3,  </div><div class="line">   </div><div class="line">       .check_intercept= vmx_check_intercept,  </div><div class="line">       .handle_external_intr= vmx_handle_external_intr,  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个结构体作为参数传递到kvm_init()函数，再传递到kvm_arch_init()函数，再传递到全局变量kvm_x86_ops中，注册各种操作函数，后续可以调用。随后还进行了一些内部<strong>数据结构</strong>以及定时器、调试信息等的一些初始化工作。与此同时，qemu层也会进行大部分的初始化工作，这一部分后一篇再讲。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/2-2.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/2-2.png" width="450"></a><br>    <figcaption></figcaption><br></figure>


<hr>
<p><strong>转载请注明</strong>：原作者信息以及<a href="http://www.csyssec.org/about/" target="_blank" rel="external">CSysSec</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/虚拟化基础/">虚拟化基础<span class="article-category-count">6</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KVM/">KVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/QEMU/">QEMU</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtualization/">Virtualization</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-keylogger"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/20170401/keylogger/">Keylogger检测</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170401/keylogger/" class="article-date">
	  <time datetime="2017-04-01T03:12:56.000Z" itemprop="datePublished">四月 1, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>Source：<a href="https://www.lastline.com/labsblog/detecting-keyloggers-on-dynamic-analysis-systems/" target="_blank" rel="external">https://www.lastline.com/labsblog/detecting-keyloggers-on-dynamic-analysis-systems/</a><br>Author： <a href="https://www.lastline.com/author/clemens/" target="_blank" rel="external">Clemens Kolbitsch</a></p>
<pre><code>Clemens is a Security Researcher and engine developer at Lastline. As a lead-developer of Anubis, he has gained profound expertise in analyzing current, malicious code found in the wild. He has observed various trends in the malware community and successfully published peer-reviewed research papers. In the past, he also investigated offensive technologies presenting results at conferences such as BlackHat.
</code></pre><hr>
<p>One notorious functionality present in many variants of today’s advanced malware is the ability to steal sensitive user information. Taking control of a targeted machine, an adversary has basically unlimited abilities to secretly monitor the actions performed by an unsuspecting victim who uses the infected machine. The type of data stored on a typical machine, and to which the attacker has access to, ranges from user account credentials (such as usernames and passwords), to financial data (such as credit card numbers or transaction secrets), and even personal data (such as social security numbers).</p>
<p>Very often, malware is specialized in capturing and identifying different types of information typed by the victim, allowing the collection of very specific information in which the attacker is interested. Typical examples are information entered in a login form for a specific URL, or values that resemble social security numbers (SSN) or credit card numbers.</p>
<p>Automatic identification of this type of attack using traditional dynamic analysis (inside a sandbox) is tricky, as most activity requires a user to trigger the attack. Such a trigger could be using username and password to authenticate to a service, or entering user-sensitive information into an application or website.</p>
<p>In this post, we describe some of the ways attackers manage to collect sensitive information on an infected machine and how Lastline’s high-resolution dynamic analysis engine is able to trigger and detect this type of malware.</p>
<h2 id="How-Keyloggers-Capture-Data"><a href="#How-Keyloggers-Capture-Data" class="headerlink" title="How Keyloggers Capture Data"></a>How Keyloggers Capture Data</h2><p>When looking at keyloggers, we can typically distinguish three basic types: User-mode keyloggers, kernel-mode keyloggers and hardware-based keyloggers. In this post, we will focus on the first two types – software-based keyloggers. Hardware-based keyloggers work by intercepting data sent from external devices (such as keyboard or mouse) to the computer hardware, and are thus outside the reach of most remote attackers.</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/kerlogger1.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/kerlogger1.png" width="450"></a><br>    <figcaption>Overview of keylogger methods</figcaption><br></figure>


<p>In user-mode keyloggers, a very common approach used to steal information typed by the user is through the use of the windows API SetWindowsHook. This API can be used to intercept events from the system, such as keyboard and mouse activity. When the to-be-intercepted action is triggered, a function of the attacker’s choosing is executed. Another user-mode method for capturing keystrokes that we found in many malware variants consists of continuously checking the system’s keyboard state using the GetAsyncKeyState or GetKeyState API functions. Different from the first method, which notifies you at every keyboard event, the attacker here needs to actively monitor which keys are pressed.</p>
<p>Kernel-mode keyloggers are more powerful than their user-mode counterparts, as they work with higher privileges, but are inherently more complex to implement. This type of  keylogger uses filter drivers to intercept keystrokes received from the keyboard or modify internal Windows kernel structures in order to capture input data. The complexity and mostly-undocumented nature of kernel code can lead to malfunction of the system if a sample is executed on an unsupported system, making user-mode keyloggers a more prominent approach.</p>
<h2 id="Analyzing-Keylogger-Software"><a href="#Analyzing-Keylogger-Software" class="headerlink" title="Analyzing Keylogger Software"></a>Analyzing Keylogger Software</h2><p>As mentioned earlier, when executing malware with keylogging abilities on a traditional analysis system, this functionality typically remains unnoticed. This is because, unless a user triggers specific actions, the malware will not be able to capture anything during the analysis.</p>
<p>To reveal this type of behavior during the automated analysis of a sample, the system needs to mimic user interactions such as keyboard typing and mouse movement. Interestingly, this is far from simple since some malware families only capture data when the key is pressed within a specific application or window, such as Internet Explorer or Firefox, for example.</p>
<p>Further, the analysis framework must be able to identify the type of application and/or information that is relevant for the malware under analysis. For instance, if a keylogger only targets information on financial transactions (such as in a breach of Point-of-Sale terminals late last year), injecting other user information would not reveal any interesting behavior. If the sandbox fails to identify the data in which the attacker is interested, the keylogger remains inactive, disguising itself from the analysis system.</p>
<h2 id="High-Resolution-Analysis-of-Keyloggers"><a href="#High-Resolution-Analysis-of-Keyloggers" class="headerlink" title="High-Resolution Analysis of Keyloggers"></a>High-Resolution Analysis of Keyloggers</h2><p>The Lastline high-resolution dynamic analysis engine has the ability to simulate specific user interactions during the analysis of a sample. Additionally, the system identifies the type of data that the malware sample is searching for and can simulate user behavior accordingly. For example, the system instruments a virtual user to use fake credit card information to do financial transactions, post user credentials to various services, or use email addresses in a way that might attract the attacker’s attention.</p>
<p>Once the keylogger starts collecting the injected data, the system tracks how the malware under analysis uses the stolen information, which gives vital information on the attacker’s goals. For example, the system tracks if the stolen data is written to the file-system or is sent to the attacker using a command-and-control channel.</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/keylogger2.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/keylogger2.png" width="450"></a><br>    <figcaption>Chewbacca analysis report</figcaption><br></figure>



<h2 id="Chasing-Chewbacca-with-Lastline"><a href="#Chasing-Chewbacca-with-Lastline" class="headerlink" title="Chasing Chewbacca with Lastline"></a>Chasing Chewbacca with Lastline</h2><p>Chewbacca [2] is a trojan used in a Point-of-Sale malware operation to log keyboard data of certain systems [3]. Besides capturing keyboard activity, the malware can also scan the memory of other processes for credit card numbers using regular expressions. Clearly, all of this happens without any signs of infections visible to the user.</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/keylogger3.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/keylogger3.png" width="450"></a><br>    <figcaption>Windows desktop showing no signs of the keylogger</figcaption><br></figure>

<p>When executed, the malware creates a copy of itself named spoolsv.exe under the Windows Startup folder. After that, it will start capturing all keyboard events from the system, logging them to a file named system.log.</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/keylogger4.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/keylogger4.png" width="450"></a><br>    <figcaption>Chewbacca data collection hook installation</figcaption><br></figure>

<p>The above figure shows the code used by Chewbacca to install the hook procedure on the system after its execution. We can see that the malware uses the Windows API SetWindowsHookEx to install the hook, with hook type WH_KEYBOARD_LL, which is used to capture low-level keyboard input. Also, to capture all keystrokes from the system, the malware sets parameter dwThreadId=0, which will install the hook on all existing threads running on the same desktop.</p>
<p>During its execution, whenever a keypress event happens, the callback KEYLOG_$$_HOOKPROC$LONGINT$LONGINT$LONGINT$$LONGINT will record the keys pressed along with the window title on which the keypress was recorded. Additionally, the software records when the window focus changes, logging the captured information to system.log.</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/keylogger5.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/keylogger5.png" width="450"></a><br>    <figcaption>The Lastline analysis engine gives access to files generated and network traffic captured during the analysis</figcaption><br></figure>

<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/keylogger6.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/keylogger6.png" width="450"></a><br>    <figcaption>Captured data shown in the analysis report</figcaption><br></figure>

<p>When analyzing Chewbacca inside Lastline’s high-resolution analysis engine, the system identifies the keylogging functionality, clearly marking it in the report overview. Additionally, the report contains detailed examples of data the malware sample extracted, as can be seen in the figure above.</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/keylogger7.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/keylogger7.png" width="450"></a><br>    <figcaption>Text content of the data captured by the keylogger into file C:Users…Tempsystem.log</figcaption><br></figure>

<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/keylogger8.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/keylogger8.png" width="450"></a><br>    <figcaption>Raw file content of the data captured by the keylogger into file C:Users…Tempsystem.log</figcaption><br></figure>


<p>As one can see, the report even shows examples of the sensitive data that was targeted by the attacker, which, in this case, includes credit card information and user passwords.</p>
<p>Conclusion<br>Keylogging functionality in advanced malware is a severe threat to user data, but traditional analysis systems are often blind to this vector of attack. Lastline’s high-resolution analysis engine tackles this threat in two ways: First, the analysis engine identifies that a keylogger was installed on the victim machine and identifies the type of information the attacker is targeting. Second, the system uses the collected information to instrument a virtual user to inject specific data to trigger the keylogger’s functionality. The injected data is then tracked throughout the analysis system to monitor how the malware processes (and potentially leaks) the stolen information.</p>
<p>REFERENCES:</p>
<p>[1] <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms644990%28v=vs.85%29.aspx" target="_blank" rel="external">http://msdn.microsoft.com/en-us/library/windows/desktop/ms644990%28v=vs.85%29.aspx</a></p>
<p>[2] <a href="https://www.virustotal.com/en/file/31d4e1b2e67706fda51633b450b280554c0c4eb595b3a0606ef4ab8421a04dc9/analysis/" target="_blank" rel="external">https://www.virustotal.com/en/file/31d4e1b2e67706fda51633b450b280554c0c4eb595b3a0606ef4ab8421a04dc9/analysis/</a></p>
<p>[3] <a href="https://blogs.rsa.com/rsa-uncovers-new-pos-malware-operation-stealing-payment-card-personal-information/" target="_blank" rel="external">https://blogs.rsa.com/rsa-uncovers-new-pos-malware-operation-stealing-payment-card-personal-information/</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/恶意代码/">恶意代码<span class="article-category-count">14</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Malware/">Malware</a></li></ul>

      
    </footer>
  </div>
  
</article>

<!-- Table of Contents -->

  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/8/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><a class="extend next" rel="next" href="/page/10/">下一页</a>
  </nav>

</section>
          <aside id="sidebar">
  
    <div class="widget-wrap" style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 75%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 42px;" placeholder=" 搜索…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="搜索">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(无标题)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">集思广益</h3>
      <p>我们推崇的是黑客与分享精神，如果您觉得本站对您有帮助，不妨自己也参与进来共同建设，期待您能推荐好文章或投稿至本站，
让更多人受益。本站热烈欢迎志同道合者与志愿者参与本站的共同维护和建设，您可通过微博[@Diting0x](http://weibo.com/diting0x)联系我</p>
       <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a href="null" title="Words"><i class="fa fa-words" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a> </li> 
		<li class="widget-si-facebook"><a href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>


        	</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>最新推荐</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170807/bypassaslr-analysis/">ASLR保护机制被突破的攻击技术分析</a></h6>
          <!--  <span>八月 7, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170807/offensivesec/">offensivesec</a></h6>
          <!--  <span>八月 7, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170605/memorysafety-defense/">内存持久战之防御措施</a></h6>
          <!--  <span>六月 5, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170531/ravel/">会找漏洞的时光机-Pinpointing Vulnerabilities</a></h6>
          <!--  <span>五月 31, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170513/memorysafety-attack/">内存支持战之攻击模型</a></h6>
          <!--  <span>五月 13, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170513/memorysafety/">内存持久战之内存安全性</a></h6>
          <!--  <span>五月 13, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170508/intro-aslr/">系统安全浅薄知识系列(一)-ASLR</a></h6>
          <!--  <span>五月 8, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170505/cfi-mathias/">控制流完整性-Mathias Payer</a></h6>
          <!--  <span>五月 5, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170505/vmi-xenproject/">虚拟机自省技术-一个有新商业应用的安全性创造</a></h6>
          <!--  <span>五月 5, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/cf-exception/">控制流分支指令上的控制流处理器异常(单步执行)</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/cfi-development/">控制流完整性的发展历程</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/cfi-ccs05/">控制流完整性-CCS05年论文</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/rop-intel/">因特尔发布新的技术规范去防御 ROP 攻击</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/ropjop-research/">ROP/JOP攻击与防御最新研究进展</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/nmi-virtual/">虚拟化技术的NMI窗口退出</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/20170504/lbr-ret2dir/">利用LBR特性检测ret2dir攻击</a></h6>
          <!--  <span>五月 4, 2017</span> -->
            </div>

          </li>
        
      </ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类导航</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hypervisor安全/">Hypervisor安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/主流会议/">主流会议</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/二进制分析/">二进制分析</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内存安全/">内存安全</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内核安全/">内核安全</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/内核完整性/">内核完整性</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/博士之路/">博士之路</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/名人课堂/">名人课堂</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学术专家/">学术专家</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/安全圈子/">安全圈子</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/恶意代码/">恶意代码</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/漏洞利用/">漏洞利用</a><span class="category-list-count">14</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/硬件特性/">硬件特性</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/硬件虚拟化/">硬件虚拟化</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统内核/">系统内核</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统安全/">系统安全</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/系统安全科普/">系统安全科普</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟化原理/">虚拟化原理</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟化基础/">虚拟化基础</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟化综合/">虚拟化综合</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机快照/">虚拟机快照</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机监控/">虚拟机监控</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机记录与重放/">虚拟机记录与重放</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/虚拟机迁移/">虚拟机迁移</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签导航</h3>
    <div class="widget tagcloud">
      <a href="/tags/ASLR/" style="font-size: 12.31px;">ASLR</a> <a href="/tags/ASPLOS/" style="font-size: 10px;">ASPLOS</a> <a href="/tags/Attack/" style="font-size: 12.31px;">Attack</a> <a href="/tags/Binary/" style="font-size: 10.77px;">Binary</a> <a href="/tags/CFI/" style="font-size: 12.31px;">CFI</a> <a href="/tags/Cloud/" style="font-size: 10px;">Cloud</a> <a href="/tags/Compiler/" style="font-size: 10px;">Compiler</a> <a href="/tags/Conference/" style="font-size: 12.31px;">Conference</a> <a href="/tags/Conferences/" style="font-size: 10px;">Conferences</a> <a href="/tags/Course/" style="font-size: 13.08px;">Course</a> <a href="/tags/Exception/" style="font-size: 10px;">Exception</a> <a href="/tags/Exploit/" style="font-size: 16.92px;">Exploit</a> <a href="/tags/Forensics/" style="font-size: 10px;">Forensics</a> <a href="/tags/HAV/" style="font-size: 12.31px;">HAV</a> <a href="/tags/Hardware/" style="font-size: 13.85px;">Hardware</a> <a href="/tags/Heap/" style="font-size: 10.77px;">Heap</a> <a href="/tags/Hooking/" style="font-size: 10px;">Hooking</a> <a href="/tags/Instrumentation/" style="font-size: 10.77px;">Instrumentation</a> <a href="/tags/Introspection/" style="font-size: 13.85px;">Introspection</a> <a href="/tags/JOP/" style="font-size: 10px;">JOP</a> <a href="/tags/KVM/" style="font-size: 16.15px;">KVM</a> <a href="/tags/Kernel/" style="font-size: 17.69px;">Kernel</a> <a href="/tags/Libvmi/" style="font-size: 13.08px;">Libvmi</a> <a href="/tags/Linux/" style="font-size: 13.08px;">Linux</a> <a href="/tags/Malware/" style="font-size: 15.38px;">Malware</a> <a href="/tags/Memory/" style="font-size: 13.08px;">Memory</a> <a href="/tags/Migration/" style="font-size: 11.54px;">Migration</a> <a href="/tags/Monitoring/" style="font-size: 13.08px;">Monitoring</a> <a href="/tags/NX/" style="font-size: 10px;">NX</a> <a href="/tags/Overflow/" style="font-size: 10.77px;">Overflow</a> <a href="/tags/PIN/" style="font-size: 10px;">PIN</a> <a href="/tags/Paper/" style="font-size: 11.54px;">Paper</a> <a href="/tags/Ph-D/" style="font-size: 10.77px;">Ph.D</a> <a href="/tags/Ppaerwriting/" style="font-size: 10px;">Ppaerwriting</a> <a href="/tags/Professor/" style="font-size: 12.31px;">Professor</a> <a href="/tags/QEMU/" style="font-size: 14.62px;">QEMU</a> <a href="/tags/RE/" style="font-size: 10px;">RE</a> <a href="/tags/ROP/" style="font-size: 10.77px;">ROP</a> <a href="/tags/Rootkit/" style="font-size: 11.54px;">Rootkit</a> <a href="/tags/SYSCALL/" style="font-size: 10px;">SYSCALL</a> <a href="/tags/Sandbox/" style="font-size: 10.77px;">Sandbox</a> <a href="/tags/Security/" style="font-size: 20px;">Security</a> <a href="/tags/Shellcode/" style="font-size: 10px;">Shellcode</a> <a href="/tags/Snapshot/" style="font-size: 10px;">Snapshot</a> <a href="/tags/Stack/" style="font-size: 10.77px;">Stack</a> <a href="/tags/Syscall/" style="font-size: 10px;">Syscall</a> <a href="/tags/System/" style="font-size: 18.46px;">System</a> <a href="/tags/Systemcall/" style="font-size: 11.54px;">Systemcall</a> <a href="/tags/TSX/" style="font-size: 10px;">TSX</a> <a href="/tags/TrustZone/" style="font-size: 10px;">TrustZone</a> <a href="/tags/VT-x/" style="font-size: 10px;">VT-x</a> <a href="/tags/Valgrind/" style="font-size: 10px;">Valgrind</a> <a href="/tags/Virtualization/" style="font-size: 19.23px;">Virtualization</a> <a href="/tags/Volatility/" style="font-size: 10px;">Volatility</a> <a href="/tags/XEN/" style="font-size: 13.08px;">XEN</a>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      版权所有&copy; 2017 Index of Computer System and Security 保留所有权利.
      </div>
      <div class="site-credit">
       <!--  自豪地使用 <a href="https://github.com/iTimeTraveler/hexo-theme-hiero" target="_blank">hiero</a> --> 
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
</script>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
    <a href="/syssec" class="mobile-nav-link">Syssec</a>
  
    <a href="/architecture" class="mobile-nav-link">Architecture</a>
  
    <a href="/virtualization" class="mobile-nav-link">Virtualization</a>
  
    <a href="/malware" class="mobile-nav-link">Malware</a>
  
    <a href="/conferences" class="mobile-nav-link">Conferences</a>
  
    <a href="/courses" class="mobile-nav-link">Courses</a>
  
    <a href="/academy" class="mobile-nav-link">Academy</a>
  
    <a href="/news" class="mobile-nav-link">News</a>
  
    <a href="/knowledge" class="mobile-nav-link">Knowledge</a>
  
    <a href="/share" class="mobile-nav-link">Share</a>
  
    <a href="/contribution" class="mobile-nav-link">Contribution</a>
  
</nav> -->
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>





  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
  

  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1261078922&web_id=1261078922" language="JavaScript"></script>
  </div>


</body>
</html>
