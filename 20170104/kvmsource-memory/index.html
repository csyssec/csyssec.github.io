<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>kvm源码分析之内存虚拟化 | Index of Computer System and Security</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="computer system, computer security" />
  
  
  
  
  <meta name="description" content="作者：Oen Han

CSysSec注： 本KVM源码分析系列文章来自系Intel中国Linux内核与虚拟化开发工程师Oen Han的博客,Oen Han 在虚拟化领域有丰富的开发经验，其写的KVM源码分析系列是本人目前见过最好最详细的，值得推荐。转载本文请务必注明，文章出处：《KVM源码分析之内存虚拟化》及原作者信息:Oen Han

终于把KVM源码分析之CPU虚拟化写完了，虽然还有run的">
<meta property="og:type" content="article">
<meta property="og:title" content="KVM源码分析之内存虚拟化">
<meta property="og:url" content="http://yoursite.com/20170104/kvmsource-memory/index.html">
<meta property="og:site_name" content="Index of Computer System and Security">
<meta property="og:description" content="作者：Oen Han

CSysSec注： 本KVM源码分析系列文章来自系Intel中国Linux内核与虚拟化开发工程师Oen Han的博客,Oen Han 在虚拟化领域有丰富的开发经验，其写的KVM源码分析系列是本人目前见过最好最详细的，值得推荐。转载本文请务必注明，文章出处：《KVM源码分析之内存虚拟化》及原作者信息:Oen Han

终于把KVM源码分析之CPU虚拟化写完了，虽然还有run的">
<meta property="og:updated_time" content="2017-01-04T05:51:53.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KVM源码分析之内存虚拟化">
<meta name="twitter:description" content="作者：Oen Han

CSysSec注： 本KVM源码分析系列文章来自系Intel中国Linux内核与虚拟化开发工程师Oen Han的博客,Oen Han 在虚拟化领域有丰富的开发经验，其写的KVM源码分析系列是本人目前见过最好最详细的，值得推荐。转载本文请务必注明，文章出处：《KVM源码分析之内存虚拟化》及原作者信息:Oen Han

终于把KVM源码分析之CPU虚拟化写完了，虽然还有run的">
  
    <link rel="alternate" href="/atom.xml" title="Index of Computer System and Security" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/hiero.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>

<body>
  <header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            <a href="/" title="Index of Computer System and Security" rel="home">
              Index of Computer System and Security</a>
          </h1>
          <div class="site-description">Diting0x@</div>

            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>
            <div class="clearfix sf-menu">

              <ul id="main-nav" class="nmenu sf-js-enabled">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/syssec">系统安全</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/architecture">系统结构</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/virtualization">虚拟化</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/malware">恶意代码</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/conferences">主流会议</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/courses">名人课堂</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/academy">学术专家</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/contribution">本站达人</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>


      </div>
  </div>
</header>




  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-kvmsource-memory" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      KVM源码分析之内存虚拟化
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170104/kvmsource-memory/" class="article-date">
	  <time datetime="2017-01-04T05:50:55.000Z" itemprop="datePublished">一月 4, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者：<a href="http://www.oenhan.com/about" target="_blank" rel="external">Oen Han</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本KVM源码分析系列文章来自系Intel中国Linux内核与虚拟化开发工程师Oen Han的<a href="http://www.oenhan.com/kvm-src-4-mem" target="_blank" rel="external">博客</a>,Oen Han 在虚拟化领域有丰富的开发经验，其写的KVM源码分析系列是本人目前见过最好最详细的，值得推荐。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170104/kvmsource-memory/" target="_blank" rel="external">KVM源码分析之内存虚拟化</a>》及原作者信息:<a href="http://www.oenhan.com/about" target="_blank" rel="external">Oen Han</a></p>
<hr>
<p>终于把<a href="http://www.csyssec.org/20170104/kvmsource-cpu/" target="_blank" rel="external">KVM源码分析之CPU虚拟化</a>写完了，虽然还有run的部分另外在写，还是先看一下内存虚拟化部分。</p>
<p>代码版本：<a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git" target="_blank" rel="external">https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git</a> v3.16.37</p>
<p>在<a href="http://www.csyssec.org/20170104/kvmsource-create/" target="_blank" rel="external">虚拟机的创建与运行中</a>pc_init_pci负责在qemu中初始化虚拟机，内存初始化也是在这里完成的，还是一步步从qemu说起，在vl.c的main函数中有ram_size参数，由qemu入参标识QEMU_OPTION_m设定，顾名思义就是虚拟机内存的大小，通过machine-&gt;init一步步传递给pc_init1函数。在这里分出了above_4g_mem_size和below_4g_mem_size，即高低端内存（也不一定是32bit机器..），然后开始初始化内存，即pc_memory_init，内存通过memory_region_init_ram下面的qemu_ram_alloc分配，使用qemu_ram_alloc_from_ptr。</p>
<p>插播qemu对内存条的模拟管理，是通过RAMBlock和ram_list管理的，RAMBlock就是每次申请的内存池，ram_list则是RAMBlock的链表，他们结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> RAMBlock &#123;</div><div class="line"><span class="comment">//对应宿主的内存地址</span></div><div class="line">    <span class="keyword">uint8_t</span> *host;</div><div class="line"><span class="comment">//block在ramlist中的偏移</span></div><div class="line">    <span class="keyword">ram_addr_t</span> offset;</div><div class="line"><span class="comment">//block长度</span></div><div class="line">    <span class="keyword">ram_addr_t</span> length;</div><div class="line">    <span class="keyword">uint32_t</span> flags;</div><div class="line"><span class="comment">//block名字</span></div><div class="line">    <span class="keyword">char</span> idstr[<span class="number">256</span>];</div><div class="line">    QLIST_ENTRY(RAMBlock) next;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__linux__) &amp;&amp; !defined(TARGET_S390X)</span></div><div class="line">    <span class="keyword">int</span> fd;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125; RAMBlock;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> RAMList &#123;</div><div class="line"><span class="comment">//看代码理解就是list的head，但是不知道为啥叫dirty...</span></div><div class="line">    <span class="keyword">uint8_t</span> *phys_dirty;</div><div class="line">    QLIST_HEAD(ram, RAMBlock) blocks;</div><div class="line">&#125; RAMList;</div></pre></td></tr></table></figure>
<p>下面再回到qemu_ram_alloc_from_ptr函数，使用find_ram_offset赋值给new block的offset，find_ram_offset具体工作模型已经在<a href="http://www.csyssec.org/20170104/kvmsource-create/" target="_blank" rel="external">KVM源代码分析之虚拟机的创建与运行</a>中提到了，不赘述。然后是一串判断，在kvm_enabled的情况下使用new_block-&gt;host = kvm_vmalloc(size)，最终内存是qemu_vmalloc分配的，使用qemu_memalign干活。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">qemu_memalign</span><span class="params">(<span class="keyword">size_t</span> alignment, <span class="keyword">size_t</span> size)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line"><span class="comment">//使用posix进行内存针对页大小对齐</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_POSIX_C_SOURCE) &amp;&amp; !defined(__sun__)</span></div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line">    ret = posix_memalign(&amp;ptr, alignment, size);</div><div class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to allocate %zu B: %sn"</span>,</div><div class="line">                size, strerror(ret));</div><div class="line">        <span class="built_in">abort</span>();</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_BSD)</span></div><div class="line">    ptr = qemu_oom_check(valloc(size));</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="comment">//所谓检查oom就是看memalign对应malloc申请内存是否成功</span></div><div class="line">    ptr = qemu_oom_check(memalign(alignment, size));</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    trace_qemu_memalign(alignment, size, ptr);</div><div class="line">    <span class="keyword">return</span> ptr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上qemu_vmalloc进行内存申请就结束了。在qemu_ram_alloc_from_ptr函数末尾则是将block添加到链表，realloc整个ramlist，用memset初始化整个ramblock，madvise对内存使用限定。<br>然后一层层的退回到pc_memory_init函数。</p>
<p>此时pc.ram已经分配完成，ram_addr已经拿到了分配的内存地址，MemoryRegion ram初始化完成。下面则是对已有的ram进行分段，即ram-below-4g和ram-above-4g，也就是高端内存和低端内存。用memory_region_init_alias初始化子MemoryRegion，然后将memory_region_add_subregion添加关联起来，memory_region_add_subregion具体细节“KVM源码分析2”中已经说了，参考对照着看吧，中间很多映射代码过程也只是qemu遗留的软件实现，没看到具体存在的意义，直接看到kvm_set_user_memory_region函数，内核真正需要kvm_vm_ioctl传递过去的参数是什么， struct kvm_userspace_memory_region mem而已，也就是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> kvm_userspace_memory_region &#123;</div><div class="line">__u32 slot;</div><div class="line">__u32 flags;</div><div class="line">__u64 guest_phys_addr;</div><div class="line">__u64 memory_size; <span class="comment">/* bytes */</span></div><div class="line">__u64 userspace_addr; <span class="comment">/* start of the userspace allocated memory */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>kvm_vm_ioctl进入到内核是在KVM_SET_USER_MEMORY_REGION参数中，即执行kvm_vm_ioctl_set_memory_region，然后一直向下，到<strong>kvm_set_memory_region函数，check_memory_region_flags检查mem-&gt;flags是否合法，而当前flag也就使用了两位，KVM_MEM_LOG_DIRTY_PAGES和KVM_MEM_READONLY，从qemu传递过来只能是KVM_MEM_LOG_DIRTY_PAGES,下面是对mem中各参数的合规检查，(mem-&gt;memory_size &amp; (PAGE_SIZE – 1))要求以页为单位，(mem-&gt;guest_phys_addr &amp; (PAGE_SIZE – 1))要求guest_phys_addr页对齐，而((mem-&gt;userspace_addr &amp; (PAGE_SIZE – 1)) || !access_ok(VERIFY_WRITE,(void </strong>user *)(unsigned long)mem-&gt;userspace_addr,mem-&gt;memory_size))则保证host的线性地址页对齐而且该地址域有写权限。<br>id_to_memslot则是根据qemu的内存槽号得到kvm结构下的内存槽号，转换关系来自id_to_index数组，那映射关系怎么来的，映射关系是一一对应的，在kvm_create_vm虚拟机创建过程中，kvm_init_memslots_id初始化对应关系，即slots-&gt;id_to_index[i] = slots-&gt;memslots[i].id = i，当前映射是没有意义的，估计是为了后续扩展而存在的。<br>扩充了new的kvm_memory_slot，下面直接在代码中注释更方便：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//映射内存有大小，不是删除内存条</span></div><div class="line"><span class="keyword">if</span> (npages) &#123;</div><div class="line"><span class="comment">//内存槽号没有虚拟内存条，意味内存新创建</span></div><div class="line">	<span class="keyword">if</span> (!old.npages)</div><div class="line">		change = KVM_MR_CREATE;</div><div class="line">	<span class="keyword">else</span> &#123; <span class="comment">/* Modify an existing slot. */</span></div><div class="line"><span class="comment">//修改已存在的内存修改标志或者平移映射地址</span></div><div class="line"><span class="comment">//下面是不能处理的状态（内存条大小不能变，物理地址不能变，不能修改只读）</span></div><div class="line">		<span class="keyword">if</span> ((mem-&gt;userspace_addr != old.userspace_addr) ||</div><div class="line">		    (npages != old.npages) ||</div><div class="line">		    ((<span class="keyword">new</span>.flags ^ old.flags) &amp; KVM_MEM_READONLY))</div><div class="line">			<span class="keyword">goto</span> out;</div><div class="line"><span class="comment">//guest地址不同，内存条平移</span></div><div class="line">		<span class="keyword">if</span> (base_gfn != old.base_gfn)</div><div class="line">			change = KVM_MR_MOVE;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">new</span>.flags != old.flags)</div><div class="line"><span class="comment">//修改属性</span></div><div class="line">			change = KVM_MR_FLAGS_ONLY;</div><div class="line">		<span class="keyword">else</span> &#123; <span class="comment">/* Nothing to change. */</span></div><div class="line">			r = <span class="number">0</span>;</div><div class="line">			<span class="keyword">goto</span> out;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (old.npages) &#123;</div><div class="line"><span class="comment">//申请插入的内存为0，而内存槽上有内存，意味删除</span></div><div class="line">	change = KVM_MR_DELETE;</div><div class="line">&#125; <span class="keyword">else</span> <span class="comment">/* Modify a non-existent slot: disallowed. */</span></div><div class="line">	<span class="keyword">goto</span> out;</div></pre></td></tr></table></figure>
<p>另外看kvm_mr_change就知道memslot的变动值了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> kvm_mr_change &#123;</div><div class="line">	KVM_MR_CREATE,</div><div class="line">	KVM_MR_DELETE,</div><div class="line">	KVM_MR_MOVE,</div><div class="line">	KVM_MR_FLAGS_ONLY,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在往下是一段检查</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((change == KVM_MR_CREATE) || (change == KVM_MR_MOVE)) &#123;</div><div class="line">	<span class="comment">/* Check for overlaps */</span></div><div class="line">	r = -EEXIST;</div><div class="line">	kvm_for_each_memslot(slot, kvm-&gt;memslots) &#123;</div><div class="line">		<span class="keyword">if</span> ((slot-&gt;id &gt;= KVM_USER_MEM_SLOTS) ||</div><div class="line"><span class="comment">//下面排除掉准备操作的内存条，在KVM_MR_MOVE中是有交集的</span></div><div class="line">		    (slot-&gt;id == mem-&gt;slot))</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line"><span class="comment">//下面就是当前已有的slot与new在guest线性区间上有交集</span></div><div class="line">		<span class="keyword">if</span> (!((base_gfn + npages &lt;= slot-&gt;base_gfn) ||</div><div class="line">		      (base_gfn &gt;= slot-&gt;base_gfn + slot-&gt;npages)))</div><div class="line">			<span class="keyword">goto</span> out;</div><div class="line"><span class="comment">//out错误码就是EEXIST</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是新插入内存条，代码则走入kvm_arch_create_memslot函数，里面主要是一个循环，KVM_NR_PAGE_SIZES是分页的级数，此处是3，第一次循环，lpages = gfn_to_index(slot-&gt;base_gfn + npages – 1,slot-&gt;base_gfn, level) + 1，lpages就是一级页表所需要的page数，大致是npages&gt;&gt;0<em>9,然后为slot-&gt;arch.rmap[i]申请了内存空间，此处可以猜想，rmap就是一级页表了，继续看，lpages约为npages&gt;&gt;1</em>9,此处又多为lpage_info申请了同等空间，然后对lpage_info初始化赋值，现在看不到lpage_info的具体作用，看到后再补上。整体上看kvm_arch_create_memslot做了一个3级的软件页表。<br>如果有脏页,并且脏页位图为空,则分配脏页位图, kvm_create_dirty_bitmap实际就是”页数/8″.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((<span class="keyword">new</span>.flags &amp; KVM_MEM_LOG_DIRTY_PAGES) &amp;&amp; !<span class="keyword">new</span>.dirty_bitmap) &#123;</div><div class="line">		<span class="keyword">if</span> (kvm_create_dirty_bitmap(&amp;<span class="keyword">new</span>) &lt; <span class="number">0</span>)</div><div class="line">			<span class="keyword">goto</span> out_free;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>当内存条的改变是KVM_MR_DELETE或者KVM_MR_MOVE,先申请一个slots,把kvm-&gt;memslots暂存到这里,首先通过id_to_memslot获取准备插入的内存条对应到kvm的插槽是slot,无论删除还是移动,将其先标记为KVM_MEMSLOT_INVALID,然后是install_new_memslots,其实就是更新了一下slots-&gt;generation的值。</p>
<p>内存的添加说完了，看一下EPT页表的映射，在kvm_arch_vcpu_setup中有kvm_mmu_setup，是mmu的初始化，EPT的初始化是init_kvm_tdp_mmu，所谓的初始化就是填充了vcpu-&gt;arch.mmu结构体，里面有很多回调函数都会用到，最终的是tdp_page_fault。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">context-&amp;gt;page_fault = tdp_page_fault;</div><div class="line">context-&amp;gt;sync_page = nonpaging_sync_page;</div><div class="line">context-&amp;gt;invlpg = nonpaging_invlpg;</div><div class="line">context-&amp;gt;update_pte = nonpaging_update_pte;</div><div class="line">context-&amp;gt;shadow_root_level = kvm_x86_ops-&amp;gt;get_tdp_level();</div><div class="line">context-&amp;gt;root_hpa = INVALID_PAGE;</div><div class="line">context-&amp;gt;direct_map = <span class="literal">true</span>;</div><div class="line">context-&amp;gt;set_cr3 = kvm_x86_ops-&amp;gt;set_tdp_cr3;</div><div class="line">context-&amp;gt;get_cr3 = get_cr3;</div><div class="line">context-&amp;gt;get_pdptr = kvm_pdptr_read;</div><div class="line">context-&amp;gt;inject_page_fault = kvm_inject_page_fault;</div></pre></td></tr></table></figure>
<p>当guest访问物理内存时发生vm-exit，进入vmx_handle_exit函数，根据EXIT_REASON_EPT_VIOLATION走到handle_ept_violation函数，exit_qualification = vmcs_readl(EXIT_QUALIFICATION)获取vm-exit的退出原因，进入kvm_mmu_page_fault函数：vcpu-&gt;arch.mmu.page_fault(vcpu, cr2, error_code, false)，即是tdp_page_fault，handle_mmio_page_fault的流程不提。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//填充kvm mmu专用的slab </span></div><div class="line">r = mmu_topup_memory_caches(vcpu);</div><div class="line"><span class="comment">//获取gfn使用的level，即hugepage的问题</span></div><div class="line">force_pt_level = mapping_level_dirty_bitmap(vcpu, gfn);</div><div class="line"><span class="keyword">if</span> (likely(!force_pt_level)) &#123;</div><div class="line">	level = mapping_level(vcpu, gfn);</div><div class="line">	gfn &amp;amp;= ~(KVM_PAGES_PER_HPAGE(level) - <span class="number">1</span>);</div><div class="line">&#125; <span class="keyword">else</span></div><div class="line">	level = PT_PAGE_TABLE_LEVEL;</div><div class="line"></div><div class="line"><span class="comment">//顾名思义，快速处理一个简单的page fault</span></div><div class="line"><span class="comment">//即present同时有写权限的非mmio page fault</span></div><div class="line"><span class="comment">//参考page_fault_can_be_fast函数</span></div><div class="line"><span class="comment">//一部分处理没有写权限的page fault</span></div><div class="line"><span class="comment">//一部分处理 TLB lazy</span></div><div class="line"><span class="comment">//fast_pf_fix_direct_spte也就是将pte获取的写权限</span></div><div class="line"><span class="keyword">if</span> (fast_page_fault(vcpu, gpa, level, error_code))</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="comment">//下面函数主要就一件事情，gfn_to_pfn</span></div><div class="line"><span class="keyword">if</span> (try_async_pf(vcpu, prefault, gfn, gpa, &amp;amp;pfn, write, &amp;amp;map_writable))</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="comment">//direct map就是映射ept页表的过程</span></div><div class="line">r = __direct_map(vcpu, gpa, write, map_writable,</div><div class="line">      level, gfn, pfn, prefault);</div></pre></td></tr></table></figure>
<p>在try_async_pf中就是gfn转换成hva，然后hva转换成pfn的过程，gfn转换到hva:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">pfn_t</span></div><div class="line">__gfn_to_pfn_memslot(<span class="keyword">struct</span> kvm_memory_slot *slot, <span class="keyword">gfn_t</span> gfn, <span class="keyword">bool</span> atomic,</div><div class="line">		     <span class="keyword">bool</span> *async, <span class="keyword">bool</span> write_fault, <span class="keyword">bool</span> *writable)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> addr = __gfn_to_hva_many(slot, gfn, <span class="literal">NULL</span>, write_fault);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (addr == KVM_HVA_ERR_RO_BAD)</div><div class="line">		<span class="keyword">return</span> KVM_PFN_ERR_RO_FAULT;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (kvm_is_error_hva(addr))</div><div class="line">		<span class="keyword">return</span> KVM_PFN_NOSLOT;</div><div class="line"></div><div class="line">	<span class="comment">/* Do not map writable pfn in the readonly memslot. */</span></div><div class="line">	<span class="keyword">if</span> (writable &amp;amp;&amp;amp; memslot_is_readonly(slot)) &#123;</div><div class="line">		*writable = <span class="literal">false</span>;</div><div class="line">		writable = <span class="literal">NULL</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> hva_to_pfn(addr, atomic, async, write_fault,</div><div class="line">			  writable);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>gfn2hva本质就是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span></div><div class="line">__gfn_to_hva_memslot(<span class="keyword">struct</span> kvm_memory_slot *slot, <span class="keyword">gfn_t</span> gfn)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> slot-&amp;gt;userspace_addr + (gfn - slot-&amp;gt;base_gfn) * PAGE_SIZE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而hva_to_pfn则就是host的线性区进行地址转换的问题了，不提。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __direct_map(<span class="keyword">struct</span> kvm_vcpu *vcpu, <span class="keyword">gpa_t</span> v, <span class="keyword">int</span> write,</div><div class="line">			<span class="keyword">int</span> map_writable, <span class="keyword">int</span> level, <span class="keyword">gfn_t</span> gfn, <span class="keyword">pfn_t</span> pfn,</div><div class="line">			<span class="keyword">bool</span> prefault)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">struct</span> kvm_shadow_walk_iterator iterator;</div><div class="line">	<span class="keyword">struct</span> kvm_mmu_page *sp;</div><div class="line">	<span class="keyword">int</span> emulate = <span class="number">0</span>;</div><div class="line">	<span class="keyword">gfn_t</span> pseudo_gfn;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (!VALID_PAGE(vcpu-&gt;arch.mmu.root_hpa))</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="comment">//遍历ept四级页表</span></div><div class="line">	for_each_shadow_entry(vcpu, (u64)gfn &lt;&lt; PAGE_SHIFT, iterator) &#123;</div><div class="line"><span class="comment">//如果是最后一级，level是hugepage下的level</span></div><div class="line">		<span class="keyword">if</span> (iterator.level == level) &#123;</div><div class="line"><span class="comment">//设置pte，页表下一级的page地址就是pfn写入到pte</span></div><div class="line">			mmu_set_spte(vcpu, iterator.sptep, ACC_ALL,</div><div class="line">				     write, &amp;emulate, level, gfn, pfn,</div><div class="line">				     prefault, map_writable);</div><div class="line">			direct_pte_prefetch(vcpu, iterator.sptep);</div><div class="line">			++vcpu-&gt;stat.pf_fixed;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		drop_large_spte(vcpu, iterator.sptep);</div><div class="line"><span class="comment">//mmu page不在位的情况，也就是缺页</span></div><div class="line">		<span class="keyword">if</span> (!is_shadow_present_pte(*iterator.sptep)) &#123;</div><div class="line">			u64 base_addr = iterator.addr;</div><div class="line"><span class="comment">//获取指向的具体mmu page entry的index</span></div><div class="line">			base_addr &amp;= PT64_LVL_ADDR_MASK(iterator.level);</div><div class="line">			pseudo_gfn = base_addr &gt;&gt; PAGE_SHIFT;</div><div class="line"><span class="comment">//获取mmu page</span></div><div class="line">			sp = kvm_mmu_get_page(vcpu, pseudo_gfn, iterator.addr,</div><div class="line">					      iterator.level - <span class="number">1</span>,</div><div class="line">					      <span class="number">1</span>, ACC_ALL, iterator.sptep);</div><div class="line"><span class="comment">//将当前的mmu page的地址写入到上一级别mmu page的pte中</span></div><div class="line">			link_shadow_page(iterator.sptep, sp, <span class="literal">true</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> emulate;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">struct</span> kvm_mmu_page *<span class="title">kvm_mmu_get_page</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu,</span></span></div><div class="line">					     <span class="keyword">gfn_t</span> gfn,</div><div class="line">					     <span class="keyword">gva_t</span> gaddr,</div><div class="line">					     <span class="keyword">unsigned</span> level,</div><div class="line">					     <span class="keyword">int</span> direct,</div><div class="line">					     <span class="keyword">unsigned</span> access,</div><div class="line">					     u64 *parent_pte)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">union</span> kvm_mmu_page_role role;</div><div class="line">	<span class="keyword">unsigned</span> quadrant;</div><div class="line">	<span class="keyword">struct</span> kvm_mmu_page *sp;</div><div class="line">	<span class="keyword">bool</span> need_sync = <span class="literal">false</span>;</div><div class="line"></div><div class="line">	role = vcpu-&gt;arch.mmu.base_role;</div><div class="line">	role.level = level;</div><div class="line">	role.direct = direct;</div><div class="line">	<span class="keyword">if</span> (role.direct)</div><div class="line">		role.cr4_pae = <span class="number">0</span>;</div><div class="line">	role.access = access;</div><div class="line">	<span class="keyword">if</span> (!vcpu-&gt;arch.mmu.direct_map</div><div class="line">	    &amp;&amp; vcpu-&gt;arch.mmu.root_level &lt;= PT32_ROOT_LEVEL) &#123;</div><div class="line">		quadrant = gaddr &gt;&gt; (PAGE_SHIFT + (PT64_PT_BITS * level));</div><div class="line">		quadrant &amp;= (<span class="number">1</span> &lt;&lt; ((PT32_PT_BITS - PT64_PT_BITS) * level)) - <span class="number">1</span>;</div><div class="line">		role.quadrant = quadrant;</div><div class="line">	&#125;</div><div class="line"><span class="comment">//根据一个hash索引来的</span></div><div class="line">	for_each_gfn_sp(vcpu-&gt;kvm, sp, gfn) &#123;</div><div class="line"><span class="comment">//检查整个mmu ept是否被失效了</span></div><div class="line">		<span class="keyword">if</span> (is_obsolete_sp(vcpu-&gt;kvm, sp))</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (!need_sync &amp;&amp; sp-&gt;unsync)</div><div class="line">			need_sync = <span class="literal">true</span>;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (sp-&gt;role.word != role.word)</div><div class="line">			<span class="keyword">continue</span>;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (sp-&gt;unsync &amp;&amp; kvm_sync_page_transient(vcpu, sp))</div><div class="line">			<span class="keyword">break</span>;</div><div class="line"></div><div class="line">		mmu_page_add_parent_pte(vcpu, sp, parent_pte);</div><div class="line">		<span class="keyword">if</span> (sp-&gt;unsync_children) &#123;</div><div class="line">			kvm_make_request(KVM_REQ_MMU_SYNC, vcpu);</div><div class="line">			kvm_mmu_mark_parents_unsync(sp);</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sp-&gt;unsync)</div><div class="line">			kvm_mmu_mark_parents_unsync(sp);</div><div class="line"></div><div class="line">		__clear_sp_write_flooding_count(sp);</div><div class="line">		trace_kvm_mmu_get_page(sp, <span class="literal">false</span>);</div><div class="line">		<span class="keyword">return</span> sp;</div><div class="line">	&#125;</div><div class="line">	++vcpu-&gt;kvm-&gt;stat.mmu_cache_miss;</div><div class="line">	sp = kvm_mmu_alloc_page(vcpu, parent_pte, direct);</div><div class="line">	<span class="keyword">if</span> (!sp)</div><div class="line">		<span class="keyword">return</span> sp;</div><div class="line">	sp-&gt;gfn = gfn;</div><div class="line">	sp-&gt;role = role;</div><div class="line"><span class="comment">//新的mmu page加入hash索引，所以前面的for循环中才能知道gfn对应的mmu有没有</span></div><div class="line"><span class="comment">//被分配</span></div><div class="line">	hlist_add_head(&amp;sp-&gt;hash_link,</div><div class="line">		&amp;vcpu-&gt;kvm-&gt;arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);</div><div class="line">	<span class="keyword">if</span> (!direct) &#123;</div><div class="line">		<span class="keyword">if</span> (rmap_write_protect(vcpu-&gt;kvm, gfn))</div><div class="line">			kvm_flush_remote_tlbs(vcpu-&gt;kvm);</div><div class="line">		<span class="keyword">if</span> (level &gt; PT_PAGE_TABLE_LEVEL &amp;&amp; need_sync)</div><div class="line">			kvm_sync_pages(vcpu, gfn);</div><div class="line"></div><div class="line">		account_shadowed(vcpu-&gt;kvm, gfn);</div><div class="line">	&#125;</div><div class="line">	sp-&gt;mmu_valid_gen = vcpu-&gt;kvm-&gt;arch.mmu_valid_gen;</div><div class="line">	init_shadow_page_table(sp);</div><div class="line">	trace_kvm_mmu_get_page(sp, <span class="literal">true</span>);</div><div class="line">	<span class="keyword">return</span> sp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样看每次缺页都会分配新的mmu page，虚拟机每次启动是根据guest不停的进行EXIT_REASON_EPT_VIOLATION，整个页表就建立起来了。</p>
<p>—结束—</p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170104/kvmsource-memory/" target="_blank" rel="external">KVM源码分析之内存虚拟化</a>》及原作者信息:<a href="http://www.oenhan.com/about" target="_blank" rel="external">Oen Han</a></p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/虚拟化原理/">虚拟化原理<span class="article-category-count">7</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KVM/">KVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/QEMU/">QEMU</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtualization/">Virtualization</a></li></ul>

      
        
	<div id="comment">
	
	<!-- 多说评论框 start -->
	 <div class="ds-thread" data-thread-key="/20170104/kvmsource-memory/" data-title="KVM源码分析之内存虚拟化" data-url="http://yoursite.com/20170104/kvmsource-memory/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"csyssec"};
	  (function() {
	    var ds = document.createElement('script');
	    ds.type = 'text/javascript';ds.async = true;
	    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	    ds.charset = 'UTF-8';
	    (document.getElementsByTagName('head')[0] 
	     || document.getElementsByTagName('body')[0]).appendChild(ds);
	  })();
	  </script>
	<!-- 多说公共JS代码 end -->
	
	</div>
	<link rel="stylesheet" href="/css/comment.css">


      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/20170104/kvmsource-io/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          KVM源码分析之IO虚拟化之PIO
        
      </div>
    </a>
  
  
    <a href="/20170104/kvmsource-cpu/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">KVM源码分析之CPU虚拟化</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
    <ol class="toc">无</ol>
    
    </div>
  </aside>
</section>
        
      </div>
      <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      版权所有&copy; 2017 Index of Computer System and Security 保留所有权利.
      </div>
      <div class="site-credit">
       <!--  自豪地使用 <a href="https://github.com/iTimeTraveler/hexo-theme-hiero" target="_blank">hiero</a> --> 
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
</script>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/syssec" class="mobile-nav-link">Syssec</a>
  
    <a href="/architecture" class="mobile-nav-link">Architecture</a>
  
    <a href="/virtualization" class="mobile-nav-link">Virtualization</a>
  
    <a href="/malware" class="mobile-nav-link">Malware</a>
  
    <a href="/conferences" class="mobile-nav-link">Conferences</a>
  
    <a href="/courses" class="mobile-nav-link">Courses</a>
  
    <a href="/academy" class="mobile-nav-link">Academy</a>
  
    <a href="/contribution" class="mobile-nav-link">Contribution</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>





  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
  

  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1261078922&web_id=1261078922" language="JavaScript"></script>
  </div>


</body>
</html>
