<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>kvm源码分析之虚拟机的创建与运行 | Index of Computer System and Security</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="computer system, computer security" />
  
  
  
  
  <meta name="description" content="作者：Oen Han

CSysSec注： 本KVM源码分析系列文章来自系Intel中国Linux内核与虚拟化开发工程师Oen Han的博客,Oen Han 在虚拟化领域有丰富的开发经验，其写的KVM源码分析系列是本人目前见过最好最详细的，值得推荐。转载本文请务必注明，文章出处：《KVM源码分析之虚拟机的创建与运行》

前段时间挖了一个坑，KVM源码分析之基本工作原理，准备写一下kvm的代码机制，">
<meta property="og:type" content="article">
<meta property="og:title" content="KVM源码分析之虚拟机的创建与运行">
<meta property="og:url" content="http://yoursite.com/20170104/kvmsource-create/index.html">
<meta property="og:site_name" content="Index of Computer System and Security">
<meta property="og:description" content="作者：Oen Han

CSysSec注： 本KVM源码分析系列文章来自系Intel中国Linux内核与虚拟化开发工程师Oen Han的博客,Oen Han 在虚拟化领域有丰富的开发经验，其写的KVM源码分析系列是本人目前见过最好最详细的，值得推荐。转载本文请务必注明，文章出处：《KVM源码分析之虚拟机的创建与运行》

前段时间挖了一个坑，KVM源码分析之基本工作原理，准备写一下kvm的代码机制，">
<meta property="og:image" content="http://oij0laovn.bkt.clouddn.com/kvmsource201.png">
<meta property="og:image" content="http://oij0laovn.bkt.clouddn.com/kvmsource202.png">
<meta property="og:image" content="http://oij0laovn.bkt.clouddn.com/kvmsource203.bmp">
<meta property="og:updated_time" content="2017-01-04T05:49:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="KVM源码分析之虚拟机的创建与运行">
<meta name="twitter:description" content="作者：Oen Han

CSysSec注： 本KVM源码分析系列文章来自系Intel中国Linux内核与虚拟化开发工程师Oen Han的博客,Oen Han 在虚拟化领域有丰富的开发经验，其写的KVM源码分析系列是本人目前见过最好最详细的，值得推荐。转载本文请务必注明，文章出处：《KVM源码分析之虚拟机的创建与运行》

前段时间挖了一个坑，KVM源码分析之基本工作原理，准备写一下kvm的代码机制，">
<meta name="twitter:image" content="http://oij0laovn.bkt.clouddn.com/kvmsource201.png">
  
    <link rel="alternate" href="/atom.xml" title="Index of Computer System and Security" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/hiero.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>

<body>
  <header id="allheader" class="site-header" role="banner">
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            <a href="/" title="Index of Computer System and Security" rel="home">
              Index of Computer System and Security</a>
          </h1>
          <div class="site-description">Diting0x@</div>

            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>
            <div class="clearfix sf-menu">

              <ul id="main-nav" class="nmenu sf-js-enabled">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/syssec">系统安全</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/architecture">系统结构</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/virtualization">虚拟化</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/malware">恶意代码</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/conferences">主流会议</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/courses">名人课堂</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/academy">学术专家</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/contribution">本站达人</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>


      </div>
  </div>
</header>




  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-kvmsource-create" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      KVM源码分析之虚拟机的创建与运行
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	Posted on <a href="/20170104/kvmsource-create/" class="article-date">
	  <time datetime="2017-01-04T05:48:14.000Z" itemprop="datePublished">一月 4, 2017</time>
	</a>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>作者：<a href="http://www.oenhan.com/about" target="_blank" rel="external">Oen Han</a></p>
<hr>
<p><strong>CSysSec注</strong>： 本KVM源码分析系列文章来自系Intel中国Linux内核与虚拟化开发工程师Oen Han的<a href="http://www.oenhan.com/kvm-src-2-vm-run" target="_blank" rel="external">博客</a>,Oen Han 在虚拟化领域有丰富的开发经验，其写的KVM源码分析系列是本人目前见过最好最详细的，值得推荐。<br><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170104/kvmsource-create/" target="_blank" rel="external">KVM源码分析之虚拟机的创建与运行</a>》</p>
<hr>
<p>前段时间挖了一个坑，<a href="http://www.csyssec.org/20170104/kvmsource1/" target="_blank" rel="external">KVM源码分析之基本工作原理</a>，准备写一下kvm的代码机制，结果一直没时间填土，现在还一下旧账，争取能温故而知新。 基本原理里面提到kvm虚拟化由用户态程序Qemu和内核态驱动kvm配合完成，qemu负责HOST用户态层面进程管理，IO处理等，KVM负责把qemu的部分指令在硬件上直接实现，从虚拟机的创建和运行上看，qemu的代码占了流程上的主要部分。下面的代码主要主要针对与qemu，KVM部分另外开篇再说。</p>
<p>代码：</p>
<pre><code>QEMU：git://git.qemu.org/qemu.git v2.4.0

KVM：https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git v4.2
</code></pre><p>QEMU和KVM是通过IOCTL进行配合的，直接抓住这个线看有kvm_ioctl、kvm_vm_ioctl、kvm_vcpu_ioctl、kvm_device_ioctl等，他们还都在一个C文件里面。</p>
<p>使用kvm_ioctl很少了，直接看调用的代码，有KVM_GET_VCPU_MMAP_SIZE，KVM_CHECK_EXTENSION，KVM_GET_API_VERSION，KVM_CREATE_VM，KVM_GET_SUPPORTED_CPUID等等，需要记住只有KVM_CREATE_VM。</p>
<p>而调用kvm_vm_ioctl的函数真是海了去了，需要看的是KVM_SET_USER_MEMORY_REGION，KVM_CREATE_VCPU，KVM_CREATE_DEVICE。</p>
<p>所有寄存器的交换信息都是通过kvm_vcpu_ioctl，需要记住的操作只有，KVM_RUN。</p>
<p>所有看QEMU和KVM的配合流程如下</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/kvmsource201.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/kvmsource201.png" width="450"></a><br>    <figcaption></figcaption><br></figure>

<p>接下来参考上图分析qemu代码流程： 从vl.c代码的main函数开始。 atexit(qemu_run_exit_notifiers)注册了qemu的退出处理函数，后面在具体看qemu_run_exit_notifiers函数。 module_call_init则开始初始化qemu的各个模块，陆陆续续的有以下参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</div><div class="line">    MODULE_INIT_BLOCK,</div><div class="line">    MODULE_INIT_MACHINE,</div><div class="line">    MODULE_INIT_QAPI,</div><div class="line">    MODULE_INIT_QOM,</div><div class="line">    MODULE_INIT_MAX</div><div class="line">&#125; module_init_type;</div></pre></td></tr></table></figure>
<p>最开始初始化的MODULE_INIT_QOM，QOM是qemu实现的一种模拟设备，具体可以参考<a href="http://wiki.qemu.org/Features/QOM，代码下面的不远处就MODULE_INIT_MACHINE的初始化，这两条语句放到一起看，直接说一下module_call_init的机制。" target="_blank" rel="external">http://wiki.qemu.org/Features/QOM，代码下面的不远处就MODULE_INIT_MACHINE的初始化，这两条语句放到一起看，直接说一下module_call_init的机制。</a> module_call_init实际设计的一个函数链表，ModuleTypeList ，链表关系如下图</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/kvmsource202.png" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/kvmsource202.png" width="450"></a><br>    <figcaption></figcaption><br></figure>

<p>它把相关的函数注册到对应的数组链表上，通过执行init项目完成所有设备的初始化。module_call_init就是执行e-&gt;init()完成功能的，而e-&gt;init是什么时候通过register_module_init注册到ModuleTypeList上的ModuleEntry，是module_init注册的，而调用module_init的有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> block_init(function) module_init(function, MODULE_INIT_BLOCK)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> machine_init(function) module_init(function, MODULE_INIT_MACHINE)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> qapi_init(function) module_init(function, MODULE_INIT_QAPI)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> type_init(function) module_init(function, MODULE_INIT_QOM)</span></div></pre></td></tr></table></figure>
<p>那么执行machine_init则是挂到了MODULE_INIT_MACHINE，type_init则将函数挂载了MODULE_INIT_QOM。那么排查一下是，我们只关注PC的注册，那么就是machine_init(pc_machine<em>init</em>##suffix)，源自DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn)宏，而DEFINE_I440FX_MACHINE有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_I440FX_MACHINE(suffix, name, compatfn, optionfn) </span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">void</span> pc_init_#<span class="meta">#suffix(MachineState *machine) </span></div><div class="line">    &#123; </div><div class="line">        <span class="keyword">void</span> (*compat)(MachineState *m) = (compatfn); </div><div class="line">        <span class="keyword">if</span> (compat) &#123; </div><div class="line">            compat(machine); </div><div class="line">        &#125; </div><div class="line">        pc_init1(machine); </div><div class="line">    &#125; </div><div class="line">    DEFINE_PC_MACHINE(suffix, name, pc_init_##suffix, optionfn)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_PC_MACHINE(suffix, namestr, initfn, optsfn) </span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">void</span> pc_machine_#<span class="meta">#suffix##_class_init(ObjectClass *oc, void *data) </span></div><div class="line">    &#123; </div><div class="line">        MachineClass *mc = MACHINE_CLASS(oc); </div><div class="line">        optsfn(mc); </div><div class="line">        mc-&gt;name = namestr; </div><div class="line">        mc-&gt;init = initfn; </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> TypeInfo pc_machine_type_#<span class="meta">#suffix = &#123; </span></div><div class="line">        .name       = namestr TYPE_MACHINE_SUFFIX, </div><div class="line">        .parent     = TYPE_PC_MACHINE, </div><div class="line">        .class_init = pc_machine_##suffix##_class_init, </div><div class="line">    &#125;; </div><div class="line">    <span class="keyword">static</span> <span class="keyword">void</span> pc_machine_init_#<span class="meta">#suffix(void) </span></div><div class="line">    &#123; </div><div class="line">        type_register(&amp;pc_machine_type_##suffix); </div><div class="line">    &#125; </div><div class="line">    machine_init(pc_machine_init_##suffix)</div></pre></td></tr></table></figure>
<p>DEFINE_PC_MACHINE注册的函数pc<em>init</em>##suffix在DEFINE_I440FX_MACHINE中定义，怎么组合都无关，pc_init1(machine)函数一定要执行，本质就是pc_init1赋值给了mc-&gt;init，其他爱看不看吧。<br>而module_init的宏是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> module_init(function, type)                                         </span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __attribute__((constructor)) do_qemu_init_ #<span class="meta"># function(void)    </span></div><div class="line">&#123;                                                                           </div><div class="line">    register_dso_module_init(function, type);                               </div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="comment">/* This should not be used directly.  Use block_init etc. instead.  */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> module_init(function, type)                                         </span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __attribute__((constructor)) do_qemu_init_ #<span class="meta"># function(void)    </span></div><div class="line">&#123;                                                                           </div><div class="line">    register_module_init(function, type);                                   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它前面的修饰是<strong>attribute</strong>((constructor)),这个导致machine_init或者type_init等会在main()之前就被执行。所有type_init(kvm_type_init）-&gt; kvm_accel_type -&gt; kvm_accel_class_init -&gt; kvm_init依次完成了函数注册，所有说module_call_init(MODULE_INIT_QOM)函数已经完成了kvm_init的执行，所有这样就清楚KVM调用关系了。<br>如此就先去看kvm_init函数，前面主要干了一件事，填充KVMState *s结构体，然后通过kvm_ioctl(s, KVM_GET_API_VERSION, 0)判断内核KVM驱动和当前QEMU版本是否兼容，下面则是执行kvm_ioctl(s, KVM_CREATE_VM, type)进行虚拟机的创建活动，创建了KVM虚拟机，获取虚拟机句柄。具体KVM_CREATE_VM在内核态做了什么，ioctl的工作等另外再说，现在假定KVM_CREATE_VM所代表的虚拟机创建成功，下面通过检查kvm_check_extension结果填充KVMState，kvm_arch_init初始化KVMState，其中有IDENTITY_MAP_ADDR，TSS_ADDR，NR_MMU_PAGES等，cpu_register_phys_memory_client注册qemu对内存管理的函数集，kvm_create_irqchip创建kvm中断管理内容，通过kvm_vm_ioctl(s, KVM_CREATE_IRQCHIP)实现，具体内核态的工作内容后面分析。到此kvm_init的工作就完成了，最主要的工作就是创建的虚拟机。</p>
<p>这样绕了这么大圈，重新回到vl.c上面来，前面刚说了module_call_init(MODULE_INIT_MACHINE)本质就是把pc_init1赋值给了mc-&gt;init，然后machine_class = find_default_machine()，如此可以看到machine_class的init函数一定会执行pc_init1。</p>
<p>下面涉及对OPT入参的解析过程略过不提。 qemu准备模拟的机器的类型从下面语句获得:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">current_machine = MACHINE(object_new(object_class_get_name( OBJECT_CLASS(machine_class))));</div></pre></td></tr></table></figure>
<p>machine_class则是通过入参传入的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> QEMU_OPTION_machine:</div><div class="line">                olist = qemu_find_opts(<span class="string">"machine"</span>);</div><div class="line">                opts = qemu_opts_parse_noisily(olist, optarg, <span class="literal">true</span>);</div><div class="line">                <span class="keyword">if</span> (!opts) &#123;</div><div class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">break</span>;</div></pre></td></tr></table></figure>
<p>man qemu</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-machine [type=]name[,prop=value[,...]]</div><div class="line">           Select the emulated machine by name.</div><div class="line">           Use <span class="string">"-machine help"</span> to <span class="built_in">list</span> available machines</div></pre></td></tr></table></figure>
<p>下面有cpu_exec_init_all就是执行了qemu的内存结构体的初始化而已，cpudef_init则提供了VCPU的不同型号的模拟，qemu_set_log设置日志输出，kvm对外的日志是从这里配置的。中间的乱七八糟的就忽略掉即可，然后直接到了machine_class-&gt;init(current_machine)函数，其实就是执行了pc_init1。暂且记下来，先看下面的，cpu_synchronize_all_post_init就是内核和qemu数据不一致同步一下。下面的函数没有重要的了，只有vm_start()函数需要记一下，后面会用到。</p>
<p>现在进入pc_init1函数：</p>
<p>在pc_init1中重点看两个函数，pc_cpus_init和pc_memory_init，顾名思义，CPU和内存的初始化，中断，vga等函数的初始化先忽略掉，先看这两个。<br>pc_cpus_init入参是cpu_model，前面说过这是具体的CPU模型，所有X86的CPU模型都在builtin_x86_defs中定义，取其中一个看看</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">       .name = <span class="string">"SandyBridge"</span>,</div><div class="line">       .level = <span class="number">0xd</span>,</div><div class="line">       .vendor = CPUID_VENDOR_INTEL,</div><div class="line">       .family = <span class="number">6</span>,</div><div class="line">       .model = <span class="number">42</span>,</div><div class="line">       .stepping = <span class="number">1</span>,</div><div class="line">       .features[FEAT_1_EDX] =</div><div class="line">           CPUID_VME | CPUID_SSE2 | CPUID_SSE | CPUID_FXSR | CPUID_MMX |</div><div class="line">           CPUID_CLFLUSH | CPUID_PSE36 | CPUID_PAT | CPUID_CMOV | CPUID_MCA |</div><div class="line">           CPUID_PGE | CPUID_MTRR | CPUID_SEP | CPUID_APIC | CPUID_CX8 |</div><div class="line">           CPUID_MCE | CPUID_PAE | CPUID_MSR | CPUID_TSC | CPUID_PSE |</div><div class="line">           CPUID_DE | CPUID_FP87,</div><div class="line">       .features[FEAT_1_ECX] =</div><div class="line">           CPUID_EXT_AVX | CPUID_EXT_XSAVE | CPUID_EXT_AES |</div><div class="line">           CPUID_EXT_TSC_DEADLINE_TIMER | CPUID_EXT_POPCNT |</div><div class="line">           CPUID_EXT_X2APIC | CPUID_EXT_SSE42 | CPUID_EXT_SSE41 |</div><div class="line">           CPUID_EXT_CX16 | CPUID_EXT_SSSE3 | CPUID_EXT_PCLMULQDQ |</div><div class="line">           CPUID_EXT_SSE3,</div><div class="line">       .features[FEAT_8000_0001_EDX] =</div><div class="line">           CPUID_EXT2_LM | CPUID_EXT2_RDTSCP | CPUID_EXT2_NX |</div><div class="line">           CPUID_EXT2_SYSCALL,</div><div class="line">       .features[FEAT_8000_0001_ECX] =</div><div class="line">           CPUID_EXT3_LAHF_LM,</div><div class="line">       .features[FEAT_XSAVE] =</div><div class="line">           CPUID_XSAVE_XSAVEOPT,</div><div class="line">       .features[FEAT_6_EAX] =</div><div class="line">           CPUID_6_EAX_ARAT,</div><div class="line">       .xlevel = <span class="number">0x80000008</span>,</div><div class="line">       .model_id = <span class="string">"Intel Xeon E312xx (Sandy Bridge)"</span>,</div><div class="line">   &#125;,</div></pre></td></tr></table></figure>
<p>你可以cat一个本地的/proc/cpuinfo，builtin_x86_defs定义的就是这些参数。<br>然后是for循环中针对每个CPU初始化，即pc_new_cpu，直接进入cpu_x86_create函数，<br>主要就是把CPUX86State填充了一下，涉及到CPUID和其他的feature。下面是x86_cpu_realize，即唤醒CPU，重点是qemu_init_vcpu，MCE忽略掉，走到qemu_kvm_start_vcpu，qemu创建VCPU，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建VPU对于的qemu线程，线程函数是qemu_kvm_cpu_thread_fn</span></div><div class="line">    qemu_thread_create(cpu-&gt;thread, thread_name, qemu_kvm_cpu_thread_fn,</div><div class="line">                       cpu, QEMU_THREAD_JOINABLE);</div><div class="line">    <span class="comment">//如果线程没有创建成功，则一直在此处循环阻塞。说明多核vcpu的创建是顺序的</span></div><div class="line">    <span class="keyword">while</span> (!cpu-&gt;created) &#123;</div><div class="line">        qemu_cond_wait(&amp;qemu_cpu_cond, &amp;qemu_global_mutex);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>线程创建完成，具体任务支线提，回到主流程上，qemu_init_vcpu执行完成后，下面就是cpu_reset，此处的作用是什么呢？答案是无用，本质是一个空函数，它的主要功能就是CPUClass的reset函数，reset在cpu_class_init里面注册的，注册的是cpu_common_reset，这是一个空函数，没有任何作用。cpu_class_init则是被cpu_type_info即TYPE_CPU使用，而cpu_type_info则由type_init(cpu_register_types)完成，type_init则是前面提到的和machine_init对应的注册关系。根据下句完成工作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">C</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> type_init(function) module_init(function, MODULE_INIT_QOM)</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> type_init(function) module_init(function, MODULE_INIT_QOM)</span></div></pre></td></tr></table></figure>
<p>从上面看，pc_cpus_init函数过程已经理顺了，下面看一下，vcpu所在的线程对应的qemu_kvm_cpu_thread_fn中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//初始化VCPU</span></div><div class="line">    r = kvm_init_vcpu(env);</div><div class="line"><span class="comment">//初始化KVM中断</span></div><div class="line">    qemu_kvm_init_cpu_signals(env);</div><div class="line"></div><div class="line"><span class="comment">//标志VCPU创建完成，和上面判断是对应的</span></div><div class="line">    cpu-&gt;created = <span class="literal">true</span>;</div><div class="line">    qemu_cond_signal(&amp;qemu_cpu_cond);</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (cpu_can_run(env)) &#123;</div><div class="line">          <span class="comment">//CPU进入执行状态</span></div><div class="line">            r = kvm_cpu_exec(env);</div><div class="line">            <span class="keyword">if</span> (r == EXCP_DEBUG) &#123;</div><div class="line">                cpu_handle_guest_debug(env);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        qemu_kvm_wait_io_event(env);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>CPU进入执行状态的时候我们看到其他的VCPU包括内存可能还没有初始化，关键是此处有一个开关，qemu_cpu_cond,打开这个开关才能进入到CPU执行状态，谁来打开这个开关，后面再说。先看kvm_init_vcpu，通过kvm_vm_ioctl，KVM_CREATE_VCPU创建VCPU，用KVM_GET_VCPU_MMAP_SIZE获取env-&gt;kvm_run对应的内存映射，kvm_arch_init_vcpu则填充对应的kvm_arch内容，具体内核部分，后面单独写。kvm_init_vcpu就是获取了vcpu，将相关内容填充了env。<br>qemu_kvm_init_cpu_signals则是将中断组合掩码传递给kvm_set_signal_mask，最终给内核KVM_SET_SIGNAL_MASK。kvm_cpu_exec此时还在阻塞过程中，先挂起来，看内存的初始化。<br>内存初始化函数是pc_memory_init,memory_region_init_ram传入了高端内存和低端内存的值，memory_region_init负责填充mr，重点在qemu_ram_alloc，即qemu_ram_alloc_from_ptr，首先有RAMBlock，ram_list，那就直接借助find_ram_offset函数一起看一下qemu的内存分布模型。</p>
<figure><br>    <a href="http://oij0laovn.bkt.clouddn.com/kvmsource203.bmp" target="_blank" rel="external"><img src="http://oij0laovn.bkt.clouddn.com/kvmsource203.bmp" width="450"></a><br>    <figcaption></figcaption><br></figure>

<p>qemu模拟了普通内存分布模型，内存的线性也是分块被使用的，每个块称为RAMBlock，由ram_list统领，RAMBlock.offset则是区块的线性地址，即相对于开始的偏移位，RAMBlock.length(size)则是区块的大小，find_ram_offset则是在线性区间内找到没有使用的一段空间，可以完全容纳新申请的ramblock length大小，代码就是进行了所有区块的遍历，找到满足新申请length的最小区间，把ramblock安插进去即可，返回的offset即是新分配区间的开始地址。<br>而RAMBlock的物理则是在RAMBlock.host,由kvm_vmalloc(size)分配真正物理内存，内部qemu_vmalloc使用qemu_memalign页对齐分配内存。后续的都是对RAMBlock的插入等处理。<br>从上面看，memory_region_init_ram已经将qemu内存模型和实际的物理内存初始化了。<br>vmstate_register_ram_global这个函数则是负责将前面提到的ramlist中的ramblock和memory region的初始地址对应一下，将mr-&gt;name填充到ramblock的idstr里面，就是让二者有确定的对应关系，如此mr就有了物理内存使用。<br>后面则是subregion的处理，memory_region_init_alias初始化，其中将ram传递给mr-&gt;owner确定了隶属关系，memory_region_add_subregion则是大头，memory_region_add_subregion_common前面的判断忽略，QTAILQ_INSERT_TAIL(&amp;mr-&gt;subregions, subregion, subregions_link)就是插入了链表而已，主要内容在memory_region_transaction_commit。<br>memory_region_transaction_commit中引入了新的结构address_spaces（AS），注释里面提到“AddressSpace: describes a mapping of addresses to #MemoryRegion objects”，就是内存地址的映射关系，因为内存有不同的应用类型，address_spaces以链表形式存在，commit函数则是对所有AS执行address_space_update_topology，先看AS在哪里注册的，就是前面提到的kvm_init里面，执行memory_listener_register，注册了address_space_memory和address_space_io两个，涉及的另外一个结构体则是MemoryListener，有kvm_memory_listener和kvm_io_listener，就是用于监控内存映射关系发生变化之后执行回调函数。<br>下面进入到address_space_update_topology函数，FlatView则是“Flattened global view of current active memory hierarchy”，address_space_get_flatview直接获取当前的，generate_memory_topology则根据前面已经变化的mr重新生成FlatView,然后通过address_space_update_topology_pass比较，简单说address_space_update_topology_pass就是两个FlatView逐条的FlatRange进行对比，以后一个FlatView为准，如果前面FlatView的FlatRange和后面的不一样，则对前面的FlatView的这条FlatRange进行处理，差别就是3种情况，如代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (iold &lt; old_view-&gt;nr || inew &lt; new_view-&gt;nr) &#123;</div><div class="line">        <span class="keyword">if</span> (iold &lt; old_view-&gt;nr) &#123;</div><div class="line">            frold = &amp;old_view-&gt;ranges[iold];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            frold = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (inew &lt; new_view-&gt;nr) &#123;</div><div class="line">            frnew = &amp;new_view-&gt;ranges[inew];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            frnew = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (frold</div><div class="line">            &amp;&amp; (!frnew</div><div class="line">                || int128_lt(frold-&gt;addr.start, frnew-&gt;addr.start)</div><div class="line">                || (int128_eq(frold-&gt;addr.start, frnew-&gt;addr.start)</div><div class="line">                    &amp;&amp; !flatrange_equal(frold, frnew)))) &#123;</div><div class="line">            <span class="comment">/* In old but not in new, or in both but attributes changed. */</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!adding) &#123; <span class="comment">//这个判断代码添加的无用，可以直接删除,</span></div><div class="line">                <span class="comment">//address_space_update_topology里面的两个pass也可以删除一个</span></div><div class="line">                MEMORY_LISTENER_UPDATE_REGION(frold, as, Reverse, region_del);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ++iold;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frold &amp;&amp; frnew &amp;&amp; flatrange_equal(frold, frnew)) &#123;</div><div class="line">            <span class="comment">/* In both and unchanged (except logging may have changed) */</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (adding) &#123;</div><div class="line">                MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_nop);</div><div class="line">                <span class="keyword">if</span> (frold-&gt;dirty_log_mask &amp;&amp; !frnew-&gt;dirty_log_mask) &#123;</div><div class="line">                    MEMORY_LISTENER_UPDATE_REGION(frnew, as, Reverse, log_stop);</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frnew-&gt;dirty_log_mask &amp;&amp; !frold-&gt;dirty_log_mask) &#123;</div><div class="line">                    MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, log_start);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ++iold;</div><div class="line">            ++inew;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">/* In new */</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (adding) &#123;</div><div class="line">                MEMORY_LISTENER_UPDATE_REGION(frnew, as, Forward, region_add);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ++inew;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>重点在MEMORY_LISTENER_UPDATE_REGION函数上，将变化的FlatRange构造一个MemoryRegionSection，然后遍历所有的memory_listeners，如果memory_listeners监控的内存区域和MemoryRegionSection一样，则执行第四个入参函数，如region_del函数，即kvm_region_del函数，这个是在kvm_init中初始化的。kvm_region_del主要是kvm_set_phys_mem函数，主要是将MemoryRegionSection有效值转换成KVMSlot形式，在kvm_set_user_memory_region中使用kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &amp;mem)传递给kernel。<br>我们看内存初始化真正需要做的是什么？就是qemu申请内存，把申请物理地址传递给kernel进行映射，那我们直接就可以KVMSlot申请内存，然后传递给kvm_vm_ioctl，这样也是OK的，之所以有这么多代码，因为qemu本身是一个软件虚拟机，mr涉及的地址已经是vm的地址，对于KVM是多余的，只是方便函数复用而已。<br>内存初始化之后还是pci等处理先跳过，如此pc_init就完成了，但是前面VM线程已经初始化成功，在qemu_kvm_cpu_thread_fn函数中等待运行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (cpu_can_run(cpu)) &#123;</div><div class="line">            r = kvm_cpu_exec(cpu);</div><div class="line">            <span class="keyword">if</span> (r == EXCP_DEBUG) &#123;</div><div class="line">                cpu_handle_guest_debug(cpu);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        qemu_kvm_wait_io_event(cpu);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>判断条件就是cpu_can_run函数，即cpu-&gt;stop &amp;&amp; cpu-&gt;stopped &amp;&amp; current_run_state ！= running 都是false，而这几个参数都是由vm_start函数决定的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">vm_start</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!runstate_is_running()) &#123;</div><div class="line">        cpu_enable_ticks();</div><div class="line">        runstate_set(RUN_STATE_RUNNING);</div><div class="line">        vm_state_notify(<span class="number">1</span>, RUN_STATE_RUNNING);</div><div class="line">        resume_all_vcpus();</div><div class="line">        monitor_protocol_event(QEVENT_RESUME, <span class="literal">NULL</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如此kvm_cpu_exec就真正进入执行阶段，即通过kvm_vcpu_ioctl传递KVM_RUN给内核。</p>
<p>《<a href="http://www.csyssec.org/20170104/kvmsource-cpu/" target="_blank" rel="external">KVM源码分析之CPU虚拟化</a>》</p>
<p>—结束—</p>
<hr>
<p><strong>转载本文请务必注明</strong>，文章出处：《<a href="http://www.csyssec.org/20170104/kvmsource-create/" target="_blank" rel="external">KVM源码分析之虚拟机的创建与运行</a>》</p>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/虚拟化原理/">虚拟化原理<span class="article-category-count">7</span></a>


      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KVM/">KVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/QEMU/">QEMU</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtualization/">Virtualization</a></li></ul>

      
        
	<div id="comment">
	
	<!-- 多说评论框 start -->
	 <div class="ds-thread" data-thread-key="/20170104/kvmsource-create/" data-title="KVM源码分析之虚拟机的创建与运行" data-url="http://yoursite.com/20170104/kvmsource-create/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"csyssec"};
	  (function() {
	    var ds = document.createElement('script');
	    ds.type = 'text/javascript';ds.async = true;
	    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	    ds.charset = 'UTF-8';
	    (document.getElementsByTagName('head')[0] 
	     || document.getElementsByTagName('body')[0]).appendChild(ds);
	  })();
	  </script>
	<!-- 多说公共JS代码 end -->
	
	</div>
	<link rel="stylesheet" href="/css/comment.css">


      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/20170104/kvmsource-cpu/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          KVM源码分析之CPU虚拟化
        
      </div>
    </a>
  
  
    <a href="/20170104/kvmsource-intro/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">KVM源码分析之基本工作原理</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
    <ol class="toc">无</ol>
    
    </div>
  </aside>
</section>
        
      </div>
      <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      版权所有&copy; 2017 Index of Computer System and Security 保留所有权利.
      </div>
      <div class="site-credit">
       <!--  自豪地使用 <a href="https://github.com/iTimeTraveler/hexo-theme-hiero" target="_blank">hiero</a> --> 
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
</script>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/syssec" class="mobile-nav-link">Syssec</a>
  
    <a href="/architecture" class="mobile-nav-link">Architecture</a>
  
    <a href="/virtualization" class="mobile-nav-link">Virtualization</a>
  
    <a href="/malware" class="mobile-nav-link">Malware</a>
  
    <a href="/conferences" class="mobile-nav-link">Conferences</a>
  
    <a href="/courses" class="mobile-nav-link">Courses</a>
  
    <a href="/academy" class="mobile-nav-link">Academy</a>
  
    <a href="/contribution" class="mobile-nav-link">Contribution</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>





  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
  

  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1261078922&web_id=1261078922" language="JavaScript"></script>
  </div>


</body>
</html>
